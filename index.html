// Streaming response handler v2 - supports tools
async function handleStreamingResponse(response) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  const messagesDiv = document.getElementById('askAIMessages');
  const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  
  const msgDiv = document.createElement('div');
  msgDiv.className = 'ask-ai-message ai';
  msgDiv.innerHTML = '<div class="ask-ai-bubble"><span class="streaming-text"></span><span class="streaming-indicator"></span></div><div class="ask-ai-time">' + time + '</div>';
  messagesDiv.appendChild(msgDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
  
  const textSpan = msgDiv.querySelector('.streaming-text');
  const indicator = msgDiv.querySelector('.streaming-indicator');
  let fullText = '';
  let buffer = '';
  let createDropData = null;
  
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') break;
          try {
            const parsed = JSON.parse(data);
            
            // New API v4.5 format
            if (parsed.type === 'text' && parsed.content) {
              fullText += parsed.content;
              textSpan.textContent = fullText;
              messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            // Tool started
            if (parsed.type === 'tool_start' && indicator) {
              indicator.textContent = toolStatusText(parsed.tool);
              indicator.classList.add('tool-active');
            }
            
            // Tool completed
            if (parsed.type === 'tool_result' && indicator) {
              indicator.classList.remove('tool-active');
              indicator.textContent = '';
            }
            
            // Stream done
            if (parsed.type === 'done') {
              createDropData = parsed.createDrop;
            }
            
            // Error
            if (parsed.type === 'error') {
              console.error('Stream error:', parsed.error);
            }
            
            // Legacy format (v4.4 and earlier)
            if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
              fullText += parsed.delta.text;
              textSpan.textContent = fullText;
              messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
          } catch (e) {}
        }
      }
    }
  } catch (e) {
    console.error('Streaming error:', e);
  }
  
  if (indicator) indicator.remove();
  
  const bubble = msgDiv.querySelector('.ask-ai-bubble');
  const actionsDiv = document.createElement('div');
  actionsDiv.className = 'ask-ai-actions';
  actionsDiv.innerHTML = '<button class="ask-ai-action-btn" onclick="copyAskAIMessage(this)">Copy</button><button class="ask-ai-action-btn" onclick="speakAskAIMessage(this)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg> Speak</button><button class="ask-ai-action-btn" onclick="createDropFromAI(this)">Create Drop</button>';
  bubble.after(actionsDiv);
  
  askAIMessages.push({ text: fullText, isUser: false });
  
  // Handle create_drop from tool
  if (createDropData?.drop) {
    const drop = createDropData.drop;
    const newIdea = { id: Date.now().toString(), text: drop.text, category: drop.category || 'inbox', date: new Date().toISOString().split('T')[0], time: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false }), isMedia: false };
    ideas.unshift(newIdea);
    save();
    render();
    toast('Drop created by Aski', 'success');
  }
  
  if (isAutoDropEnabled()) autoSaveMessageAsDrop(fullText, false);
  
  if (isAutoSpeakEnabled() && fullText) {
    try { speakText(fullText); } catch (e) { console.error('TTS error:', e); unlockVoiceMode(); }
  } else {
    unlockVoiceMode();
  }
}

function toolStatusText(toolName) {
  const names = { 'web_search': 'Searching...', 'create_drop': 'Creating drop...', 'fetch_recent_drops': 'Reading notes...', 'search_drops': 'Searching notes...', 'get_summary': 'Summarizing...' };
  return names[toolName] || 'Processing...';
}
