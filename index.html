<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1E293B">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="DropLit">
  <meta name="application-name" content="DropLit">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="format-detection" content="telephone=no">
  <meta name="description" content="DropLit - Voice-first idea capture app. Never lose your ideas again.">
  <title>DropLit</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-32.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root {
      --color-primary: #FF6B4A;
      --color-primary-dark: #E85A3A;
      --color-primary-light: #FF8A70;
      --color-recording: #EF4444;
      --color-success: #10B981;
      --color-warning: #F59E0B;
      --color-error: #EF4444;
      --color-merge: #8B5CF6;
      --color-bg: #F5F5F4;
      --color-bg-card: #FFFFFF;
      --color-bg-soft: #E7E5E4;
      --color-bg-btn: #E7E5E4;
      --color-text: #1C1917;
      --color-text-soft: #57534E;
      --color-text-muted: #78716C;
      --color-border: #D6D3D1;
      --color-active: #FF6B4A;
      --cat-tasks-bg: #FEF3C7; --cat-tasks-text: #92400E;
      --cat-ideas-bg: #E0E7FF; --cat-ideas-text: #3730A3;
      --cat-handmagic-bg: #FCE7F3; --cat-handmagic-text: #9D174D;
      --cat-design-bg: #D1FAE5; --cat-design-text: #065F46;
      --cat-bugs-bg: #FEE2E2; --cat-bugs-text: #991B1B;
      --cat-questions-bg: #E0F2FE; --cat-questions-text: #075985;
      --cat-sketch-bg: #FEE2E2; --cat-sketch-text: #DC2626;
      --cat-scan-bg: #DBEAFE; --cat-scan-text: #1D4ED8;
      --cat-photo-bg: #F3E8FF; --cat-photo-text: #7C3AED;
      --cat-audio-bg: #FEF9C3; --cat-audio-text: #854D0E;
      --cat-inbox-bg: #F5F5F4; --cat-inbox-text: #57534E;
      --font-main: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-full: 9999px;
      --shadow-card: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
      --shadow-fab: 0 4px 14px rgba(255,107,74,0.4);
      --shadow-scroll: 0 2px 10px rgba(0,0,0,0.1);
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; overflow: hidden; touch-action: manipulation; }
    body { font-family: var(--font-main); background: var(--color-bg); color: var(--color-text); -webkit-font-smoothing: antialiased; }
    
    .app { display: flex; flex-direction: column; height: 100vh; height: 100dvh; max-width: 480px; margin: 0 auto; background: var(--color-bg); position: relative; padding-top: var(--safe-top); }

 /* Header */
    .header { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; background: var(--color-bg-card); position: relative; padding-top: max(10px, env(safe-area-inset-top)); z-index: 100; }
    .header::after { content: ''; position: absolute; left: 0; right: 0; bottom: -8px; height: 8px; background: linear-gradient(to bottom, rgba(0,0,0,0.06), transparent); pointer-events: none; z-index: 99; }
    body.filters-visible .header::after { display: none; }
.logo-btn { width: 48px; height: 48px; border: none; background: var(--color-bg-soft); border-radius: var(--radius-full); cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.2s; color: var(--color-text-soft); }
    .logo-btn:active { opacity: 0.7; transform: scale(0.95); }
    .logo-btn svg { width: 22px; height: 22px; transition: transform 0.3s; }
    body.filters-visible .logo-btn svg { transform: rotate(180deg); }
    
    /* Filters toggle - hidden by default */
    .filters-wrap { position: relative; z-index: 99; }
    .filters-wrap::after { content: ''; position: absolute; left: 0; right: 0; top: 100%; height: 10px; background: linear-gradient(to bottom, rgba(0,0,0,0.08), transparent); pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100; }
    body.filters-visible .filters-wrap::after { opacity: 1; }
    .filters { max-height: 0; overflow: hidden; opacity: 0; transition: max-height 0.3s ease, opacity 0.2s ease, padding 0.3s ease; padding: 0; background: var(--color-bg-card); }
    body.filters-visible .filters { max-height: 200px; opacity: 1; padding: 8px 10px; }
	body.filters-visible .logo-btn { background: var(--color-bg-soft); }
    .header-title { position: absolute; left: 50%; transform: translateX(-50%); font-family: var(--font-main); font-size: 1.1rem; font-weight: 800; letter-spacing: 0.5px; display: flex; align-items: center; gap: 4px; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
    .title-drop { color: #FF6B4A; }
    .title-lit { color: #06B6D4; }
    .header-add-btn { position: absolute; left: 50%; transform: translateX(-50%); display: flex; align-items: center; justify-content: center; gap: 6px; height: 48px; padding: 0 20px; background: linear-gradient(135deg, #8B5CF6, #7C3AED); border: none; border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.8rem; font-weight: 700; color: white; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; transition: all 0.15s; box-shadow: 0 3px 12px rgba(139,92,246,0.3); }
    .header-add-btn:hover { transform: translateX(-50%) scale(1.03); box-shadow: 0 4px 14px rgba(139,92,246,0.4); }
    .header-add-btn:active { transform: translateX(-50%) scale(0.97); }
    .header-add-btn svg { width: 12px; height: 12px; }
    body.chat-open .header-add-btn { display: none; }
	.btn-icon { width: 48px; height: 48px; border: none; background: var(--color-bg-soft); border-radius: var(--radius-full); cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--color-text-soft); flex-shrink: 0; transition: all 0.15s; }
    .btn-icon:active { opacity: 0.7; transform: scale(0.95); }

    .network-banner { display: none; padding: 6px; background: var(--color-error); color: white; font-size: 0.7rem; font-weight: 600; text-align: center; }
    .network-banner.show { display: block; }
    .warning { padding: 8px; background: #FEF3C7; color: #92400E; font-size: 0.75rem; text-align: center; font-weight: 600; display: none; }

    /* Filters */
    .time-row { display: flex; justify-content: center; gap: 6px; margin-bottom: 8px; }
    .time-btn { height: 34px; padding: 0 12px; border: 2px solid transparent; background: var(--color-bg-btn); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.7rem; font-weight: 600; color: var(--color-text-soft); cursor: pointer; text-transform: uppercase; display: flex; align-items: center; gap: 5px; transition: all 0.15s; }
    .time-btn:active { transform: scale(0.97); }
    .time-btn[data-time="all"] { background: var(--color-primary); color: white; border-color: var(--color-primary); }
    .time-btn[data-time="all"] .cnt { background: rgba(255,255,255,0.25); color: white; }
    .time-btn:not([data-time="all"]).active { border-color: var(--color-active); background: var(--color-bg-btn); color: var(--color-text-soft); }
    .time-btn:not([data-time="all"]).active .cnt { background: var(--color-active); color: white; }
    .cnt { min-width: 20px; height: 20px; padding: 0 6px; background: rgba(0,0,0,0.08); border-radius: var(--radius-full); font-size: 0.65rem; font-weight: 700; display: inline-flex; align-items: center; justify-content: center; }
    .sort-btn { height: 34px; width: 40px; padding: 0; border: 2px solid transparent; background: var(--color-bg-btn); border-radius: var(--radius-full); font-size: 0.9rem; font-weight: 600; color: var(--color-text-soft); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .sort-btn:active { transform: scale(0.97); }
    .sort-btn.desc { border-color: var(--color-active); }

    .cat-row { display: flex; gap: 6px; overflow-x: auto; scrollbar-width: none; scroll-behavior: smooth; padding: 2px 4px; }
    .cat-row::-webkit-scrollbar { display: none; }
    .cat { flex-shrink: 0; height: 34px; padding: 0 12px; border: 2px solid transparent; border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.65rem; font-weight: 700; cursor: pointer; text-transform: uppercase; display: flex; align-items: center; gap: 5px; transition: all 0.15s; }
    .cat:active { transform: scale(0.97); }
    .cat.active { border-color: var(--color-active); }
    .cat[data-category="tasks"] { background: var(--cat-tasks-bg); color: var(--cat-tasks-text); }
    .cat[data-category="tasks"] .cnt { background: rgba(146,64,14,0.15); }
    .cat[data-category="ideas"] { background: var(--cat-ideas-bg); color: var(--cat-ideas-text); }
    .cat[data-category="ideas"] .cnt { background: rgba(55,48,163,0.15); }
    .cat[data-category="handmagic"] { background: var(--cat-handmagic-bg); color: var(--cat-handmagic-text); }
    .cat[data-category="handmagic"] .cnt { background: rgba(157,23,77,0.15); }
    .cat[data-category="design"] { background: var(--cat-design-bg); color: var(--cat-design-text); }
    .cat[data-category="design"] .cnt { background: rgba(6,95,70,0.15); }
    .cat[data-category="bugs"] { background: var(--cat-bugs-bg); color: var(--cat-bugs-text); }
    .cat[data-category="bugs"] .cnt { background: rgba(153,27,27,0.15); }
    .cat[data-category="questions"] { background: var(--cat-questions-bg); color: var(--cat-questions-text); }
    .cat[data-category="questions"] .cnt { background: rgba(7,89,133,0.15); }
    .cat[data-category="inbox"] { background: var(--color-bg-btn); color: var(--cat-inbox-text); }
    .cat[data-category="inbox"] .cnt { background: rgba(0,0,0,0.08); }
    .cat[data-category="photo"] { background: var(--cat-photo-bg); color: var(--cat-photo-text); }
    .cat[data-category="photo"] .cnt { background: rgba(124,58,237,0.15); }
    .cat[data-category="sketch"] { background: var(--cat-sketch-bg); color: var(--cat-sketch-text); }
    .cat[data-category="sketch"] .cnt { background: rgba(220,38,38,0.15); }
    .cat[data-category="scan"] { background: var(--cat-scan-bg); color: var(--cat-scan-text); }
    .cat[data-category="scan"] .cnt { background: rgba(29,78,216,0.15); }
    .cat-add { flex-shrink: 0; width: 34px; height: 34px; border: 2px dashed var(--color-border); border-radius: var(--radius-full); background: transparent; color: var(--color-text-muted); font-size: 1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .cat-add:active { border-color: var(--color-primary); color: var(--color-primary); }

    /* Ideas container */
    .ideas-wrap { flex: 1; overflow-y: auto; padding: 12px 14px 100px; -webkit-overflow-scrolling: touch; position: relative; z-index: 1; }
    .ideas { display: flex; flex-direction: column; gap: 2px; }
    .date-sep { display: flex; align-items: center; justify-content: center; padding: 16px 0 8px; font-size: 0.65rem; font-weight: 700; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.08em; }

    /* Card */
    .card { background: var(--color-bg-card); border-radius: var(--radius-md); padding: 12px 14px; box-shadow: var(--shadow-card); cursor: pointer; transition: all 0.15s; margin-bottom: 8px; position: relative; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
    .card.active { box-shadow: 0 0 0 2px #8B5CF6, var(--shadow-card); }
    .card.editing { box-shadow: 0 0 0 2px #8B5CF6, var(--shadow-card); }
    .card.selected { box-shadow: 0 0 0 2px var(--color-merge), var(--shadow-card); background: #F5F3FF; }
    /* Checkbox removed in v0.8.2 */
    .card-checkbox { display: none !important; }
    .card-head { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    .card-chars { font-size: 0.7rem; color: var(--color-text-muted); font-weight: 500; }
    .card-time { font-size: 0.7rem; color: var(--color-text-muted); font-weight: 500; margin-left: auto; }
    .card-cat { padding: 4px 10px; border-radius: var(--radius-full); font-size: 0.6rem; font-weight: 700; text-transform: uppercase; cursor: pointer; letter-spacing: 0.02em; }
    .card-cat:active { opacity: 0.8; }
    .card-cat.tasks { background: var(--cat-tasks-bg); color: var(--cat-tasks-text); }
    .card-cat.ideas { background: var(--cat-ideas-bg); color: var(--cat-ideas-text); }
    .card-cat.handmagic { background: var(--cat-handmagic-bg); color: var(--cat-handmagic-text); }
    .card-cat.design { background: var(--cat-design-bg); color: var(--cat-design-text); }
    .card-cat.bugs { background: var(--cat-bugs-bg); color: var(--cat-bugs-text); }
    .card-cat.questions { background: var(--cat-questions-bg); color: var(--cat-questions-text); }
    .card-cat.inbox { background: var(--color-bg-btn); color: var(--cat-inbox-text); }
    .card-cat.sketch { background: var(--cat-sketch-bg); color: var(--cat-sketch-text); }
    
    /* Card markers */
    .card-marker { font-size: 0.9rem; margin-left: 6px; opacity: 0.9; }
    .card-marker.pop { animation: markerPop 0.2s ease; }
    @keyframes markerPop { 0% { transform: scale(0); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
    
    /* Markers panel (shown when card is active) - BELOW actions */
    .card-markers { display: none; flex-wrap: wrap; gap: 6px; padding: 10px 12px; margin-top: 12px; border-top: 1px solid var(--color-border); background: var(--color-bg-btn); border-radius: var(--radius-md); }
    .card.active .card-markers { display: flex; }
    .marker-btn { width: 36px; height: 36px; border: none; background: var(--color-bg-card); border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.15s; opacity: 0.4; }
    .marker-btn:hover { opacity: 0.7; transform: scale(1.1); }
    .marker-btn:active { transform: scale(0.95); }
    .marker-btn.active { opacity: 1; background: var(--color-bg); box-shadow: 0 0 0 2px var(--color-primary); }
    .card-cat.scan { background: var(--cat-scan-bg); color: var(--cat-scan-text); }
    .card-cat.photo { background: var(--cat-photo-bg); color: var(--cat-photo-text); }
    .card-cat.audio { background: var(--cat-audio-bg); color: var(--cat-audio-text); }
    
    /* Audio Player in Card */
    .card-audio-player {
      background: linear-gradient(135deg, #FEF9C3 0%, #FDE68A 100%);
      border-radius: var(--radius-md);
      padding: 16px;
      margin: 8px 0;
      border: 2px solid transparent;
    }
    .card.active .card-audio-player {
      border-color: #8B5CF6;
    }
    .audio-waveform {
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      margin-bottom: 12px;
    }
    .audio-waveform-bar {
      width: 3px;
      background: rgba(133,77,14,0.3);
      border-radius: 2px;
      transition: background 0.1s;
    }
    .audio-waveform-bar.played {
      background: var(--color-primary);
    }
    .audio-controls {
      display: none;
    }
    .card.active .audio-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .audio-btn {
      padding: 8px 16px;
      border: none;
      border-radius: var(--radius-full);
      background: rgba(133,77,14,0.15);
      color: #854D0E;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      transition: all 0.15s;
    }
    .audio-btn:active {
      transform: scale(0.95);
    }
    .audio-btn.play {
      padding: 12px 24px;
      background: var(--color-primary);
      color: white;
      font-size: 0.85rem;
    }
    .audio-btn.play:active {
      background: var(--color-primary-dark);
    }
    .audio-time {
      display: flex;
      justify-content: space-between;
      color: #854D0E;
      font-size: 0.75rem;
      margin-top: 8px;
      opacity: 0.7;
    }
    .audio-format {
      text-align: center;
      font-size: 0.65rem;
      color: #854D0E;
      opacity: 0.5;
      margin-top: 4px;
      text-transform: uppercase;
    }
    
    .card-text { font-size: 1.05rem; line-height: 1.5; color: var(--color-text); padding-right: 30px; }
    .card-text a { color: var(--color-primary); text-decoration: underline; word-break: break-all; }
    .card-text a:active { opacity: 0.7; }
    .card-text.truncated { max-height: 500px; overflow: hidden; position: relative; } /* ~20 lines for text drops */
    .card-text.truncated::after { content: ''; position: absolute; bottom: 0; left: 0; right: 30px; height: 40px; background: linear-gradient(transparent, var(--color-bg-card)); pointer-events: none; }
    .card-text.expanded { max-height: none !important; }
    .card-text.expanded::after { display: none; }
    .card-image { width: 100%; max-height: 200px; object-fit: cover; border-radius: var(--radius-sm); margin-bottom: 8px; cursor: pointer; }
    .card-image:active { opacity: 0.9; }
    .card-media-meta { font-size: 0.7rem; color: var(--color-text-muted); display: flex; gap: 10px; margin-bottom: 4px; }
    .card-notes { font-size: 0.85rem; color: var(--color-text-soft); line-height: 1.4; max-height: 60px; overflow: hidden; position: relative; } /* ~2-3 lines for photo captions */
    .card-notes::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 25px; background: linear-gradient(transparent, var(--color-bg-card)); pointer-events: none; }
    .card-notes.expanded { max-height: none; }
    .card-notes.expanded::after { display: none; }
    .card-more { display: none; padding: 8px 0 4px; font-size: 0.8rem; color: var(--color-primary); font-weight: 600; cursor: pointer; }
    .card-more.show { display: block; }
    /* No extra padding - checkboxes removed */
    .card-edit { display: none; margin-top: 10px; }
    .card.editing .card-text { display: none; }
    .card.editing .card-edit { display: block; }
    .card-ta { width: 100%; min-height: 180px; padding: 12px; border: 1px solid var(--color-border); border-radius: var(--radius-sm); font-family: var(--font-main); font-size: 1.05rem; line-height: 1.5; color: var(--color-text); resize: vertical; background: var(--color-bg); user-select: text; -webkit-user-select: text; -webkit-touch-callout: default; }
    .card-ta:focus { outline: none; border-color: var(--color-primary); }
    
    .card-actions { display: none; gap: 6px; margin-top: 12px; padding-top: 10px; border-top: 1px solid var(--color-border); overflow-x: auto; scrollbar-width: none; }
    .card-actions::-webkit-scrollbar { display: none; }
    .card.active .card-actions { display: flex; }
    .card.editing .card-actions { display: none; }
    .select-mode .card.active .card-actions { display: none; }
    .card-edit-actions { display: none; gap: 6px; margin-top: 10px; }
    .card.editing .card-edit-actions { display: flex; }
    .act { flex-shrink: 0; height: 34px; padding: 0 12px; border: 2px solid var(--color-border); background: var(--color-bg-btn); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.65rem; font-weight: 700; color: var(--color-text-soft); cursor: pointer; text-transform: uppercase; display: flex; align-items: center; gap: 5px; white-space: nowrap; transition: all 0.15s; }
    .act:active { background: var(--color-bg-soft); }
    .act.primary { background: var(--color-primary); color: white; border-color: transparent; }
    .act.ai { background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white; border-color: transparent; }
    .act.danger { background: rgba(239,68,68,0.1); color: #EF4444; border-color: rgba(239,68,68,0.5); }
    .act.merge { background: var(--color-merge); color: white; border-color: transparent; }
    .act.secondary { background: var(--color-bg-btn); color: var(--color-text-soft); }
    .act.act-tts { background: linear-gradient(135deg, #10B981, #059669); color: white; border-color: transparent; }
    .act.act-tts.playing { background: linear-gradient(135deg, #EF4444, #DC2626); animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.7;} }

    /* Empty state */
    .empty { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; text-align: center; padding: 30px; }
    .empty-icon { width: 120px; height: 120px; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; opacity: 0.12; }
    .empty-icon svg { width: 100px; height: 100px; fill: #3B82F6; }
    .empty-title { font-size: 1.1rem; font-weight: 700; margin-bottom: 6px; color: var(--color-text-muted); }
    .empty-text { font-size: 0.85rem; color: var(--color-text-muted); }

    /* FAB - Record button */
  .fab-record { width: 56px; height: 56px; border: none; background: #06B6D4; border-radius: var(--radius-full); cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(6,182,212,0.4); transition: all 0.2s; }
    .fab-record:active { transform: scale(0.95); }
    .fab-record.recording { background: var(--color-recording); animation: pulse 1.5s ease infinite; box-shadow: 0 4px 14px rgba(239,68,68,0.4); }
    .fab-record svg { width: 24px; height: 24px; color: white; }
    .select-mode .fab-record, .editing-mode .fab-record { display: none; }
    @keyframes pulse { 0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,0.4)} 50%{box-shadow:0 0 0 12px rgba(239,68,68,0)} }

    /* FAB - Camera button */
    .fab-camera { width: 56px; height: 56px; border: none; background: #FF6B4A; border-radius: var(--radius-full); cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 20px rgba(255,107,74,0.4); transition: all 0.2s; flex-shrink: 0; }
    .fab-camera:active { transform: scale(0.95); }
    .fab-camera svg { width: 24px; height: 24px; color: white; }
    .select-mode .fab-camera, .editing-mode .fab-camera { display: none !important; }
    .camera-input { display: none; }

    /* FAB - Plus button (center) */
   .fab-askai { position: fixed; bottom: calc(24px + var(--safe-bottom)); left: 50%; transform: translateX(-50%); height: 52px; padding: 0 24px; border: none; background: #FF6B4A; border-radius: var(--radius-full); cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 20px rgba(255,107,74,0.4); z-index: 50; transition: all 0.2s; animation: askaiPulse 2.5s ease-in-out infinite; font-family: var(--font-main); font-size: 0.85rem; font-weight: 700; color: white; letter-spacing: 1px; text-transform: uppercase; }
    @keyframes askaiPulse { 
      0%, 100% { 
        transform: translateX(-50%) scale(1); 
      } 
      50% { 
        transform: translateX(-50%) scale(1.05); 
      } 
    }
    .fab-askai:hover { animation: none; transform: translateX(-50%) scale(1.05); }
    .fab-askai:active { transform: translateX(-50%) scale(0.97); }
    .fab-askai .sparkle { font-size: 1.1rem; animation: sparkle 1.5s ease-in-out infinite; }
    @keyframes sparkle { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.8; transform: scale(1.15); } }
    .select-mode .fab-askai, .editing-mode .fab-askai { display: none !important; }
	/* FAB Container - bottom bar */
    .fab-container { position: fixed; bottom: 16px; left: 16px; right: 16px; display: flex; justify-content: space-between; align-items: center; z-index: 50; pointer-events: none; padding-bottom: env(safe-area-inset-bottom); }
    .fab-container > * { pointer-events: auto; }
    .fab-pill { height: 48px; min-width: 110px; padding: 0 16px; border: none; background: #FF6B4A; border-radius: var(--radius-full); cursor: pointer; display: flex; align-items: center; justify-content: center; font-family: var(--font-main); font-size: 0.8rem; font-weight: 700; color: white; letter-spacing: 0.5px; text-transform: uppercase; box-shadow: 0 4px 20px rgba(255,107,74,0.4); transition: all 0.2s; }
    .fab-pill:active { transform: scale(0.95); }
    .fab-pill.create { background: #8B5CF6; box-shadow: 0 4px 20px rgba(139,92,246,0.4); }
    .select-mode .fab-container, .editing-mode .fab-container { display: none !important; }

    /* Ask AI Panel - Full Screen Slide Up */
    .ask-ai-panel { position: fixed; inset: 0; top: 0; background: var(--color-bg-card); border-radius: 0; transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); z-index: 1000; display: flex; flex-direction: column; box-shadow: 0 -10px 40px rgba(0,0,0,0.15); }
    .ask-ai-panel.show { transform: translateY(0); }
    .ask-ai-handle { display: none; }
    .ask-ai-handle-bar { display: none; }
    .ask-ai-header { background: linear-gradient(135deg, #8B5CF6, #7C3AED); color: white; padding: 10px 16px; padding-top: max(10px, env(safe-area-inset-top)); display: flex; align-items: center; justify-content: space-between; }
    .ask-ai-header-left { display: flex; align-items: center; gap: 12px; }
    .ask-ai-avatar { width: 48px; height: 48px; background: rgba(255,255,255,0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; }
    .ask-ai-title { font-size: 1.15rem; font-weight: 600; }
    .ask-ai-subtitle { font-size: 0.8rem; opacity: 0.85; }
    /* Speaking indicator removed - status shown in subtitle */
    @keyframes speakPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
    .ask-ai-close { width: 36px; height: 36px; border: none; background: rgba(255,255,255,0.2); border-radius: 50%; color: white; font-size: 1.3rem; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.15s; }
    .ask-ai-close:hover { background: rgba(255,255,255,0.3); }
    .ask-ai-messages { flex: 1; overflow-y: auto; padding: 20px 16px 84px 16px; display: flex; flex-direction: column; gap: 16px; background: var(--color-bg); }
    .ask-ai-message { display: flex; flex-direction: column; max-width: 85%; animation: msgFadeIn 0.3s ease; }
    @keyframes msgFadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    .ask-ai-message.user { align-self: flex-end; }
    .ask-ai-message.ai { align-self: flex-start; }
    .ask-ai-bubble { padding: 12px 16px; border-radius: 18px; font-size: 0.95rem; line-height: 1.5; }
    .ask-ai-message.user .ask-ai-bubble { background: linear-gradient(135deg, #8B5CF6, #7C3AED); color: white; border-bottom-right-radius: 4px; }
    .ask-ai-message.ai .ask-ai-bubble { background: var(--color-bg-card); color: var(--color-text); border: none; box-shadow: 0 1px 2px rgba(0,0,0,0.1); border-bottom-left-radius: 4px; }
    .ask-ai-time { font-size: 0.7rem; color: var(--color-text-muted); margin-top: 4px; padding: 0 6px; }
    .ask-ai-message.user .ask-ai-time { text-align: right; }
    .ask-ai-actions { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
    .ask-ai-message.user .ask-ai-actions { justify-content: flex-end; }
    .ask-ai-action-btn { height: 34px; padding: 0 16px; border: 2px solid var(--color-border); border-radius: var(--radius-full); background: var(--color-bg-card); font-family: var(--font-main); font-size: 0.75rem; font-weight: 600; color: var(--color-text-soft); cursor: pointer; display: inline-flex; align-items: center; gap: 6px; transition: all 0.15s; }
    .ask-ai-action-btn:hover { border-color: var(--color-primary); color: var(--color-primary); }
    .ask-ai-action-btn.speak-btn { border-color: #06B6D4; color: #06B6D4; }
    .ask-ai-action-btn.speak-btn:hover { background: #06B6D4; color: white; }
    .ask-ai-action-btn.created { border-color: #10B981; color: #10B981; cursor: default; }
    .ask-ai-action-btn.created:hover, .ask-ai-action-btn.created:focus, .ask-ai-action-btn.created:active { border-color: #10B981; color: #10B981; outline: none; background: var(--color-bg-card); }
    .ask-ai-action-btn.autodrop-saved { border-color: #10B981; color: #10B981; cursor: default; background: transparent; }
    .ask-ai-action-btn.autodrop-saved:hover, .ask-ai-action-btn.autodrop-saved:focus { border-color: #10B981; color: #10B981; outline: none; background: transparent; }
    .ask-ai-action-btn:focus { outline: none; }
    .ask-ai-action-btn.primary { background: linear-gradient(135deg, #8B5CF6, #7C3AED); border-color: transparent; color: white; }
    .ask-ai-action-btn.primary:hover { transform: scale(1.03); }
    .ask-ai-typing { display: flex; align-items: center; gap: 5px; padding: 14px 18px; background: var(--color-bg-card); box-shadow: 0 1px 2px rgba(0,0,0,0.1); border-radius: 18px; border-bottom-left-radius: 4px; width: fit-content; }
    .ask-ai-typing-dot { width: 8px; height: 8px; background: #8B5CF6; border-radius: 50%; animation: typingPulse 1.4s infinite; }
    .ask-ai-typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .ask-ai-typing-dot:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typingPulse { 0%, 60%, 100% { opacity: 0.3; transform: scale(1); } 30% { opacity: 1; transform: scale(1.2); } }
    .ask-ai-empty { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 24px; text-align: center; }
    .ask-ai-empty-icon { font-size: 4rem; margin-bottom: 20px; }
    .ask-ai-empty-title { font-size: 1.2rem; font-weight: 600; color: var(--color-text); margin-bottom: 8px; }
    .ask-ai-empty-text { font-size: 0.95rem; color: var(--color-text-muted); line-height: 1.5; max-width: 280px; }
    .ask-ai-prompts { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 24px; justify-content: center; }
    .ask-ai-prompt { padding: 10px 16px; background: var(--color-bg-card); border: 2px solid var(--color-border); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.85rem; color: var(--color-text-soft); cursor: pointer; transition: all 0.15s; }
    .ask-ai-prompt:hover { border-color: var(--color-primary); color: var(--color-primary); }
    .ask-ai-input-area { padding: 12px 16px; padding-bottom: max(24px, env(safe-area-inset-bottom)); background: var(--color-bg-card); border-top: 1px solid var(--color-border); flex-shrink: 0; }
    .ask-ai-input-row { display: flex; align-items: flex-end; gap: 10px; }
    .ask-ai-input { flex: 1; padding: 12px 16px; border: 2px solid var(--color-border); border-radius: 16px; font-family: var(--font-main); font-size: 1rem; background: var(--color-bg); color: var(--color-text); outline: none; transition: border-color 0.15s; resize: none; min-height: 44px; max-height: 120px; line-height: 1.4; user-select: text; -webkit-user-select: text; -webkit-touch-callout: default; }
    .ask-ai-input:focus { border-color: var(--color-primary); }
    .ask-ai-input::placeholder { color: var(--color-text-muted); }
	.ask-ai-panel.voice-mode .ask-ai-input-row { display: none !important; }
    .ask-ai-panel.voice-mode .ask-ai-char-count { display: none !important; }
    .ask-ai-panel.voice-mode .ask-ai-voice-large { display: none !important; }
    .ask-ai-panel.voice-mode .ask-ai-input-area { background: transparent; border-top: none; padding: 0; }
    .ask-ai-btn { width: 48px; height: 48px; min-width: 48px; min-height: 48px; max-width: 48px; max-height: 48px; flex: 0 0 48px; align-self: center; border: none; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .ask-ai-btn-voice { background: var(--color-bg); border: 2px solid var(--color-border); color: var(--color-text-soft); }
    .ask-ai-btn-voice:hover { border-color: #FF6B4A; color: #FF6B4A; }
    .ask-ai-btn-voice.recording { background: #FF6B4A; border-color: #FF6B4A; color: white; animation: pulse 1s infinite; }
    .ask-ai-btn-send { background: linear-gradient(135deg, #8B5CF6, #7C3AED); color: white; }
    .ask-ai-btn-send:hover { transform: scale(1.05); }
    .ask-ai-btn-send:disabled { background: var(--color-border); cursor: not-allowed; transform: none; }
    .ask-ai-char-count { text-align: right; font-size: 0.7rem; color: var(--color-text-muted); margin-top: 8px; padding-right: 4px; }
    .ask-ai-char-count.warning { color: #FF6B4A; }
    
    /* Voice Mode: Large mic button */
    .ask-ai-voice-large { display: none; width: 100%; padding: 18px 24px; border: 2px solid var(--color-border); border-radius: var(--radius-full); background: var(--color-bg); color: var(--color-text); font-family: var(--font-main); font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s; align-items: center; justify-content: center; gap: 12px; }
    .ask-ai-voice-large:hover { border-color: #10B981; background: rgba(16, 185, 129, 0.05); }
    .ask-ai-voice-large.listening { border-color: #10B981; background: rgba(16, 185, 129, 0.1); color: #10B981; animation: pulse 1.5s infinite; }
    .ask-ai-voice-large svg { flex-shrink: 0; }
	
	/* Chat Control Buttons - bottom panel */
    .ask-ai-controls-bottom { display: none; position: fixed; bottom: 16px; left: 16px; right: 16px; gap: 12px; padding-bottom: env(safe-area-inset-bottom); z-index: 1001; }
    .ask-ai-panel.show .ask-ai-controls-bottom { display: flex; }
    .ask-ai-control-left, .ask-ai-control-right { flex: 1; height: 52px; border: none; border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.85rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s; }
    .ask-ai-control-left { background: #FF6B4A; color: white; box-shadow: 0 4px 20px rgba(255,107,74,0.4); }
    .ask-ai-control-left:active { opacity: 0.7; transform: scale(0.97); }
    .ask-ai-control-left.stop { background: #EF4444; box-shadow: 0 4px 20px rgba(239,68,68,0.4); }
    .ask-ai-control-right { background: #06B6D4; color: white; box-shadow: 0 4px 20px rgba(6,182,212,0.4); }
    .ask-ai-control-right:active { opacity: 0.7; transform: scale(0.97); }
    .ask-ai-control-right.listening { background: white; color: #06B6D4; border: 3px solid #06B6D4; box-shadow: 0 0 0 0 rgba(6, 182, 212, 0.5); animation: pulse-glow-cyan 1.5s infinite; }
    @keyframes pulse-glow-cyan { 0% { box-shadow: 0 0 0 0 rgba(6, 182, 212, 0.5); } 70% { box-shadow: 0 0 0 15px rgba(6, 182, 212, 0); } 100% { box-shadow: 0 0 0 0 rgba(6, 182, 212, 0); } }
    .ask-ai-control-right.processing { background: white; color: #8B5CF6; border: 3px solid #8B5CF6; }
    .ask-ai-control-right svg { width: 20px; height: 20px; flex-shrink: 0; }
    
    /* Voice Mode: Header buttons */
    .ask-ai-header-btn { height: 44px; padding: 0 20px; border: none; border-radius: 22px; font-family: var(--font-main); font-size: 0.75rem; font-weight: 700; letter-spacing: 0.5px; text-transform: uppercase; cursor: pointer; transition: all 0.15s; }
    .ask-ai-btn-done { background: rgba(255,255,255,0.2); color: white; }
    .ask-ai-btn-done:hover { background: rgba(255,255,255,0.3); }
    .ask-ai-btn-stop { background: #EF4444; color: white; display: none; }
    .ask-ai-btn-stop:hover { background: #DC2626; }
    .ask-ai-btn-autodrop { background: #10B981 !important; color: white !important; border-color: transparent !important; }
    .ask-ai-btn-autodrop.off { background: rgba(255,255,255,0.25) !important; color: white !important; border-color: transparent !important; }
    
    /* Voice Mode active: show large button, hide input row */
    .ask-ai-panel.voice-mode-active .ask-ai-input-row { display: none; }
    .ask-ai-panel.voice-mode-active .ask-ai-char-count { display: none; }
    .ask-ai-panel.voice-mode-active .ask-ai-voice-large { display: flex; }
    .ask-ai-panel.voice-mode-active .ask-ai-close { display: none; }
    .ask-ai-panel.voice-mode-active .ask-ai-btn-done { display: block; }
    
    /* Stop button visible when processing/speaking */
    .ask-ai-panel.aski-busy .ask-ai-btn-stop { display: block; }
    .ask-ai-panel.aski-busy .ask-ai-btn-done { display: none; }
    .ask-ai-panel.aski-busy .ask-ai-close { display: none; }
    
    body.chat-open .fab-camera, body.chat-open .fab-askai, body.chat-open .fab-record { opacity: 0; pointer-events: none; }

    /* Plus menu */
    .plus-menu { position: fixed; bottom: calc(100px + var(--safe-bottom)); left: 50%; transform: translateX(-50%) translateY(20px); background: var(--color-bg-card); border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,0.2); z-index: 49; opacity: 0; visibility: hidden; transition: all 0.2s ease; min-width: 280px; overflow: hidden; padding: 12px; }
    .plus-menu.show { opacity: 1; visibility: visible; transform: translateX(-50%) translateY(0); }
    .plus-menu-item { display: flex; align-items: center; gap: 12px; padding: 12px; cursor: pointer; transition: all 0.15s; border: 1.5px solid var(--color-border); border-radius: 12px; background: var(--color-bg); width: 100%; text-align: left; font-family: var(--font-main); margin-bottom: 8px; }
    .plus-menu-item:last-child { margin-bottom: 0; }
    .plus-menu-item:hover { border-color: #8B5CF6; background: rgba(139,92,246,0.05); }
    .plus-menu-item:active { transform: scale(0.98); }
    .plus-menu-item .icon { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: var(--color-bg-btn); border-radius: 10px; color: var(--color-text-muted); flex-shrink: 0; }
    .plus-menu-item .icon svg { width: 20px; height: 20px; }
    .plus-menu-item .info { flex: 1; }
    .plus-menu-item .title { font-size: 0.9rem; font-weight: 600; color: var(--color-text); }
    .plus-menu-item .desc { font-size: 0.75rem; color: var(--color-text-muted); margin-top: 2px; }
    .plus-menu-divider { height: 1px; background: var(--color-border); margin: 8px 0; }
    .plus-menu-label { padding: 4px 4px 8px; font-size: 0.65rem; font-weight: 700; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
    .plus-menu-item.magic { border-color: rgba(139,92,246,0.3); background: linear-gradient(135deg, rgba(139,92,246,0.05), rgba(236,72,153,0.05)); }
    .plus-menu-item.magic .icon { background: linear-gradient(135deg, rgba(139,92,246,0.15), rgba(236,72,153,0.15)); color: #8B5CF6; }
    .plus-menu-item.magic:hover { border-color: #8B5CF6; background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(236,72,153,0.1)); }
    .plus-menu-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.3); z-index: 48; opacity: 0; visibility: hidden; transition: opacity 0.2s; }
    .plus-menu-backdrop.show { opacity: 1; visibility: visible; }
    
    /* AI Magic Modal */
    .magic-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; padding: 20px; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .magic-modal.show { opacity: 1; visibility: visible; }
    .magic-content { background: var(--color-bg-card); border-radius: 20px; width: 100%; max-width: 400px; max-height: 90vh; overflow-y: auto; transform: translateY(20px); transition: transform 0.2s; }
    .magic-modal.show .magic-content { transform: translateY(0); }
    
    /* Audio Recorder Modal */
    .audio-recorder-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 200; display: flex; align-items: center; justify-content: center; padding: 20px; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .audio-recorder-modal.show { opacity: 1; visibility: visible; }
    .audio-recorder-content { background: var(--color-bg-card); border-radius: var(--radius-lg); width: 100%; max-width: 400px; overflow: hidden; transform: translateY(20px); transition: transform 0.2s; }
    .audio-recorder-modal.show .audio-recorder-content { transform: translateY(0); }
    .audio-recorder-header { background: linear-gradient(135deg, #F59E0B, #D97706); padding: 20px; text-align: center; }
    .audio-recorder-header h2 { color: white; font-size: 1.2rem; font-weight: 700; margin: 0; display: flex; align-items: center; justify-content: center; gap: 8px; }
    .audio-recorder-body { padding: 24px; }
    .audio-recorder-waveform { height: 80px; background: var(--color-bg); border-radius: var(--radius-md); display: flex; align-items: center; justify-content: center; gap: 3px; margin-bottom: 20px; overflow: hidden; }
    .audio-recorder-waveform .bar { width: 4px; background: var(--color-border); border-radius: 2px; transition: all 0.1s; }
    .audio-recorder-waveform.recording .bar { background: var(--color-primary); animation: waveBar 0.5s ease-in-out infinite alternate; }
    @keyframes waveBar { from { transform: scaleY(0.3); } to { transform: scaleY(1); } }
    .audio-recorder-time { text-align: center; font-size: 2rem; font-weight: 700; color: var(--color-text); margin-bottom: 20px; font-variant-numeric: tabular-nums; }
    .audio-recorder-controls { display: flex; justify-content: center; gap: 12px; margin-bottom: 20px; }
    .audio-recorder-controls .ctrl-btn { padding: 12px 20px; border: none; border-radius: var(--radius-full); font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.15s; text-transform: uppercase; }
    .audio-recorder-controls .ctrl-btn:active { transform: scale(0.95); }
    .audio-recorder-controls .ctrl-btn.rewind { background: var(--color-bg-btn); color: var(--color-text-soft); }
    .audio-recorder-controls .ctrl-btn.play { background: var(--color-bg-btn); color: var(--color-text-soft); }
    .audio-recorder-controls .ctrl-btn.forward { background: var(--color-bg-btn); color: var(--color-text-soft); }
    .audio-recorder-main-btn { width: 100%; padding: 20px; border: none; border-radius: var(--radius-md); font-size: 1.1rem; font-weight: 700; cursor: pointer; transition: all 0.15s; text-transform: uppercase; display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 20px; }
    .audio-recorder-main-btn.ready { background: linear-gradient(135deg, #F59E0B, #D97706); color: white; }
    .audio-recorder-main-btn.recording { background: linear-gradient(135deg, #EF4444, #DC2626); color: white; animation: pulse 1s infinite; }
    .audio-recorder-main-btn.paused { background: linear-gradient(135deg, #3B82F6, #2563EB); color: white; }
    .audio-recorder-main-btn.stopped { background: linear-gradient(135deg, #10B981, #059669); color: white; }
    .audio-recorder-main-btn:active { transform: scale(0.98); }
    .audio-recorder-actions { display: flex; gap: 8px; margin-bottom: 16px; }
    .audio-recorder-actions .act-btn { flex: 1; padding: 12px; border: none; border-radius: var(--radius-md); font-size: 0.8rem; font-weight: 600; cursor: pointer; text-transform: uppercase; transition: all 0.15s; }
    .audio-recorder-actions .act-btn:active { transform: scale(0.95); }
    .audio-recorder-actions .act-btn.delete { background: #FEE2E2; color: #991B1B; }
    .audio-recorder-actions .act-btn.create { background: #D1FAE5; color: #065F46; }
    .audio-recorder-actions .act-btn.share { background: #E0E7FF; color: #3730A3; }
    .audio-recorder-actions .act-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .audio-recorder-controls .ctrl-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .audio-recorder-cancel { width: 100%; padding: 16px; border: 2px solid var(--color-border); border-radius: var(--radius-md); background: transparent; font-size: 0.9rem; font-weight: 600; color: var(--color-text-soft); cursor: pointer; text-transform: uppercase; transition: all 0.15s; }
    .audio-recorder-cancel:active { background: var(--color-bg-btn); }
    .magic-header { padding: 20px; text-align: center; background: linear-gradient(135deg, #8B5CF6, #EC4899); color: white; }
    .magic-header h2 { font-size: 1.3rem; margin-bottom: 4px; }
    .magic-header p { font-size: 0.85rem; opacity: 0.9; }
    .magic-body { padding: 20px; }
    .magic-photo-section { margin-bottom: 16px; }
    .magic-photo-btn { width: 100%; padding: 14px; border: 2px dashed var(--color-border); border-radius: 12px; background: var(--color-bg); cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; font-family: var(--font-main); font-size: 0.95rem; color: var(--color-text-soft); transition: all 0.2s; }
    .magic-photo-btn:hover { border-color: #8B5CF6; background: rgba(139,92,246,0.05); }
    .magic-photo-btn.has-photo { border-style: solid; border-color: #10B981; background: rgba(16,185,129,0.05); color: #059669; }
    .magic-photo-preview { position: relative; margin-top: 12px; border-radius: 12px; overflow: hidden; }
    .magic-photo-preview img { width: 100%; max-height: 150px; object-fit: cover; display: block; }
    .magic-photo-remove { position: absolute; top: 8px; right: 8px; width: 28px; height: 28px; border: none; border-radius: 50%; background: rgba(0,0,0,0.6); color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; }
    .magic-photo-menu { position: absolute; bottom: 100%; left: 0; right: 0; background: var(--color-bg-card); border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); margin-bottom: 8px; overflow: hidden; display: none; }
    .magic-photo-menu.show { display: block; }
    .magic-photo-menu-item { display: flex; align-items: center; gap: 12px; padding: 14px 16px; cursor: pointer; border: none; background: none; width: 100%; text-align: left; font-family: var(--font-main); font-size: 0.95rem; color: var(--color-text); }
    .magic-photo-menu-item:hover { background: var(--color-bg-btn); }
    .magic-photo-menu-item:active { background: var(--color-border); }
    .magic-input-area { width: 100%; min-height: 80px; padding: 14px; border: 2px solid var(--color-border); border-radius: 12px; font-family: var(--font-main); font-size: 1rem; resize: none; margin-bottom: 16px; user-select: text; -webkit-user-select: text; -webkit-touch-callout: default; }
    .magic-input-area:focus { outline: none; border-color: #8B5CF6; }
    .magic-input-label { font-size: 0.8rem; color: var(--color-text-muted); margin-bottom: 6px; display: block; }
    .magic-voice-btn { width: 100%; padding: 14px; border: 2px dashed var(--color-border); border-radius: 12px; background: var(--color-bg); cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; font-family: var(--font-main); font-size: 0.95rem; color: var(--color-text-soft); margin-bottom: 16px; transition: all 0.2s; }
    .magic-voice-btn:hover { border-color: #8B5CF6; background: rgba(139,92,246,0.05); }
    .magic-voice-btn.recording { border-color: var(--color-recording); background: rgba(239,68,68,0.1); color: var(--color-recording); animation: pulse 1s infinite; }
    .magic-styles { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px; }
    .magic-style { padding: 8px 16px; border: 2px solid var(--color-border); border-radius: 20px; background: none; font-family: var(--font-main); font-size: 0.85rem; cursor: pointer; transition: all 0.15s; }
    .magic-style:hover { border-color: #8B5CF6; }
    .magic-style.active { border-color: #8B5CF6; background: rgba(139,92,246,0.1); color: #8B5CF6; }
    .magic-generate { width: 100%; padding: 16px; border: none; border-radius: 12px; background: linear-gradient(135deg, #8B5CF6, #EC4899); color: white; font-family: var(--font-main); font-size: 1.1rem; font-weight: 600; cursor: pointer; transition: transform 0.15s, box-shadow 0.15s; }
    .magic-generate:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(139,92,246,0.4); }
    .magic-generate:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
    .magic-footer { padding: 16px 20px; border-top: 1px solid var(--color-border); }
    .magic-cancel { padding: 10px 24px; border: none; background: none; font-family: var(--font-main); font-size: 0.95rem; color: var(--color-text-soft); cursor: pointer; }
    
    /* Drops picker modal */
    .drops-picker { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 250; display: flex; align-items: flex-end; justify-content: center; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .drops-picker.show { opacity: 1; visibility: visible; }
    .drops-picker-content { background: var(--color-bg-card); border-radius: 20px 20px 0 0; width: 100%; max-width: 480px; max-height: 70vh; overflow: hidden; transform: translateY(100%); transition: transform 0.3s; }
    .drops-picker.show .drops-picker-content { transform: translateY(0); }
    .drops-picker-header { padding: 16px 20px; border-bottom: 1px solid var(--color-border); display: flex; justify-content: space-between; align-items: center; }
    .drops-picker-header h3 { font-size: 1.1rem; }
    .drops-picker-close { width: 32px; height: 32px; border: none; background: var(--color-bg-btn); border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; }
    .drops-picker-grid { padding: 16px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; overflow-y: auto; max-height: calc(70vh - 70px); }
    .drops-picker-item { aspect-ratio: 1; border-radius: 12px; overflow: hidden; cursor: pointer; border: 3px solid transparent; transition: all 0.15s; }
    .drops-picker-item:hover { border-color: #8B5CF6; }
    .drops-picker-item img { width: 100%; height: 100%; object-fit: cover; }
    .drops-picker-empty { grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--color-text-muted); }
    
    /* AI Tools Modal (for text drops) */
    .ai-tools-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; padding: 16px; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .ai-tools-modal.show { opacity: 1; visibility: visible; }
    .ai-tools-content { background: var(--color-bg-card); border-radius: 20px; width: 100%; max-width: 420px; max-height: 90vh; overflow-y: auto; transform: translateY(20px); transition: transform 0.2s; }
    .ai-tools-modal.show .ai-tools-content { transform: translateY(0); }
    .ai-tools-header { padding: 20px; text-align: center; background: linear-gradient(135deg, #3B82F6, #8B5CF6); color: white; }
    .ai-tools-header h2 { font-size: 1.3rem; margin-bottom: 4px; }
    .ai-tools-header p { font-size: 0.85rem; opacity: 0.9; }
    .ai-tools-preview { padding: 16px 20px; background: var(--color-bg); border-bottom: 1px solid var(--color-border); }
    .ai-tools-preview-text { font-size: 0.9rem; color: var(--color-text-soft); line-height: 1.5; max-height: 80px; overflow: hidden; position: relative; }
    .ai-tools-preview-text::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 30px; background: linear-gradient(transparent, var(--color-bg)); }
    .ai-tools-preview-label { font-size: 0.75rem; color: var(--color-text-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
    .ai-tools-body { padding: 20px; }
    .ai-tools-grid { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
    .ai-tool-btn { display: flex; align-items: center; gap: 14px; padding: 16px; border: 2px solid var(--color-border); border-radius: 14px; background: var(--color-bg-card); cursor: pointer; transition: all 0.15s; text-align: left; font-family: var(--font-main); }
    .ai-tool-btn:hover { border-color: #8B5CF6; background: rgba(139,92,246,0.05); }
    .ai-tool-btn:active { transform: scale(0.98); }
    .ai-tool-btn .icon { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, rgba(59,130,246,0.1), rgba(139,92,246,0.1)); border-radius: 10px; color: #6366F1; }
    .ai-tool-btn .icon svg { width: 22px; height: 22px; }
    .ai-tool-btn .info { flex: 1; }
    .ai-tool-btn .title { font-size: 1rem; font-weight: 600; color: var(--color-text); margin-bottom: 2px; }
    .ai-tool-btn .desc { font-size: 0.8rem; color: var(--color-text-muted); }
    .ai-tools-option { display: flex; align-items: center; gap: 10px; padding: 14px 16px; background: var(--color-bg); border-radius: 12px; margin-bottom: 16px; }
    .ai-tools-option input[type="checkbox"] { width: 20px; height: 20px; accent-color: #8B5CF6; }
    .ai-tools-option-label { flex: 1; }
    .ai-tools-option-label .title { font-size: 0.9rem; font-weight: 500; color: var(--color-text); }
    .ai-tools-option-label .current { font-size: 0.8rem; color: var(--color-text-muted); }
    .ai-tools-footer { padding: 16px 20px; border-top: 1px solid var(--color-border); }
    
    /* AI Result Modal (large) */
    .ai-result-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 210; display: flex; align-items: center; justify-content: center; padding: 16px; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .ai-result-modal.show { opacity: 1; visibility: visible; }
    .ai-result-content { background: var(--color-bg-card); border-radius: 20px; width: 100%; max-width: 420px; max-height: 90vh; overflow: hidden; transform: translateY(20px); transition: transform 0.2s; display: flex; flex-direction: column; }
    .ai-result-modal.show .ai-result-content { transform: translateY(0); }
    .ai-result-header { padding: 20px; text-align: center; background: linear-gradient(135deg, #10B981, #3B82F6); color: white; flex-shrink: 0; }
    .ai-result-header h2 { font-size: 1.2rem; }
    .ai-result-body { padding: 20px; flex: 1; overflow-y: auto; }
    .ai-result-text { font-size: max(1rem, 16px); line-height: 1.6; color: var(--color-text); white-space: pre-wrap; }
    .ai-result-category { margin-top: 20px; padding: 16px; background: var(--color-bg); border-radius: 12px; }
    .ai-result-category-title { font-size: 0.8rem; color: var(--color-text-muted); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
    .ai-result-category-row { display: flex; align-items: center; gap: 10px; }
    .ai-result-category-current { font-size: 0.9rem; color: var(--color-text-soft); }
    .ai-result-category-arrow { color: var(--color-text-muted); }
    .ai-result-category-suggested { font-size: 0.9rem; font-weight: 600; color: #8B5CF6; }
    .ai-result-category-actions { display: flex; gap: 8px; margin-top: 12px; }
    .ai-result-category-btn { flex: 1; padding: 10px; border: 2px solid var(--color-border); border-radius: 8px; background: none; font-family: var(--font-main); font-size: 0.85rem; cursor: pointer; transition: all 0.15s; }
    .ai-result-category-btn:hover { border-color: #8B5CF6; }
    .ai-result-category-btn.accept { border-color: #10B981; background: rgba(16,185,129,0.1); color: #059669; }
    .ai-result-actions { padding: 20px; border-top: 1px solid var(--color-border); display: flex; flex-direction: column; gap: 10px; flex-shrink: 0; }
    .ai-result-action-btn { padding: 14px; border: none; border-radius: 12px; font-family: var(--font-main); font-size: 1rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.15s; }
    .ai-result-action-btn.primary { background: linear-gradient(135deg, #8B5CF6, #EC4899); color: white; }
    .ai-result-action-btn.primary:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(139,92,246,0.3); }
    .ai-result-action-btn.secondary { background: var(--color-bg-btn); color: var(--color-text); }
    .ai-result-action-btn.secondary:hover { background: var(--color-border); }
    .ai-result-action-row { display: flex; gap: 10px; }
    .ai-result-action-row .ai-result-action-btn { flex: 1; }
    .ai-result-cancel { width: 100%; padding: 14px; margin-top: 8px; border: 2px solid var(--color-border); border-radius: 12px; background: var(--color-bg); font-family: var(--font-main); font-size: 1rem; font-weight: 600; color: var(--color-text-soft); cursor: pointer; transition: all 0.15s; }
    .ai-result-cancel:hover { border-color: var(--color-text-muted); background: var(--color-bg-soft); }
    
    /* B2 FIX: Tasks Preview List */
    .tasks-preview-list { display: flex; flex-direction: column; gap: 8px; max-height: 40vh; overflow-y: auto; }
    .tasks-preview-item { display: flex; align-items: flex-start; gap: 10px; padding: 12px; background: var(--color-bg); border-radius: 10px; font-size: 0.9rem; line-height: 1.4; }
    .tasks-preview-num { flex-shrink: 0; width: 24px; height: 24px; background: var(--cat-tasks-bg); color: var(--cat-tasks-text); border-radius: 50%; font-size: 0.75rem; font-weight: 700; display: flex; align-items: center; justify-content: center; }
    .tasks-preview-text { flex: 1; color: var(--color-text); }
    
    /* I1 FIX: Translate Language Buttons */
    .translate-langs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .translate-lang-btn { padding: 14px 16px; border: 2px solid var(--color-border); border-radius: 12px; background: var(--color-bg); font-family: var(--font-main); font-size: 0.95rem; font-weight: 500; color: var(--color-text); cursor: pointer; transition: all 0.15s; text-align: left; }
    .translate-lang-btn:hover { border-color: #3B82F6; background: rgba(59, 130, 246, 0.05); }
    .translate-lang-btn:active { transform: scale(0.98); }
    
    /* AI Loading Indicator (compact, inside modal) */
    .ai-loading-inline { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 20px; }
    .ai-loading-dots { display: flex; gap: 6px; margin-bottom: 16px; }
    .ai-loading-dots span { width: 10px; height: 10px; background: #8B5CF6; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite; }
    .ai-loading-dots span:nth-child(1) { animation-delay: 0s; }
    .ai-loading-dots span:nth-child(2) { animation-delay: 0.2s; }
    .ai-loading-dots span:nth-child(3) { animation-delay: 0.4s; }
    .ai-loading-dots span:nth-child(4) { animation-delay: 0.6s; }
    .ai-loading-dots span:nth-child(5) { animation-delay: 0.8s; }
    @keyframes bounce { 0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; } 40% { transform: scale(1); opacity: 1; } }
    .ai-loading-label { font-size: 0.9rem; color: var(--color-text-soft); }
    .ai-loading-dots.magic span { background: linear-gradient(135deg, #8B5CF6, #EC4899); }
    .magic-loading { display: none; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; }
    .magic-loading.show { display: flex; }
    .magic-form.hidden { display: none; }
    
    /* Main Menu Modal */
    .main-menu { position: fixed; top: calc(72px + env(safe-area-inset-top, 0px)); left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.4); z-index: 150; opacity: 0; visibility: hidden; transition: all 0.25s; }
    .main-menu.show { opacity: 1; visibility: visible; }
    .main-menu-content { background: var(--color-bg-card); width: 100%; height: 100%; overflow-y: auto; transform: translateY(-20px); transition: transform 0.25s; padding-bottom: 100px; }
    .main-menu.show .main-menu-content { transform: translateY(0); }
    .main-menu-header { display: none; }
    .main-menu-close { display: none; }
    .main-menu-footer { padding: 16px 20px 24px; display: none; }
    
    /* Balance Card */
    .balance-card { margin: 16px 16px 0 16px; padding: 16px; background: linear-gradient(135deg, #8B5CF6, #EC4899); border-radius: 16px; color: white; }
    .balance-label { font-size: 0.8rem; opacity: 0.9; margin-bottom: 4px; }
    .balance-value { font-size: 1.8rem; font-weight: 700; }
    .balance-hint { font-size: 0.75rem; opacity: 0.8; margin-top: 6px; }
    
    /* Menu Sections */
    .menu-section { padding: 16px 20px; border-bottom: 1px solid var(--color-border); }
    .menu-section:last-child { border-bottom: none; }
    .menu-section.no-border { border-bottom: none; }
    .menu-section-title { font-size: 0.75rem; font-weight: 600; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    
    /* Search Box */
    .menu-search { display: flex; gap: 10px; }
    .menu-search-input { flex: 1; padding: 14px 16px; border: 2px solid var(--color-border); border-radius: 16px; font-size: 1rem; font-family: var(--font-main); background: var(--color-bg); color: var(--color-text); min-width: 0; }
    .menu-search-input:focus { border-color: #8B5CF6; outline: none; }
    .menu-search-btn { width: 52px; height: 52px; flex-shrink: 0; border: none; background: linear-gradient(135deg, #8B5CF6, #3B82F6); border-radius: 12px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: transform 0.15s; }
    .menu-search-btn:hover { transform: scale(1.05); }
    .menu-search-btn:active { transform: scale(0.95); }
    .menu-search-btn svg { width: 22px; height: 22px; }
    
    /* Undo List */
    .undo-header { display: flex; align-items: center; justify-content: space-between; }
    .undo-header-left { display: flex; align-items: center; gap: 8px; }
    .undo-toggle-btn { padding: 6px 12px; border: 1px solid var(--color-border); background: var(--color-bg); border-radius: 8px; font-size: 0.8rem; color: var(--color-text-muted); cursor: pointer; }
    .undo-toggle-btn:hover { border-color: #8B5CF6; }
    .undo-main-btn { flex: 1; padding: 14px; border: none; background: linear-gradient(135deg, #8B5CF6, #3B82F6); color: white; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: transform 0.15s; }
    .undo-main-btn:hover { transform: scale(1.02); }
    .undo-main-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .undo-list { display: none; flex-direction: column; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--color-border); }
    .undo-list.show { display: flex; }
    .undo-item { display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--color-bg); border-radius: 12px; }
    .undo-item-icon { width: 36px; height: 36px; background: rgba(139,92,246,0.1); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; }
    .undo-item-info { flex: 1; }
    .undo-item-title { font-size: 0.9rem; font-weight: 500; color: var(--color-text); }
    .undo-item-time { font-size: 0.75rem; color: var(--color-text-muted); }
    .undo-item-btn { padding: 8px 16px; border: none; background: #8B5CF6; color: white; border-radius: 8px; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.15s; }
    .undo-item-btn:hover { background: #7C3AED; }
    .undo-empty { text-align: center; padding: 20px; color: var(--color-text-muted); font-size: 0.9rem; }
    
    /* Settings Items */
    .settings-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 0; border-bottom: 1px solid var(--color-border); }
    .settings-item.no-border { border-bottom: none; padding-bottom: 6px; }
    .section-divider + .settings-item { padding-top: 0; border-top: none; }
    .settings-item:last-child { border-bottom: none; padding-bottom: 0; }
    .settings-item-left { display: flex; align-items: center; gap: 12px; }
    .settings-item-icon { font-size: 1.2rem; }
    .settings-item-label { font-size: 0.95rem; color: var(--color-text); }
    .settings-item-hint { font-size: 0.7rem; color: var(--color-text-muted); margin-left: 8px; }
    .settings-item-warning { font-size: 0.8rem; color: #EF4444; margin-left: 8px; display: flex; align-items: center; gap: 4px; }
    .settings-item-warning svg { stroke: #EF4444; flex-shrink: 0; }
    .settings-toggle { width: 50px; height: 28px; background: var(--color-border); border-radius: 14px; position: relative; cursor: pointer; transition: background 0.2s; }
    .settings-toggle.active { background: #8B5CF6; }
    .settings-toggle::after { content: ''; position: absolute; top: 3px; left: 3px; width: 22px; height: 22px; background: white; border-radius: 50%; transition: transform 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .settings-toggle.active::after { transform: translateX(22px); }
    .settings-btn { padding: 10px 20px; border: 2px solid var(--color-border); background: none; border-radius: 10px; font-size: 0.9rem; font-family: var(--font-main); color: var(--color-text); cursor: pointer; transition: all 0.15s; }
    .settings-btn:hover { border-color: #8B5CF6; background: rgba(139,92,246,0.05); }
    .settings-btn.danger { border-color: #EF4444; color: #EF4444; }
    .settings-btn.danger:hover { background: rgba(239,68,68,0.1); }
    
    /* About Section */
    .menu-about { text-align: center; padding: 20px; }
    .menu-about-logo { width: 50px; height: 50px; background: linear-gradient(135deg, #3B82F6, #8B5CF6); border-radius: 14px; display: flex; align-items: center; justify-content: center; margin: 0 auto 12px; }
    .menu-about-logo svg { width: 28px; height: 28px; fill: white; }
    .menu-about-name { font-size: 1.1rem; font-weight: 700; color: var(--color-text); }
    .menu-about-ver { font-size: 0.8rem; color: var(--color-text-muted); margin-top: 2px; }
    
    /* Search indicator */
    .search-indicator { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(59,130,246,0.1)); border-bottom: 1px solid var(--color-border); }
    .search-indicator-text { font-size: 0.9rem; color: var(--color-text); }
    .search-indicator-text span { font-weight: 600; color: #8B5CF6; }
    .search-indicator-clear { padding: 6px 12px; border: none; background: rgba(239,68,68,0.1); color: #EF4444; border-radius: 6px; font-size: 0.8rem; font-weight: 600; cursor: pointer; }
    
    /* Font size variants */
    body.font-small { font-size: 14px; }
    body.font-normal { font-size: 16px; }
    body.font-large { font-size: 18px; }
    
    /* Card text */
    body.font-small .card-text { font-size: 0.95rem; }
    body.font-normal .card-text { font-size: 1.05rem; }
    body.font-large .card-text { font-size: 1.2rem; }
    
    /* Chat messages */
    body.font-small .ask-ai-bubble { font-size: 0.9rem; }
    body.font-normal .ask-ai-bubble { font-size: 1rem; }
    body.font-large .ask-ai-bubble { font-size: 1.15rem; }
    
    /* Card notes/caption */
    body.font-small .card-notes { font-size: 0.8rem; }
    body.font-normal .card-notes { font-size: 0.85rem; }
    body.font-large .card-notes { font-size: 1rem; }
    
    /* Card meta (time, chars) */
    body.font-small .card-time, body.font-small .card-chars { font-size: 0.7rem; }
    body.font-normal .card-time, body.font-normal .card-chars { font-size: 0.75rem; }
    body.font-large .card-time, body.font-large .card-chars { font-size: 0.85rem; }
    
    /* Card header */
    body.font-small .card-head { font-size: 0.75rem; }
    body.font-normal .card-head { font-size: 0.8rem; }
    body.font-large .card-head { font-size: 0.9rem; }
    
    /* Category badges */
    body.font-small .card-cat { font-size: 0.65rem; padding: 3px 8px; }
    body.font-normal .card-cat { font-size: 0.7rem; padding: 4px 10px; }
    body.font-large .card-cat { font-size: 0.8rem; padding: 5px 12px; }
    
    /* Filter buttons */
    body.font-small .cat, body.font-small .time-btn { font-size: 0.75rem; padding: 6px 10px; }
    body.font-normal .cat, body.font-normal .time-btn { font-size: 0.8rem; padding: 7px 12px; }
    body.font-large .cat, body.font-large .time-btn { font-size: 0.9rem; padding: 8px 14px; }
    
    /* Action buttons - same as filter buttons */
    body.font-small .act, body.font-small .select-btn, body.font-small .modal-btn { font-size: 0.75rem; padding: 6px 10px; }
    body.font-normal .act, body.font-normal .select-btn, body.font-normal .modal-btn { font-size: 0.8rem; padding: 7px 12px; }
    body.font-large .act, body.font-large .select-btn, body.font-large .modal-btn { font-size: 0.9rem; padding: 8px 14px; }
    
    /* Textarea (edit mode) */
    body.font-small .card-ta { font-size: 0.95rem; }
    body.font-normal .card-ta { font-size: 1.05rem; }
    body.font-large .card-ta { font-size: 1.2rem; min-height: 200px; }
    
    /* Media meta */
    body.font-small .card-media-meta { font-size: 0.7rem; }
    body.font-normal .card-media-meta { font-size: 0.75rem; }
    body.font-large .card-media-meta { font-size: 0.85rem; }
    
    /* Date separator */
    body.font-small .date-sep { font-size: 0.75rem; }
    body.font-normal .date-sep { font-size: 0.8rem; }
    body.font-large .date-sep { font-size: 0.9rem; }
    
    /* Modal titles */
    body.font-small .modal-title { font-size: 1rem; }
    body.font-normal .modal-title { font-size: 1.1rem; }
    body.font-large .modal-title { font-size: 1.3rem; }
    
    /* Menu */
    body.font-large .menu-section-title { font-size: 0.85rem; }
    body.font-large .settings-item-label { font-size: 1.05rem; }
    body.font-large .undo-item-title { font-size: 1rem; }
    body.font-large .balance-value { font-size: 2rem; }
    
    /* Font size selector */
    .font-size-selector { display: flex; gap: 8px; }
    .font-size-btn { flex: 1; padding: 12px 8px; border: 2px solid var(--color-border); background: var(--color-bg); border-radius: 10px; font-family: var(--font-main); cursor: pointer; transition: all 0.15s; display: flex; flex-direction: column; align-items: center; gap: 4px; }
    .font-size-btn:hover { border-color: #8B5CF6; }
    .font-size-btn.active { border-color: #8B5CF6; background: rgba(139,92,246,0.1); }
    .font-size-btn .size-label { font-weight: 600; color: var(--color-text); }
    .font-size-btn .size-preview { color: var(--color-text-muted); }
    .font-size-btn[data-size="small"] .size-preview { font-size: 12px; }
    .font-size-btn[data-size="normal"] .size-preview { font-size: 14px; }
    .font-size-btn[data-size="large"] .size-preview { font-size: 16px; }
    
    /* AI Result with Actions */
    .ai-result-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--color-border); }
    .ai-result-btn { flex: 1; min-width: 100px; padding: 12px 16px; border: none; border-radius: 10px; font-family: var(--font-main); font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: all 0.15s; display: flex; align-items: center; justify-content: center; gap: 6px; }
    .ai-result-btn.primary { background: linear-gradient(135deg, #8B5CF6, #EC4899); color: white; }
    .ai-result-btn.primary:hover { transform: translateY(-1px); box-shadow: 0 3px 10px rgba(139,92,246,0.3); }
    .ai-result-btn.secondary { background: var(--color-bg-btn); color: var(--color-text); }
    .ai-result-btn.secondary:hover { background: var(--color-border); }

    /* Text input modal */
    .text-input-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 100; display: none; align-items: flex-end; justify-content: center; }
    .text-input-modal.show { display: flex; }
    .text-input-content { background: var(--color-bg-card); width: 100%; max-height: 70vh; border-radius: 20px 20px 0 0; padding: 20px; padding-bottom: calc(20px + var(--safe-bottom)); animation: slideUp 0.25s ease; }
    @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
    .text-input-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .text-input-title { font-size: 1.1rem; font-weight: 600; color: var(--color-text); }
    .text-input-close { width: 32px; height: 32px; border: none; background: var(--color-bg-btn); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--color-text-soft); font-size: 1.2rem; }
    .text-input-area { width: 100%; min-height: 120px; padding: 14px; border: 1px solid var(--color-border); border-radius: 12px; font-family: var(--font-main); font-size: 1rem; resize: none; background: var(--color-bg); color: var(--color-text); user-select: text; -webkit-user-select: text; -webkit-touch-callout: default; }
    .text-input-area:focus { outline: none; border-color: var(--color-primary); }
    .text-input-actions { display: flex; gap: 12px; margin-top: 16px; }
    .text-input-btn { flex: 1; height: 48px; border: none; border-radius: 12px; font-family: var(--font-main); font-size: 0.95rem; font-weight: 600; cursor: pointer; }
    .text-input-btn.cancel { background: var(--color-bg-btn); color: var(--color-text-soft); }
    .text-input-btn.save { background: var(--color-primary); color: white; }

    /* Recording status */
    .rec-status { position: fixed; bottom: calc(96px + var(--safe-bottom)); left: 50%; transform: translateX(-50%); display: none; align-items: center; gap: 8px; padding: 10px 20px; background: var(--color-bg-card); border-radius: var(--radius-full); box-shadow: var(--shadow-scroll); z-index: 50; }
    .rec-status.show { display: flex; }
    .rec-dot { width: 8px; height: 8px; background: var(--color-recording); border-radius: 50%; animation: blink 1s ease infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
    .rec-text { font-size: 0.8rem; font-weight: 600; color: var(--color-text); max-width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    /* Scroll FAB */
    .scroll-fab { position: fixed; right: 20px; width: 56px; height: 56px; border: none; background: var(--color-bg-card); border-radius: var(--radius-full); box-shadow: var(--shadow-scroll); cursor: pointer; display: none; align-items: center; justify-content: center; color: var(--color-primary); font-size: 1.1rem; font-weight: 700; z-index: 40; transition: all 0.2s; }
    .scroll-fab.show { display: flex; }
    .scroll-fab:active { transform: scale(0.9); }
    .scroll-fab.top { bottom: calc(170px + var(--safe-bottom)); }
    .scroll-fab.bottom { bottom: calc(100px + var(--safe-bottom)); }
    .editing-mode .scroll-fab, .select-mode .scroll-fab { display: none !important; }
    
    /* B1 FIX: Keep header visible when keyboard appears */
    .editing-mode .header, .editing-mode .filters { position: sticky; top: 0; z-index: 10; background: var(--color-bg-card); }
    .editing-mode .ideas-wrap { padding-bottom: 350px; }

    /* Selection bar */
    .select-bar { position: fixed; bottom: 0; left: 0; right: 0; background: var(--color-bg-card); border-top: 1px solid var(--color-border); padding: 12px 16px calc(12px + var(--safe-bottom)); display: none; align-items: center; justify-content: space-between; gap: 10px; z-index: 60; box-shadow: 0 -4px 20px rgba(0,0,0,0.1); }
    .select-bar.show { display: flex; }
    .select-info { font-size: 0.85rem; font-weight: 600; color: var(--color-text); }
    .select-actions { display: flex; gap: 8px; }
    .select-btn { height: 34px; padding: 0 12px; border: 2px solid var(--color-border); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.65rem; font-weight: 700; cursor: pointer; display: flex; align-items: center; gap: 5px; text-transform: uppercase; transition: all 0.15s; }
    .select-btn:active { transform: scale(0.97); }
    .select-btn.cancel { background: var(--color-bg-btn); color: var(--color-text-soft); border-color: var(--color-border); }
    .select-btn.merge { background: var(--color-merge); color: white; border-color: transparent; }
    .select-btn.delete { background: var(--color-error); color: white; border-color: transparent; }

    /* Modals - TYPE-C (compact, 320px) */
    .overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4); align-items: center; justify-content: center; padding: 20px; z-index: 100; backdrop-filter: blur(4px); }
    .overlay.show { display: flex; }
    .modal { width: 100%; max-width: 320px; background: var(--color-bg-card); border-radius: var(--radius-lg); padding: 24px; box-shadow: 0 20px 60px rgba(0,0,0,0.2); animation: modalIn 0.25s ease; }
    .modal.type-b { max-width: 360px; padding: 0; overflow: hidden; }
    .modal.type-b .modal-header { padding: 16px 20px; background: var(--color-bg-soft); border-bottom: 1px solid var(--color-border); }
    .modal.type-b .modal-header h3 { font-size: 1rem; font-weight: 700; margin: 0; }
    .modal.type-b .modal-body { padding: 20px; }
    .modal.type-b .modal-actions { padding: 0 20px 20px; }
    @keyframes modalIn { from{opacity:0;transform:scale(0.95) translateY(10px)} to{opacity:1;transform:scale(1) translateY(0)} }
    .modal-title { font-size: 1.1rem; font-weight: 700; margin-bottom: 16px; text-align: center; }
    .modal-text { font-size: 0.85rem; color: var(--color-text-soft); margin-bottom: 20px; line-height: 1.6; }
    .modal-actions { display: flex; gap: 10px; justify-content: center; }
    .modal-btn { height: 34px; padding: 0 12px; border: 2px solid var(--color-border); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.65rem; font-weight: 700; cursor: pointer; text-transform: uppercase; transition: all 0.15s; }
    .modal-btn:active { transform: scale(0.97); }
    .modal-btn.sec { background: var(--color-bg-btn); color: var(--color-text); border-color: var(--color-border); }
    .modal-btn.pri { background: var(--color-primary); color: white; border-color: transparent; }
    .modal-btn.merge { background: var(--color-merge); color: white; border-color: transparent; }
    .modal-btn.danger { background: var(--color-error); color: white; border-color: transparent; }

    /* ========== UNIFIED PILLS SYSTEM v0.9.58 ========== */
    
    /* Pills - Small (34px) for compact areas */
    .pill-s { height: 34px; padding: 0 14px; border: 2px solid var(--color-border); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.7rem; font-weight: 700; cursor: pointer; text-transform: uppercase; display: inline-flex; align-items: center; justify-content: center; gap: 5px; transition: all 0.15s; background: var(--color-bg-btn); color: var(--color-text-soft); }
    .pill-s:active { transform: scale(0.97); }
    .pill-s.sec { background: var(--color-bg-btn); color: var(--color-text); border-color: var(--color-border); }
    .pill-s.pri { background: var(--color-primary); color: white; border-color: transparent; }
    .pill-s.active { background: rgba(139,92,246,0.15); border-color: #8B5CF6; color: #8B5CF6; }

    /* Pills - Medium (40px) for TYPE-B modals */
    .pill-m { height: 40px; padding: 0 16px; border: 2px solid var(--color-border); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.75rem; font-weight: 700; cursor: pointer; text-transform: uppercase; display: inline-flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.15s; background: var(--color-bg-btn); color: var(--color-text-soft); }
    .pill-m:active { transform: scale(0.97); }
    .pill-m.sec { background: var(--color-bg-btn); color: var(--color-text); border-color: var(--color-border); }
    .pill-m.pri { background: var(--color-primary); color: white; border-color: transparent; }
    .pill-m.ai { background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white; border-color: transparent; }
    .pill-m.magic { background: linear-gradient(135deg, #8B5CF6, #EC4899); color: white; border-color: transparent; }
    .pill-m.merge { background: var(--color-merge); color: white; border-color: transparent; }
    .pill-m.danger { background: var(--color-error); color: white; border-color: transparent; }
    .pill-m.active { background: rgba(139,92,246,0.15); border-color: #8B5CF6; color: #8B5CF6; }

    /* Pills - Large (48px) for TYPE-A modals */
    .pill-l { height: 48px; padding: 0 24px; border: 2px solid var(--color-border); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.85rem; font-weight: 700; cursor: pointer; text-transform: uppercase; display: inline-flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.15s; background: var(--color-bg-btn); color: var(--color-text-soft); width: 100%; }
    .pill-l:active { transform: scale(0.98); }
    .pill-l.sec { background: var(--color-bg-btn); color: var(--color-text); border-color: var(--color-border); }
    .pill-l.pri { background: var(--color-primary); color: white; border-color: transparent; }
    .pill-l.ai { background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white; border-color: transparent; }
    .pill-l.magic { background: linear-gradient(135deg, #8B5CF6, #EC4899); color: white; border-color: transparent; }
    .pill-l.success { background: linear-gradient(135deg, #10B981, #3B82F6); color: white; border-color: transparent; }
    .pill-l.merge { background: var(--color-merge); color: white; border-color: transparent; }
    .pill-l.danger { background: var(--color-error); color: white; border-color: transparent; }
    .pill-l:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }

    /* Pills - XL (56px) for main CTA */
    .pill-xl { height: 56px; padding: 0 32px; border: 2px solid var(--color-border); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 1rem; font-weight: 700; cursor: pointer; text-transform: uppercase; display: inline-flex; align-items: center; justify-content: center; gap: 10px; transition: all 0.15s; background: var(--color-bg-btn); color: var(--color-text-soft); width: 100%; }
    .pill-xl:active { transform: scale(0.98); }
    .pill-xl.magic { background: linear-gradient(135deg, #8B5CF6, #EC4899); color: white; border-color: transparent; }
    .pill-xl.ai { background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white; border-color: transparent; }
    .pill-xl.pri { background: var(--color-primary); color: white; border-color: transparent; }

    /* Centered Section Divider */
    .section-divider { display: flex; align-items: center; gap: 12px; margin: 16px 0 12px 0; }
    .section-divider:first-child { margin-top: 0; }
    .section-divider::before, .section-divider::after { content: ''; flex: 1; height: 1px; background: var(--color-border); }
    .section-divider span { font-size: 0.65rem; font-weight: 700; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.5px; }

    /* NEW badge for fresh drops */
    .new-badge { padding: 3px 8px; border-radius: var(--radius-full); font-size: 0.55rem; font-weight: 700; text-transform: uppercase; background: #D1FAE5; color: #065F46; margin-right: 6px; }

    /* Pill row for side-by-side buttons */
    .pill-row { display: flex; gap: 10px; width: 100%; }
    .pill-row .pill-l, .pill-row .pill-m { flex: 1; width: auto; }

    .cat-grid { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    .modal:not(.type-b) .cat-grid { margin-bottom: 20px; }
    .cat-opt { padding: 10px 16px; border: none; border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.7rem; font-weight: 700; cursor: pointer; text-transform: uppercase; }
    .cat-opt:active { transform: scale(1.05); }
    .cat-opt[data-cat="tasks"] { background: var(--cat-tasks-bg); color: var(--cat-tasks-text); }
    .cat-opt[data-cat="ideas"] { background: var(--cat-ideas-bg); color: var(--cat-ideas-text); }
    .cat-opt[data-cat="handmagic"] { background: var(--cat-handmagic-bg); color: var(--cat-handmagic-text); }
    .cat-opt[data-cat="design"] { background: var(--cat-design-bg); color: var(--cat-design-text); }
    .cat-opt[data-cat="bugs"] { background: var(--cat-bugs-bg); color: var(--cat-bugs-text); }
    .cat-opt[data-cat="questions"] { background: var(--cat-questions-bg); color: var(--cat-questions-text); }
    .cat-opt[data-cat="inbox"] { background: var(--color-bg-btn); color: var(--cat-inbox-text); }
    .cat-opt[data-cat="sketch"] { background: var(--cat-sketch-bg); color: var(--cat-sketch-text); }
    .cat-opt[data-cat="scan"] { background: var(--cat-scan-bg); color: var(--cat-scan-text); }

    .send-opts { display: flex; flex-direction: column; gap: 8px; }
    .modal:not(.type-b) .send-opts { margin-bottom: 20px; }
    .send-opt { display: flex; align-items: center; gap: 12px; padding: 12px 14px; background: var(--color-bg); border-radius: var(--radius-md); cursor: pointer; }
    .send-opt:active { background: var(--color-bg-soft); }
    .send-icon { width: 36px; height: 36px; background: var(--color-bg-card); border-radius: var(--radius-full); display: flex; align-items: center; justify-content: center; font-size: 1.1rem; box-shadow: var(--shadow-card); }
    .send-info { flex: 1; }
    .send-title { font-size: 0.85rem; font-weight: 600; }
    .send-desc { font-size: 0.7rem; color: var(--color-text-muted); }
    .send-badge { font-size: 0.55rem; font-weight: 700; padding: 3px 8px; background: linear-gradient(135deg,#8B5CF6,#6366F1); color: white; border-radius: var(--radius-full); text-transform: uppercase; }
    .send-div { display: flex; align-items: center; gap: 10px; margin: 6px 0; font-size: 0.6rem; color: var(--color-text-muted); text-transform: uppercase; font-weight: 600; }
    .send-div::before, .send-div::after { content: ''; flex: 1; height: 1px; background: var(--color-border); }

    .export-box { background: var(--color-bg); border-radius: var(--radius-sm); padding: 12px; font-family: monospace; font-size: 0.65rem; max-height: 180px; overflow-y: auto; white-space: pre-wrap; word-break: break-word; }
    .modal:not(.type-b) .export-box { margin-bottom: 16px; }

    .about-brand { text-align: center; padding: 20px 0; margin-bottom: 16px; border-bottom: 1px solid var(--color-border); }
    .about-logo { width: 72px; height: 72px; background: linear-gradient(135deg, var(--color-primary), var(--color-primary-light)); border-radius: var(--radius-full); display: flex; align-items: center; justify-content: center; margin: 0 auto 12px; box-shadow: var(--shadow-fab); }
    .about-logo svg { width: 36px; height: 36px; }
    .about-name { font-size: 1.4rem; font-weight: 800; }
    .about-ver { font-size: 0.75rem; color: var(--color-text-muted); margin-top: 4px; }

    .toast-wrap { position: fixed; bottom: calc(100px + var(--safe-bottom)); left: 50%; transform: translateX(-50%); z-index: 200; pointer-events: none; }
    .toast { padding: 12px 20px; border-radius: var(--radius-full); font-size: 0.8rem; font-weight: 600; display: flex; align-items: center; gap: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); opacity: 0; transform: translateY(10px); transition: all 0.3s; pointer-events: auto; }
    .toast.show { opacity: 1; transform: translateY(0); }
    .toast.success { background: var(--color-success); color: white; }
    .toast.warning { background: var(--color-warning); color: white; }
    .toast.error { background: var(--color-error); color: white; }
    .toast.info { background: var(--color-text); color: white; }

    /* Merge preview */
    .merge-preview { background: var(--color-bg); border-radius: var(--radius-sm); padding: 12px; font-size: 0.9rem; max-height: 200px; overflow-y: auto; line-height: 1.6; white-space: pre-wrap; }
    .modal:not(.type-b) .merge-preview { margin-bottom: 16px; }
    .merge-options { margin-bottom: 12px; }
    .merge-toggle { display: flex; align-items: center; gap: 8px; font-size: 0.85rem; color: var(--color-text-soft); cursor: pointer; }
    .merge-toggle input { width: 18px; height: 18px; accent-color: var(--color-primary); }

    /* Image viewer */
    .image-viewer { background: rgba(0,0,0,0.95); padding: 0; overflow: hidden; }
    .image-viewer.show { display: flex; flex-direction: column; align-items: stretch; justify-content: flex-start; }
    .image-viewer-content { flex: 1; display: flex; align-items: center; justify-content: center; overflow: hidden; padding: 50px 0 0; touch-action: none; min-height: 0; position: relative; }
    .image-viewer img { max-width: 100%; max-height: 100%; width: auto; height: auto; object-fit: contain; border-radius: 0; transform-origin: center center; user-select: none; -webkit-user-drag: none; will-change: transform; transition: transform 0.2s ease; }
    .image-viewer img.portrait { width: 100%; max-width: 100%; height: auto; max-height: none; }
    .image-viewer img.landscape { width: auto; max-width: 100%; height: auto; max-height: 100%; }
    .image-viewer img.zoomed { max-width: none; max-height: none; }
    .image-viewer-close { position: absolute; top: 16px; right: 16px; width: 44px; height: 44px; background: rgba(255,255,255,0.15); border-radius: var(--radius-full); display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2rem; cursor: pointer; z-index: 10; }
    .image-viewer-close:active { background: rgba(255,255,255,0.3); }
    
    /* AI button on photo */
    .image-viewer-ai { position: absolute; top: 72px; right: 16px; width: 52px; height: 52px; background: linear-gradient(135deg, #8B5CF6, #3B82F6); border-radius: var(--radius-full); display: flex; align-items: center; justify-content: center; color: white; font-size: 1.4rem; cursor: pointer; z-index: 10; box-shadow: 0 4px 12px rgba(139,92,246,0.4); transition: transform 0.15s; }
    .image-viewer-ai:active { transform: scale(0.9); }
    
    /* Markers button on photo */
    .image-viewer-markers { position: absolute; top: 16px; left: 16px; min-width: 44px; height: 44px; padding: 0 12px; background: rgba(255,255,255,0.15); border-radius: 22px; display: flex; align-items: center; justify-content: center; gap: 4px; color: white; font-size: 1.1rem; cursor: pointer; z-index: 10; }
    .image-viewer-markers:active { background: rgba(255,255,255,0.3); }
    .image-viewer-markers.has-markers { background: rgba(139,92,246,0.6); }
    
    /* Photo AI Tools Modal */
    .photo-ai-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 250; display: flex; align-items: center; justify-content: center; padding: 20px; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .photo-ai-modal.show { opacity: 1; visibility: visible; }
    .photo-ai-content { background: var(--color-bg-card); border-radius: 20px; width: 100%; max-width: 360px; overflow: hidden; transform: scale(0.9); transition: transform 0.2s; }
    .photo-ai-modal.show .photo-ai-content { transform: scale(1); }
    .photo-ai-header { padding: 20px; background: linear-gradient(135deg, #8B5CF6, #3B82F6); color: white; text-align: center; }
    .photo-ai-header h3 { font-size: 1.2rem; margin: 0; }
    .photo-ai-header p { font-size: 0.85rem; opacity: 0.9; margin: 4px 0 0; }
    .photo-ai-tools { padding: 12px; display: flex; flex-direction: column; gap: 8px; }
    .photo-ai-btn { display: flex; align-items: center; gap: 14px; padding: 16px; border: none; background: var(--color-bg); border-radius: 14px; cursor: pointer; transition: all 0.15s; text-align: left; }
    .photo-ai-btn:hover { background: rgba(139,92,246,0.1); }
    .photo-ai-btn:active { transform: scale(0.98); }
    .photo-ai-btn .icon { width: 44px; height: 44px; background: linear-gradient(135deg, #8B5CF6, #3B82F6); border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.3rem; flex-shrink: 0; }
    .photo-ai-btn .info { flex: 1; }
    .photo-ai-btn .title { font-size: 1rem; font-weight: 600; color: var(--color-text); }
    .photo-ai-btn .desc { font-size: 0.8rem; color: var(--color-text-muted); margin-top: 2px; }
    .photo-ai-cancel { padding: 14px; border: none; background: none; width: 100%; font-size: 0.95rem; color: var(--color-text-muted); cursor: pointer; border-top: 1px solid var(--color-border); }
    
    /* Photo AI Result Modal */
    .photo-ai-result { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 260; display: flex; align-items: center; justify-content: center; padding: 20px; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .photo-ai-result.show { opacity: 1; visibility: visible; }
    .photo-ai-result-content { background: var(--color-bg-card); border-radius: 20px; width: 100%; max-width: 400px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; }
    .photo-ai-result-header { padding: 16px 20px; background: linear-gradient(135deg, #8B5CF6, #3B82F6); color: white; }
    .photo-ai-result-header h3 { font-size: 1.1rem; margin: 0; }
    .photo-ai-result-text { flex: 1; padding: 16px 20px; overflow-y: auto; font-size: 0.95rem; line-height: 1.5; color: var(--color-text); }
    .photo-ai-result-actions { padding: 12px 16px 16px; display: flex; flex-direction: column; gap: 8px; border-top: 1px solid var(--color-border); }
    .photo-ai-result-btn { padding: 14px; border: none; border-radius: 12px; font-size: 0.95rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.15s; }
    .photo-ai-result-btn.primary { background: linear-gradient(135deg, #8B5CF6, #3B82F6); color: white; }
    .photo-ai-result-btn.secondary { background: var(--color-bg); color: var(--color-text); }
    .photo-ai-result-btn:active { transform: scale(0.98); }
    
    /* Photo Markers Modal */
    .photo-markers-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 250; display: flex; align-items: center; justify-content: center; padding: 20px; opacity: 0; visibility: hidden; transition: all 0.2s; }
    .photo-markers-modal.show { opacity: 1; visibility: visible; }
    .photo-markers-content { background: var(--color-bg-card); border-radius: 20px; width: 100%; max-width: 320px; padding: 20px; text-align: center; }
    .photo-markers-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 16px; }
    .photo-markers-grid { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 16px; }
    .photo-marker-btn { width: 56px; height: 56px; border: 2px solid var(--color-border); background: var(--color-bg); border-radius: 14px; font-size: 1.6rem; cursor: pointer; transition: all 0.15s; }
    .photo-marker-btn:active { transform: scale(0.9); }
    .photo-marker-btn.active { border-color: #8B5CF6; background: rgba(139,92,246,0.15); }
    .photo-markers-done { width: 100%; padding: 14px; border: none; background: linear-gradient(135deg, #8B5CF6, #3B82F6); color: white; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer; }
    .image-viewer-nav { position: absolute; top: 50%; transform: translateY(-50%); width: 44px; height: 44px; background: rgba(255,255,255,0.15); border-radius: var(--radius-full); display: none; align-items: center; justify-content: center; color: white; font-size: 1.2rem; cursor: pointer; z-index: 10; }
    .image-viewer-nav:active { background: rgba(255,255,255,0.3); }
    .image-viewer-nav.prev { left: 10px; }
    .image-viewer-nav.next { right: 10px; }
    .image-viewer-nav.show { display: flex; }
    .image-viewer-panel { flex-shrink: 0; background: var(--color-bg-card); border-radius: var(--radius-lg) var(--radius-lg) 0 0; padding: 12px 16px calc(12px + env(safe-area-inset-bottom, 0px)) 16px; width: 100%; box-sizing: border-box; position: relative; z-index: 20; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
    .image-meta { font-size: 0.75rem; color: var(--color-text-muted); margin-bottom: 8px; display: flex; gap: 12px; flex-wrap: wrap; }
    .image-meta span { display: flex; align-items: center; gap: 4px; }
    .image-caption-display { font-size: 0.9rem; color: var(--color-text); line-height: 1.4; flex: 1; }
    .image-caption-display.empty { color: var(--color-text-muted); font-style: italic; }
    .image-caption-display.hidden { display: none; }
    .image-caption-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
    .caption-edit-btn { height: 28px; padding: 0 10px; border: none; background: var(--color-bg-btn); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.65rem; font-weight: 600; color: var(--color-text-soft); cursor: pointer; display: flex; align-items: center; flex-shrink: 0; text-transform: uppercase; }
    .caption-edit-btn:active { background: var(--color-bg-soft); }
    .image-notes-wrap { display: none; }
    .image-notes-wrap.editing { display: block; }
    .image-notes { width: 100%; padding: 10px; border: 2px solid var(--color-primary); border-radius: var(--radius-sm); font-family: var(--font-main); font-size: 0.9rem; resize: none; background: var(--color-bg); }
    .image-notes:focus { outline: none; }
    .image-actions { display: flex; gap: 8px; overflow-x: auto; scrollbar-width: none; padding-bottom: 2px; margin-top: 12px; }
    .image-actions::-webkit-scrollbar { display: none; }
    .image-actions.hidden { display: none; }
    .image-edit-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 10px; }
    .img-act { flex-shrink: 0; height: 36px; padding: 0 14px; border: none; background: var(--color-bg-btn); border-radius: var(--radius-full); font-family: var(--font-main); font-size: 0.7rem; font-weight: 600; color: var(--color-text-soft); cursor: pointer; display: flex; align-items: center; gap: 5px; white-space: nowrap; }
    .img-act.delete { background: rgba(239,68,68,0.15); color: #EF4444; }
    .img-act:active { background: var(--color-bg-soft); }
    .img-act.primary { background: var(--color-primary); color: white; }
    .image-counter { position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.5); color: white; padding: 4px 12px; border-radius: var(--radius-full); font-size: 0.7rem; font-weight: 600; z-index: 10; }

    @media print {
      body * { visibility: hidden; }
      .image-viewer, .image-viewer img { visibility: visible; }
      .image-viewer { position: absolute; left: 0; top: 0; background: white; }
      .image-viewer img { max-width: 100%; max-height: 100%; }
      .image-viewer-close, .image-viewer-panel { display: none !important; }
    }

    @media (min-width:481px) { 
      .app { margin: 20px auto; height: calc(100vh - 40px); border-radius: var(--radius-lg); box-shadow: 0 10px 40px rgba(0,0,0,0.1); overflow: hidden; }
      .fab-record { right: calc(50% - 220px); }
      .fab-camera { left: calc(50% - 220px); }
      .scroll-fab { right: calc(50% - 220px); }
      .select-bar { left: 50%; right: auto; transform: translateX(-50%); max-width: 480px; border-radius: var(--radius-lg) var(--radius-lg) 0 0; }
    }

    /* ========== INSIGHTS BANNER ========== */
    .insights-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #6366F1 0%, #8B5CF6 100%);
      color: white;
      padding: 12px 16px;
      z-index: 9999;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    .insights-banner.show { transform: translateY(0); }
    .insights-banner-icon { font-size: 24px; }
    .insights-banner-content { flex: 1; }
    .insights-banner-title { font-weight: 600; font-size: 14px; }
    .insights-banner-text { font-size: 12px; opacity: 0.9; margin-top: 2px; }
    .insights-banner-close {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
    }
    .insights-banner-close:hover { background: rgba(255,255,255,0.3); }

    /* Notification permission banner */
    .notif-banner {
      position: fixed;
      bottom: 100px;
      left: 16px;
      right: 16px;
      background: white;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      z-index: 9998;
      display: none;
    }
    .notif-banner.show { display: block; }
    .notif-banner-title { font-weight: 600; margin-bottom: 8px; }
    .notif-banner-text { font-size: 13px; color: #666; margin-bottom: 12px; }
    .notif-banner-actions { display: flex; gap: 8px; }
    .notif-banner-btn {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }
    .notif-banner-btn.primary { background: #6366F1; color: white; }
    .notif-banner-btn.secondary { background: #f3f4f6; color: #666; }
	/* Streaming indicator */
	.streaming-indicator {
	display: inline-block;
	width: 8px;
	height: 8px;
	background: var(--color-primary);
	border-radius: 50%;
	animation: streamPulse 0.5s ease-in-out infinite;
	margin-left: 4px;
	}
	@keyframes streamPulse {
	0%, 100% { opacity: 1; }
	50% { opacity: 0.3; }
	}
  </style>
</head>
<body>
  <!-- Insights Banner -->
  <div class="insights-banner" id="insightsBanner">
    <div class="insights-banner-icon"></div>
    <div class="insights-banner-content">
      <div class="insights-banner-title" id="insightTitle"></div>
      <div class="insights-banner-text" id="insightText">...</div>
    </div>
    <button class="insights-banner-close" onclick="dismissInsight()"></button>
  </div>

  <!-- Notification Permission Banner -->
  <div class="notif-banner" id="notifBanner">
    <div class="notif-banner-title">  ?</div>
    <div class="notif-banner-text">ASKI        </div>
    <div class="notif-banner-actions">
      <button class="notif-banner-btn secondary" onclick="dismissNotifBanner()"></button>
      <button class="notif-banner-btn primary" onclick="requestNotifPermission()"></button>
    </div>
  </div>

  <div class="app" id="app">
    <header class="header">
      <button class="logo-btn" id="logoBtn" onclick="toggleFilters()" title="Toggle filters">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l6 6 6-6"/></svg>
      </button>
      <div class="header-title"><span class="title-drop">Drop</span><span class="title-lit">Lit</span></div>
      <button class="btn-icon" id="menuToggleBtn" onclick="toggleMainMenu()">
        <svg class="menu-icon-open" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
        <svg class="menu-icon-close" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" style="display:none;"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
      </button>
    </header>
    <div class="network-banner" id="netBanner">No internet</div>
    <div class="warning" id="warning">Speech recognition not supported. Use Chrome.</div>
    <div class="search-indicator" id="searchIndicator" style="display:none">
      <span class="search-indicator-text">Searching: <span id="searchQueryDisplay"></span></span>
      <button class="search-indicator-clear" onclick="clearSearch()"> Clear</button>
    </div>
    <div class="filters-wrap">
    <div class="filters">
      <div class="time-row" id="timeRow">
        <button class="time-btn" data-time="all">All <span class="cnt" id="cntAll">0</span></button>
        <button class="time-btn" data-time="today">Today <span class="cnt" id="cntToday">0</span></button>
        <button class="time-btn" data-time="7days">7d <span class="cnt" id="cnt7d">0</span></button>
        <button class="sort-btn" id="sortBtn" onclick="toggleSort()" title="Sort order"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M18 15l-6-6-6 6"/></svg></button>
      </div>
      <div class="cat-row" id="cats">
        <button class="cat" data-category="tasks">Tasks <span class="cnt" id="cntTasks">0</span></button>
        <button class="cat" data-category="ideas">Ideas <span class="cnt" id="cntIdeas">0</span></button>
        <button class="cat" data-category="handmagic">Handmagic <span class="cnt" id="cntHandmagic">0</span></button>
        <button class="cat" data-category="design">Design <span class="cnt" id="cntDesign">0</span></button>
        <button class="cat" data-category="bugs">Bugs <span class="cnt" id="cntBugs">0</span></button>
        <button class="cat" data-category="questions">Questions <span class="cnt" id="cntQuestions">0</span></button>
        <button class="cat" data-category="inbox">Inbox <span class="cnt" id="cntInbox">0</span></button>
        <button class="cat" data-category="audio">Audio <span class="cnt" id="cntAudio">0</span></button>
        <button class="cat" data-category="photo">Photo <span class="cnt" id="cntPhoto">0</span></button>
        <button class="cat" data-category="sketch">Sketch <span class="cnt" id="cntSketch">0</span></button>
        <button class="cat" data-category="scan">Scan <span class="cnt" id="cntScan">0</span></button>
        <button class="cat-add" onclick="addCatPrompt()">+</button>
      </div>
    </div>
    </div>
    <div class="ideas-wrap" id="ideasWrap">
      <div class="ideas" id="ideasList"></div>
      <div class="empty" id="emptyState">
        <div class="empty-icon"><svg viewBox="0 0 24 24"><path d="M12 2C12 2 5 10.5 5 15C5 18.866 8.134 22 12 22C15.866 22 19 18.866 19 15C19 10.5 12 2 12 2Z"/></svg></div>
        <div class="empty-title">Your ideas start here</div>
        <div class="empty-text">SHOOT  PRESS  SPEAK</div>
      </div>
    </div>
  </div>

<input type="file" id="cameraInput" class="camera-input" accept="image/*" capture="environment" onchange="handlePhoto(event)">
  <input type="file" id="imageUpload" class="camera-input" accept="image/*" onchange="handleUploadedImage(event)">
  <input type="file" id="fileUpload" style="display:none" accept=".txt,.md,.csv,.json" onchange="handleUploadedFile(event)">
  
  <!-- FAB Container - all bottom buttons -->
  <div class="fab-container" id="fabContainer">
    <button class="fab-camera" id="fabCamera" onclick="document.getElementById('cameraInput').click()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
    </button>
    <button class="fab-pill" id="fabAskAI" onclick="openAskAI()">AI CHAT</button>
    <button class="fab-pill create" id="fabCreate" onclick="togglePlusMenu()">CREATE+</button>
    <button class="fab-record" id="fabRecord" onclick="handleFabClick(event)" ontouchstart="fabTouchStart()" ontouchend="fabTouchEnd()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
    </button>
  </div>

  <!-- Plus menu backdrop -->
  <div class="plus-menu-backdrop" id="plusBackdrop" onclick="closePlusMenu()"></div>

  <!-- Plus menu -->
  <div class="plus-menu" id="plusMenu">
    <div class="section-divider"><span>Create</span></div>
    <button class="plus-menu-item" onclick="openTextInput()">
      <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14"/><path d="M5 12h14"/></svg></span>
      <div class="info">
        <div class="title">New Drop</div>
        <div class="desc">Text note or idea</div>
      </div>
    </button>
    <button class="plus-menu-item" onclick="pasteLink()">
      <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>
      <div class="info">
        <div class="title">Paste Link</div>
        <div class="desc">Save URL from clipboard</div>
      </div>
    </button>
    <button class="plus-menu-item" onclick="uploadImage()">
      <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg></span>
      <div class="info">
        <div class="title">Upload Image</div>
        <div class="desc">Photo from gallery</div>
      </div>
    </button>
    <button class="plus-menu-item" onclick="uploadFile()">
      <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></svg></span>
      <div class="info">
        <div class="title">Upload File</div>
        <div class="desc">Document or PDF</div>
      </div>
    </button>
    <button class="plus-menu-item" onclick="openAudioRecorder()" style="border-color: #F59E0B;">
      <span class="icon" style="background: linear-gradient(135deg, #FEF3C7, #FDE68A); color: #92400E;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg></span>
      <div class="info">
        <div class="title">Record Audio</div>
        <div class="desc">Voice memo or sound</div>
      </div>
    </button>
    <div class="section-divider"><span>AI Magic</span></div>
    <button class="plus-menu-item magic" onclick="openMagic('poem')">
      <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m12 3-1.9 5.8a2 2 0 0 1-1.3 1.3L3 12l5.8 1.9a2 2 0 0 1 1.3 1.3L12 21l1.9-5.8a2 2 0 0 1 1.3-1.3L21 12l-5.8-1.9a2 2 0 0 1-1.3-1.3Z"/></svg></span>
      <div class="info">
        <div class="title">Create Poem</div>
        <div class="desc">AI-generated poetry</div>
      </div>
    </button>
    <button class="plus-menu-item magic" onclick="openMagic('greeting')">
      <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/></svg></span>
      <div class="info">
        <div class="title">Create Greeting</div>
        <div class="desc">Birthday, holiday wishes</div>
      </div>
    </button>
    <button class="plus-menu-item magic" onclick="openMagic('speech')">
      <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg></span>
      <div class="info">
        <div class="title">Create Speech</div>
        <div class="desc">Toast or presentation</div>
      </div>
    </button>
  </div>

  <!-- Text input modal -->
  <div class="text-input-modal" id="textInputModal">
    <div class="text-input-content">
      <div class="text-input-header">
        <span class="text-input-title">New Drop</span>
        <button class="text-input-close" onclick="closeTextInput()"></button>
      </div>
      <textarea class="text-input-area" id="textInputArea" placeholder="Type your idea here..."></textarea>
      <div class="text-input-actions">
        <button class="text-input-btn cancel" onclick="closeTextInput()">Cancel</button>
        <button class="text-input-btn save" onclick="saveTextNote()">Save</button>
      </div>
    </div>
  </div>

  <!-- AI Magic Modal -->
  <div class="magic-modal" id="magicModal" onclick="if(event.target===this)closeMagic()">
    <div class="magic-content">
      <div class="magic-header">
        <h2 id="magicTitle">Create Poem</h2>
        <p id="magicSubtitle">Tell me what it should be about</p>
      </div>
      <div class="magic-body">
        <!-- Loading indicator -->
        <div class="magic-loading" id="magicLoading">
          <div class="ai-loading-dots magic">
            <span></span><span></span><span></span><span></span><span></span>
          </div>
          <div class="ai-loading-label" id="magicLoadingLabel">Creating magic...</div>
        </div>
        <!-- Form -->
        <div class="magic-form" id="magicForm">
        <!-- Photo section -->
        <div class="magic-photo-section">
          <div style="position: relative;">
            <button class="pill-l sec" id="magicPhotoBtn" onclick="togglePhotoMenu()">
              <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
              <span id="magicPhotoBtnText">Add photo (optional)</span>
            </button>
            <div class="magic-photo-menu" id="magicPhotoMenu">
              <button class="magic-photo-menu-item" onclick="takeMagicPhoto()">
                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg> Take photo
              </button>
              <button class="magic-photo-menu-item" onclick="chooseMagicPhoto()">
                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg> Choose from gallery
              </button>
              <button class="magic-photo-menu-item" onclick="openDropsPicker()">
                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg> Choose from Drops
              </button>
            </div>
          </div>
          <div class="magic-photo-preview" id="magicPhotoPreview" style="display: none;">
            <img id="magicPhotoImg" src="" alt="Selected photo">
            <button class="magic-photo-remove" onclick="removeMagicPhoto()"></button>
          </div>
          <input type="file" id="magicPhotoInput" accept="image/*" style="display:none" onchange="handleMagicPhoto(event)">
          <input type="file" id="magicCameraInput" accept="image/*" capture="environment" style="display:none" onchange="handleMagicPhoto(event)">
        </div>
        
        <label class="magic-input-label" id="magicInputLabel">Add details (optional if photo added)</label>
        <textarea class="magic-input-area" id="magicInput" placeholder="Example: Birthday greeting for mom, she loves gardening and has 2 grandkids..."></textarea>
        <button class="pill-l sec" id="magicVoiceBtn" onclick="toggleMagicVoice()">
          <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
          <span id="magicVoiceText">Tap to speak</span>
        </button>
        <div class="magic-styles" id="magicStyles">
          <button class="magic-style active" data-style="classic">Classic</button>
          <button class="magic-style" data-style="funny">Funny</button>
          <button class="magic-style" data-style="tender">Tender</button>
          <button class="magic-style" data-style="epic">Epic</button>
        </div>
        <button class="pill-xl magic" id="magicGenerate" onclick="generateMagic()">
          Create Magic
        </button>
        </div><!-- end magic-form -->
      </div>
      <div class="magic-footer">
        <button class="pill-l sec" onclick="closeMagic()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Drops Picker Modal -->
  <div class="drops-picker" id="dropsPicker" onclick="if(event.target===this)closeDropsPicker()">
    <div class="drops-picker-content">
      <div class="drops-picker-header">
        <h3>Choose from Drops</h3>
        <button class="drops-picker-close" onclick="closeDropsPicker()"></button>
      </div>
      <div class="drops-picker-grid" id="dropsPickerGrid">
        <!-- Filled dynamically -->
      </div>
    </div>
  </div>

  <!-- Audio Recorder Modal -->
  <div class="audio-recorder-modal" id="audioRecorderModal" onclick="if(event.target===this)closeAudioRecorder()">
    <div class="audio-recorder-content">
      <div class="audio-recorder-header">
        <h2>AUDIO RECORDER</h2>
      </div>
      <div class="audio-recorder-body">
        <div class="audio-recorder-waveform" id="recorderWaveform">
          <div class="bar" style="height:20px"></div>
          <div class="bar" style="height:35px"></div>
          <div class="bar" style="height:50px"></div>
          <div class="bar" style="height:40px"></div>
          <div class="bar" style="height:60px"></div>
          <div class="bar" style="height:45px"></div>
          <div class="bar" style="height:30px"></div>
          <div class="bar" style="height:55px"></div>
          <div class="bar" style="height:70px"></div>
          <div class="bar" style="height:50px"></div>
          <div class="bar" style="height:35px"></div>
          <div class="bar" style="height:60px"></div>
          <div class="bar" style="height:45px"></div>
          <div class="bar" style="height:25px"></div>
          <div class="bar" style="height:40px"></div>
          <div class="bar" style="height:55px"></div>
          <div class="bar" style="height:35px"></div>
          <div class="bar" style="height:50px"></div>
          <div class="bar" style="height:65px"></div>
          <div class="bar" style="height:40px"></div>
        </div>
        <div class="audio-recorder-time" id="recorderTime">0:00</div>
        <div class="audio-recorder-controls">
          <button class="ctrl-btn rewind" onclick="recorderRewind()">&lt;&lt;</button>
          <button class="ctrl-btn" id="recorderStopBtn" onclick="recorderStop()" style="background:#EF4444; color:white; font-weight:700;">STOP</button>
          <button class="ctrl-btn play" id="recorderPlayBtn" onclick="recorderPlayPause()">PLAY</button>
          <button class="ctrl-btn forward" onclick="recorderForward()">&gt;&gt;</button>
        </div>
        <button class="audio-recorder-main-btn ready" id="recorderMainBtn" onclick="recorderToggleRecord()">
          <span id="recorderMainText">TAP TO RECORD</span>
        </button>
        <div class="audio-recorder-actions">
          <button class="act-btn delete" onclick="recorderDelete()" disabled>DELETE</button>
          <button class="act-btn create" onclick="recorderCreateDrop()" disabled>CREATE DROP</button>
          <button class="act-btn share" onclick="recorderShare()" disabled>SHARE</button>
        </div>
        <button class="audio-recorder-cancel" onclick="closeAudioRecorder()">CANCEL</button>
      </div>
    </div>
  </div>

  <!-- AI Tools Modal (for text drops) -->
  <div class="ai-tools-modal" id="aiToolsModal" onclick="if(event.target===this)closeAITools()">
    <div class="ai-tools-content">
      <div class="ai-tools-header">
        <h2>AI Tools</h2>
        <p>What would you like to do?</p>
      </div>
      <div class="ai-tools-preview">
        <div class="ai-tools-preview-label">Selected drop:</div>
        <div class="ai-tools-preview-text" id="aiToolsPreviewText"></div>
      </div>
      <div class="ai-tools-body">
        <div class="ai-tools-grid">
          <button class="ai-tool-btn" onclick="runAITool('summarize')">
            <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/></svg></span>
            <div class="info">
              <div class="title">Summarize</div>
              <div class="desc">Make it shorter and clearer</div>
            </div>
          </button>
          <button class="ai-tool-btn" onclick="runAITool('tasks')">
            <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="m9 12 2 2 4-4"/></svg></span>
            <div class="info">
              <div class="title">Create Tasks</div>
              <div class="desc">Extract actionable to-dos</div>
            </div>
          </button>
          <button class="ai-tool-btn" onclick="runAITool('expand')">
            <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m12 3-1.9 5.8a2 2 0 0 1-1.3 1.3L3 12l5.8 1.9a2 2 0 0 1 1.3 1.3L12 21l1.9-5.8a2 2 0 0 1 1.3-1.3L21 12l-5.8-1.9a2 2 0 0 1-1.3-1.3Z"/></svg></span>
            <div class="info">
              <div class="title">Expand</div>
              <div class="desc">Add more details and ideas</div>
            </div>
          </button>
          <button class="ai-tool-btn" onclick="runAITool('rewrite')">
            <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg></span>
            <div class="info">
              <div class="title">Rewrite</div>
              <div class="desc">Different style or tone</div>
            </div>
          </button>
          <button class="ai-tool-btn" onclick="runAITool('enhance')">
            <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg></span>
            <div class="info">
              <div class="title">Enhance</div>
              <div class="desc">Fix errors, punctuation, formatting</div>
            </div>
          </button>
          <button class="ai-tool-btn" onclick="openTranslateModal()">
            <span class="icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg></span>
            <div class="info">
              <div class="title">Translate</div>
              <div class="desc">Translate to another language</div>
            </div>
          </button>
        </div>
        <div class="ai-tools-option">
          <input type="checkbox" id="aiToolsCheckCategory" checked>
          <div class="ai-tools-option-label">
            <div class="title">Also check/update category</div>
            <div class="current">Current: <span id="aiToolsCurrentCategory">INBOX</span></div>
          </div>
        </div>
        <div class="ai-tools-option">
          <input type="checkbox" id="aiToolsRemoveLineBreaks">
          <div class="ai-tools-option-label">
            <div class="title">Remove extra line breaks</div>
            <div class="current">Join paragraphs into continuous text</div>
          </div>
        </div>
      </div>
      <div class="ai-tools-footer">
        <button class="pill-l sec" onclick="closeAITools()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- AI Result Modal (large, with actions) -->
  <div class="ai-result-modal" id="aiResultModal2" onclick="if(event.target===this)closeAIResult2()">
    <div class="ai-result-content">
      <div class="ai-result-header">
        <h2 id="aiResult2Title">Result</h2>
      </div>
      <div class="ai-result-body">
        <div class="ai-result-text" id="aiResult2Text"></div>
        <div class="ai-result-category" id="aiResult2Category" style="display:none;">
          <div class="ai-result-category-title">Suggested category</div>
          <div class="ai-result-category-row">
            <span class="ai-result-category-current" id="aiResult2CurrentCat">INBOX</span>
            <span class="ai-result-category-arrow"></span>
            <span class="ai-result-category-suggested" id="aiResult2SuggestedCat">TASKS</span>
          </div>
          <div class="ai-result-category-actions">
            <button class="ai-result-category-btn" onclick="keepCategory()">Keep current</button>
            <button class="ai-result-category-btn accept" onclick="acceptCategory()">Change</button>
          </div>
        </div>
      </div>
      <div class="ai-result-actions">
        <button class="pill-l magic" onclick="replaceOriginal()">Replace original</button>
        <div class="pill-row">
          <button class="pill-l sec" onclick="createNewDrop()">New Drop</button>
          <button class="pill-l sec" onclick="copyResult2()">Copy</button>
        </div>
        <button class="pill-l sec" onclick="closeAIResult2()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- B2 FIX: Tasks Confirmation Modal -->
  <div class="ai-result-modal" id="tasksConfirmModal" onclick="if(event.target===this)closeTasksConfirm()">
    <div class="ai-result-content">
      <div class="ai-result-header" style="background: linear-gradient(135deg, #10B981, #3B82F6);">
        <h2>Extracted Tasks</h2>
      </div>
      <div class="ai-result-body">
        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 12px;">Found <span id="tasksCount">0</span> tasks. Each will become a separate drop:</p>
        <div class="tasks-preview-list" id="tasksPreviewList"></div>
      </div>
      <div class="ai-result-actions">
        <button class="pill-l success" onclick="confirmCreateTasks()">
          Create <span id="tasksCountBtn">0</span> Task Drops
        </button>
        <button class="pill-l sec" onclick="closeTasksConfirm()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- I1 FIX: Translate Modal -->
  <div class="ai-result-modal" id="translateModal" onclick="if(event.target===this)closeTranslateModal()">
    <div class="ai-result-content" style="max-width: 360px;">
      <div class="ai-result-header" style="background: linear-gradient(135deg, #3B82F6, #10B981);">
        <h2>Translate</h2>
      </div>
      <div class="ai-result-body" style="padding: 20px;">
        <p style="color: var(--color-text-muted); font-size: 0.85rem; margin-bottom: 16px;">Select target language:</p>
        <div class="translate-langs">
          <button class="translate-lang-btn" onclick="runTranslate('English')"> English</button>
          <button class="translate-lang-btn" onclick="runTranslate('Russian')"> </button>
          <button class="translate-lang-btn" onclick="runTranslate('Spanish')"> Espaol</button>
          <button class="translate-lang-btn" onclick="runTranslate('German')"> Deutsch</button>
          <button class="translate-lang-btn" onclick="runTranslate('French')"> Franais</button>
          <button class="translate-lang-btn" onclick="runTranslate('Chinese')"> </button>
          <button class="translate-lang-btn" onclick="runTranslate('Japanese')"> </button>
          <button class="translate-lang-btn" onclick="runTranslate('Portuguese')"> Portugus</button>
        </div>
      </div>
      <div class="ai-result-actions" style="padding: 16px 20px;">
        <button class="pill-l sec" onclick="closeTranslateModal()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="rec-status" id="recStatus">
    <span class="rec-dot"></span>
    <span class="rec-text" id="recText">Listening...</span>
  </div>

  <button class="scroll-fab top" id="scrollTop" onclick="scrollToTop()"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M18 15l-6-6-6 6"/></svg></button>
  <button class="scroll-fab bottom" id="scrollBottom" onclick="scrollToBottom()"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M6 9l6 6 6-6"/></svg></button>

  <!-- Ask AI Panel -->
  <div class="ask-ai-panel" id="askAIPanel">
    <div class="ask-ai-handle" onclick="closeAskAI()">
      <div class="ask-ai-handle-bar"></div>
    </div>
    <div class="ask-ai-header">
      <div class="ask-ai-header-left">
        <div class="ask-ai-avatar">A</div>
        <div>
          <div class="ask-ai-title">Aski</div>
          <div class="ask-ai-subtitle" id="askiSubtitle">AI Assistant</div>
        </div>
      </div>
      <button class="pill-s ask-ai-btn-autodrop" id="autoDropIndicator" onclick="toggleAutoDropFromChat()" style="display: none;">AUTODROP</button>
      <button class="ask-ai-close" onclick="closeAskAI()"></button>
    </div>
    <div class="ask-ai-messages" id="askAIMessages">
      <div class="ask-ai-empty" id="askAIEmpty">
        <div class="ask-ai-empty-icon"><svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#8B5CF6" stroke-width="1.5"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg></div>
        <div class="ask-ai-empty-title">Ask me anything</div>
        <div class="ask-ai-empty-text">I'm here to help  answer questions, give ideas, or just chat.</div>
        <div class="ask-ai-prompts">
          <button class="ask-ai-prompt" onclick="setAskAIPrompt('   ?')"> ?</button>
          <button class="ask-ai-prompt" onclick="setAskAIPrompt(' ')"></button>
          <button class="ask-ai-prompt" onclick="setAskAIPrompt('  ?')"> </button>
        </div>
      </div>
    </div>
    <div class="ask-ai-input-area">
      <div class="ask-ai-input-row">
        <button class="ask-ai-btn ask-ai-btn-voice" id="askAIVoiceBtn" onclick="toggleAskAIVoice()">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
        </button>
        <textarea class="ask-ai-input" id="askAIInput" placeholder="Ask anything..." maxlength="2000" rows="2" oninput="updateAskAICharCount(); autoResizeTextarea(this);" onkeypress="if(event.key==='Enter' && !event.shiftKey && this.value.trim()) { event.preventDefault(); sendAskAIMessage(); }"></textarea>
        <button class="ask-ai-btn ask-ai-btn-send" id="askAISendBtn" onclick="console.log('Send clicked'); sendAskAIMessage()">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M22 2 11 13"/><path d="M22 2 15 22 11 13 2 9 22 2Z"/></svg>
        </button>
      </div>
	  <div class="ask-ai-controls-bottom" id="askAIControlsBottom">
        <button class="ask-ai-control-left" id="askAIControlLeft" onclick="handleChatControlLeft()">HIDE</button>
        <button class="ask-ai-control-right" id="askAIControlRight" onclick="toggleAskAIVoice()">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
          <span id="askAIControlRightText">TAP TO TALK</span>
        </button>
      </div>
      <button class="ask-ai-voice-large" id="askAIVoiceLarge" onclick="toggleAskAIVoice()">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
        <span id="voiceLargeText">Tap to talk</span>
      </button>
      <div class="ask-ai-char-count" id="askAICharCount">0 / 2000</div>
    </div>
  </div>

  <!-- Selection bar for merge -->
  <div class="select-bar" id="selectBar">
    <div class="select-info"><span id="selectCount">0</span> selected</div>
    <div class="select-actions">
      <button class="select-btn cancel" onclick="cancelSelect()">Cancel</button>
      <button class="select-btn delete" onclick="deleteSelected()">Delete</button>
      <button class="select-btn merge" onclick="showMergePreview()">Merge/Copy</button>
    </div>
  </div>

  <div class="toast-wrap" id="toastWrap"></div>

  <!-- Main Menu Modal -->
  <div class="main-menu" id="mainMenu" onclick="if(event.target===this)closeMainMenu()">
    <div class="main-menu-content">
      <div class="main-menu-header">
        <h2><svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg> Menu</h2>
        <button class="pill-s sec" onclick="closeMainMenu()">Close</button>
      </div>
      
      <!-- Balance Card -->
      <div class="balance-card">
        <div class="balance-label">AI Token Balance</div>
        <div class="balance-value" id="tokenBalance"></div>
        <div class="balance-hint">Tokens refresh monthly  <span id="tokenUsage">Loading...</span></div>
      </div>
      
      <!-- Search Section -->
      <div class="menu-section" style="border-bottom: none;">
        <div class="section-divider"><span>Search</span></div>
        <input type="text" class="menu-search-input" id="menuSearchInput" placeholder="Search drops..." onkeypress="if(event.key==='Enter')performSearch()" style="width: 100%; margin-bottom: 16px;">
        <div class="pill-row">
          <button class="pill-m sec" onclick="startVoiceSearch()">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/></svg>
            Voice
          </button>
          <button class="pill-m pri" onclick="performSearch()">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
            Search
          </button>
        </div>
      </div>
      
      <!-- Undo Section -->
      <div class="menu-section" style="border-bottom: none;">
        <div class="section-divider"><span>Undo</span></div>
        <div class="undo-header">
          <button class="pill-l ai" id="undoMainBtn" onclick="undoLast()" disabled>
             Undo Last Action
          </button>
        </div>
        <div id="undoLastInfo" style="text-align: center; font-size: 0.85rem; color: var(--color-text-muted); margin-top: 8px;"></div>
        <button class="pill-l sec" id="undoToggleBtn" onclick="toggleUndoList()" style="display: none; margin-top: 12px;">
          Show history (0)
        </button>
        <div class="undo-list" id="undoList"></div>
      </div>
      
      <!-- Settings Section -->
      <div class="menu-section no-border">
        <div class="section-divider"><span>Aski Voice</span></div>
        
        <div class="settings-item">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg></span>
            <span class="settings-item-label">Voice Mode</span>
            <span class="settings-item-warning"><svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg> Uses more battery</span>
          </div>
          <div class="settings-toggle" id="voiceModeToggle" onclick="toggleVoiceMode()"></div>
        </div>
        
        <div class="settings-item">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg></span>
            <span class="settings-item-label">Auto-speak replies</span>
          </div>
          <div class="settings-toggle" id="autoSpeakToggle" onclick="toggleAutoSpeak()"></div>
        </div>
        
        <div class="settings-item no-border" style="flex-direction: column; align-items: flex-start; gap: 12px;">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M20 21a8 8 0 0 0-16 0"/></svg></span>
            <span class="settings-item-label">TTS Provider</span>
          </div>
          <div class="pill-row" id="ttsProviderSelector">
            <button class="pill-m" data-provider="openai" onclick="setTTSProvider('openai')">OpenAI</button>
            <button class="pill-m" data-provider="elevenlabs" onclick="setTTSProvider('elevenlabs')">ElevenLabs</button>
            <button class="pill-m" data-provider="browser" onclick="setTTSProvider('browser')">Browser</button>
          </div>
        </div>
        
        <!-- OpenAI Voice Settings -->
        <div id="openaiVoiceSettings">
          <div class="settings-item no-border" style="flex-direction: column; align-items: flex-start; gap: 12px;">
            <div class="settings-item-left">
              <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg></span>
              <span class="settings-item-label">OpenAI Voice</span>
            </div>
            <div class="pill-row" id="voiceSelector" style="flex-wrap: wrap;">
              <button class="pill-m" data-voice="nova" onclick="setAskiVoice('nova')">Nova</button>
              <button class="pill-m" data-voice="shimmer" onclick="setAskiVoice('shimmer')">Shimmer</button>
              <button class="pill-m" data-voice="alloy" onclick="setAskiVoice('alloy')">Alloy</button>
              <button class="pill-m" data-voice="onyx" onclick="setAskiVoice('onyx')">Onyx</button>
              <button class="pill-m" data-voice="echo" onclick="setAskiVoice('echo')">Echo</button>
              <button class="pill-m" data-voice="fable" onclick="setAskiVoice('fable')">Fable</button>
            </div>
            <div class="voice-preview-hint" style="font-size: 0.75rem; color: var(--color-text-muted); margin-top: 4px;">Tap voice to preview</div>
          </div>
          
          <div class="settings-item no-border" style="flex-direction: column; align-items: flex-start; gap: 12px;">
            <div class="settings-item-left">
              <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg></span>
              <span class="settings-item-label">OpenAI API Key</span>
            </div>
            <div style="width: 100%; display: flex; gap: 8px;">
              <input type="password" id="openaiApiKeyInput" placeholder="sk-..." style="flex: 1; padding: 10px 14px; border: 1px solid var(--color-border); border-radius: var(--radius-md); font-family: var(--font-main); font-size: 0.9rem; background: var(--color-bg);" oninput="saveOpenAIKey()">
              <button class="pill-m" onclick="toggleApiKeyVisibility('openai')" id="apiKeyToggleBtn" style="min-width: 60px;">Show</button>
            </div>
            <div id="apiKeyStatus" style="font-size: 0.75rem; color: var(--color-text-muted);"></div>
          </div>
        </div>
        
        <!-- ElevenLabs Voice Settings -->
        <div id="elevenlabsVoiceSettings" style="display: none;">
          <div class="settings-item no-border" style="flex-direction: column; align-items: flex-start; gap: 12px;">
            <div class="settings-item-left">
              <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg></span>
              <span class="settings-item-label">ElevenLabs Voice (Russian)</span>
            </div>
            <div class="pill-row" id="elevenlabsVoiceSelector" style="flex-wrap: wrap;">
              <button class="pill-m" data-voice="Nadia" data-voiceid="gedzfqL7OGdPbwm0ynTP" onclick="selectElevenLabsVoice('Nadia','gedzfqL7OGdPbwm0ynTP')">Nadia</button>
              <button class="pill-m" data-voice="Larisa" data-voiceid="AB9XsbSA4eLG12t2myjN" onclick="selectElevenLabsVoice('Larisa','AB9XsbSA4eLG12t2myjN')">Larisa</button>
              <button class="pill-m" data-voice="Dmitry" data-voiceid="kwajW3Xh5svCeKU5ky2S" onclick="selectElevenLabsVoice('Dmitry','kwajW3Xh5svCeKU5ky2S')">Dmitry</button>
              <button class="pill-m" data-voice="Bella" data-voiceid="EXAVITQu4vr4xnSDxMaL" onclick="selectElevenLabsVoice('Bella','EXAVITQu4vr4xnSDxMaL')">Bella</button>
              <button class="pill-m" data-voice="Rachel" data-voiceid="21m00Tcm4TlvDq8ikWAM" onclick="selectElevenLabsVoice('Rachel','21m00Tcm4TlvDq8ikWAM')">Rachel</button>
            </div>
            <div class="voice-preview-hint" style="font-size: 0.75rem; color: var(--color-text-muted); margin-top: 4px;">Tap voice to preview  Native Russian speakers</div>
          </div>
          
          <div class="settings-item no-border" style="flex-direction: column; align-items: flex-start; gap: 12px;">
            <div class="settings-item-left">
              <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg></span>
              <span class="settings-item-label">ElevenLabs API Key</span>
            </div>
            <div style="width: 100%; display: flex; gap: 8px;">
              <input type="password" id="elevenlabsApiKeyInput" placeholder="xi-..." style="flex: 1; padding: 10px 14px; border: 1px solid var(--color-border); border-radius: var(--radius-md); font-family: var(--font-main); font-size: 0.9rem; background: var(--color-bg);" oninput="saveElevenLabsKey()">
              <button class="pill-m" onclick="toggleApiKeyVisibility('elevenlabs')" id="elevenlabsApiKeyToggleBtn" style="min-width: 60px;">Show</button>
            </div>
            <div id="elevenlabsApiKeyStatus" style="font-size: 0.75rem; color: var(--color-text-muted);"></div>
            <div style="font-size: 0.7rem; color: var(--color-text-muted); margin-top: 4px;">
              Get free API key at <a href="https://elevenlabs.io" target="_blank" style="color: #8B5CF6;">elevenlabs.io</a> (10K chars/month free)
            </div>
          </div>
        </div>
        
        <div class="settings-item no-border" style="flex-direction: column; align-items: flex-start; gap: 12px;">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg></span>
            <span class="settings-item-label">Listen time after Aski, sec</span>
          </div>
          <div class="pill-row" id="listenCyclesSelector">
            <button class="pill-m" data-cycles="10" onclick="setListenCycles(10)">10</button>
            <button class="pill-m active" data-cycles="15" onclick="setListenCycles(15)">15</button>
            <button class="pill-m" data-cycles="20" onclick="setListenCycles(20)">20</button>
            <button class="pill-m" data-cycles="25" onclick="setListenCycles(25)">25</button>
          </div>
        </div>
        
        <div class="section-divider"><span>Aski Chat</span></div>
        
        <div class="settings-item">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v4"/><path d="M12 18v4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/><path d="M2 12h4"/><path d="M18 12h4"/><path d="M4.93 19.07l2.83-2.83"/><path d="M16.24 7.76l2.83-2.83"/></svg></span>
            <span class="settings-item-label">AutoDrop</span>
            <span class="settings-item-hint" style="font-size: 0.7rem; color: var(--color-text-muted); margin-left: 8px;">Auto-save all messages</span>
          </div>
          <div class="settings-toggle" id="autoDropToggle" onclick="toggleAutoDrop()"></div>
        </div>
        
        <div class="section-divider"><span>Display</span></div>
        
        <div class="settings-item">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg></span>
            <span class="settings-item-label">Dark mode</span>
          </div>
          <div class="settings-toggle" id="darkModeToggle" onclick="toggleDarkMode()"></div>
        </div>
        
        <div class="settings-item no-border" style="flex-direction: column; align-items: flex-start; gap: 12px;">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/></svg></span>
            <span class="settings-item-label">Font size</span>
          </div>
          <div class="pill-row" id="fontSizeSelector">
            <button class="pill-m" data-size="small" onclick="setFontSize('small')">Small</button>
            <button class="pill-m" data-size="normal" onclick="setFontSize('normal')">Normal</button>
            <button class="pill-m" data-size="large" onclick="setFontSize('large')">Large</button>
          </div>
        </div>
        
        <div class="section-divider"><span>Cloud</span></div>
        
        <div class="settings-item no-border">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg></span>
            <div>
              <span class="settings-item-label">Cloud Sync</span>
              <div id="lastSyncInfo" style="font-size: 0.65rem; color: var(--color-text-muted); margin-top: 2px;">Last sync: </div>
            </div>
          </div>
          <button class="pill-m pri" onclick="manualSync()">Sync Now</button>
        </div>
        
        <div class="section-divider"><span>Data</span></div>
        
        <div class="settings-item">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 8V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v3"/><path d="M21 16v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-3"/><path d="M4 12h16"/><path d="m9 8-4 4 4 4"/><path d="m15 8 4 4-4 4"/></svg></span>
            <span class="settings-item-label">Export data</span>
          </div>
          <button class="pill-m sec" onclick="exportData()">Export</button>
        </div>
        
        <div class="settings-item">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg></span>
            <span class="settings-item-label">Import data</span>
          </div>
          <button class="pill-m sec" onclick="document.getElementById('importFileInput').click()">Import</button>
          <input type="file" id="importFileInput" style="display:none" accept=".json" onchange="handleImportFile(event)">
        </div>
        
        <div class="settings-item no-border" style="padding-bottom: 0;">
          <div class="settings-item-left">
            <span class="settings-item-icon"><svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg></span>
            <span class="settings-item-label">Clear all data</span>
          </div>
          <button class="pill-m danger" onclick="clearAllData()">Clear</button>
        </div>
        
        <div class="section-divider"><span>About</span></div>
        
        <!-- Debug button -->
        <div style="padding: 12px 0;">
          <button class="pill-l sec" onclick="showDebugInfo()" style="width: 100%;"> Debug & Sync Info</button>
        </div>
        
        <div class="menu-about" onclick="closeMainMenu(); openAbout();" style="cursor: pointer;">
          <div class="menu-about-logo">
            <svg viewBox="0 0 24 24"><path d="M12 2C12 2 5 10.5 5 15C5 18.866 8.134 22 12 22C15.866 22 19 18.866 19 15C19 10.5 12 2 12 2Z"/></svg>
          </div>
          <div class="menu-about-name">DropLit</div>
          <div class="menu-about-ver">v0.9.58 by Syntrise</div>
          <div style="font-size: 0.7rem; color: var(--color-primary); margin-top: 8px;">Tap for more info</div>
        </div>
      </div>
      
      <!-- Footer with Close button -->
      <div class="main-menu-footer">
        <button class="pill-l sec" onclick="showDebugInfo()" style="margin-right: 8px;"> Debug</button>
        <button class="pill-l sec" onclick="closeMainMenu()">Close Menu</button>
      </div>
    </div>
  </div>

  <!-- Modals -->
  <div class="overlay" id="aboutModal"><div class="modal"><div class="about-brand"><div class="about-logo"><svg viewBox="0 0 24 24" fill="white"><path d="M12 2C12 2 5 10.5 5 15C5 18.866 8.134 22 12 22C15.866 22 19 18.866 19 15C19 10.5 12 2 12 2Z"/></svg></div><div class="about-name">DropLit</div><div class="about-ver">v0.9.58 by Syntrise</div></div><div class="modal-text" style="text-align:center">Voice-first idea capture.<br>Long press card to select & merge.</div><div class="modal-actions"><button class="modal-btn pri" onclick="closeAbout()">Got it</button></div></div></div>
  <div class="overlay" id="catModal"><div class="modal type-b"><div class="modal-header"><h3>Move to Category</h3></div><div class="modal-body"><div class="cat-grid"><button class="cat-opt" data-cat="tasks" onclick="changeCat('tasks')">Tasks</button><button class="cat-opt" data-cat="ideas" onclick="changeCat('ideas')">Ideas</button><button class="cat-opt" data-cat="handmagic" onclick="changeCat('handmagic')">Handmagic</button><button class="cat-opt" data-cat="design" onclick="changeCat('design')">Design</button><button class="cat-opt" data-cat="bugs" onclick="changeCat('bugs')">Bugs</button><button class="cat-opt" data-cat="questions" onclick="changeCat('questions')">Questions</button><button class="cat-opt" data-cat="sketch" onclick="changeCat('sketch')">Sketch</button><button class="cat-opt" data-cat="scan" onclick="changeCat('scan')">Scan</button><button class="cat-opt" data-cat="inbox" onclick="changeCat('inbox')">Inbox</button></div></div><div class="modal-actions"><button class="modal-btn sec" onclick="closeCatModal()">Cancel</button></div></div></div>
  <div class="overlay" id="sendModal"><div class="modal type-b"><div class="modal-header"><h3>Share Drop</h3></div><div class="modal-body"><div class="send-opts"><div class="send-opt" onclick="sendAI()"><div class="send-icon">AI</div><div class="send-info"><div class="send-title">AI Assistant</div><div class="send-desc">Copy + open Claude</div></div><span class="send-badge">Pro</span></div><div class="send-div">or share via</div><div class="send-opt" onclick="shareNative()"><div class="send-icon">...</div><div class="send-info"><div class="send-title">Share...</div><div class="send-desc">WhatsApp, Telegram</div></div></div><div class="send-opt" onclick="sendMail()"><div class="send-icon">@</div><div class="send-info"><div class="send-title">Email</div><div class="send-desc">Send via email</div></div></div><div class="send-opt" onclick="copyClip()"><div class="send-icon">#</div><div class="send-info"><div class="send-title">Copy</div><div class="send-desc">Copy to clipboard</div></div></div></div></div><div class="modal-actions"><button class="modal-btn sec" onclick="closeSendModal()">Cancel</button></div></div></div>
  <div class="overlay" id="exportModal"><div class="modal type-b"><div class="modal-header"><h3>Export Data</h3></div><div class="modal-body"><div class="export-box" id="exportBox"></div></div><div class="modal-actions"><button class="modal-btn sec" onclick="closeExportModal()">Close</button><button class="modal-btn pri" onclick="copyExport()">Copy All</button></div></div></div>
  <div class="overlay" id="delModal"><div class="modal"><div class="modal-title">Delete this idea?</div><div class="modal-text">This action cannot be undone.</div><div class="modal-actions"><button class="modal-btn sec" onclick="closeDelModal()">Cancel</button><button class="modal-btn danger" onclick="confirmDel()">Delete</button></div></div></div>
  <div class="overlay" id="settingsModal"><div class="modal type-b"><div class="modal-header"><h3>Settings</h3></div><div class="modal-body"><div class="modal-text" style="margin-bottom:0;">Syntrise CORE:<br>Sync your ideas to cloud</div></div><div class="modal-actions"><button class="modal-btn sec" onclick="syncToCloud()">Sync</button><button class="modal-btn sec" onclick="exportAll()">Export</button><button class="modal-btn pri" onclick="closeSettings()">Done</button></div></div></div>
  <div class="overlay" id="addCatModal"><div class="modal"><div class="modal-title">Add Category</div><div class="modal-text">Custom categories coming in a future update!</div><div class="modal-actions"><button class="modal-btn pri" onclick="closeAddCatModal()">OK</button></div></div></div>
  <div class="overlay" id="mergeModal"><div class="modal type-b"><div class="modal-header"><h3>Merge Preview</h3></div><div class="modal-body"><div class="merge-options"><label class="merge-toggle"><input type="checkbox" id="mergeSimple" onchange="updateMergePreview()"><span>Simple merge (no headers)</span></label></div><div class="merge-preview" id="mergePreview"></div></div><div class="modal-actions"><button class="pill-m sec" onclick="closeMergeModal()">Cancel</button><button class="pill-m sec" onclick="copyMerged()">Copy</button><button class="pill-m merge" onclick="saveMerged()">Save Merge</button></div></div></div>
  <div class="overlay image-viewer" id="imageViewer" onclick="handleImageViewerClick(event)">
    <div class="image-viewer-close" onclick="closeImageViewer()"></div>
    <div class="image-viewer-markers" id="imageViewerMarkers" onclick="openPhotoMarkers()"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.57a2 2 0 0 1-2.83-2.83l8.49-8.47"/></svg></div>
    <div class="image-viewer-ai" onclick="openPhotoAI()"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="m12 3-1.9 5.8a2 2 0 0 1-1.3 1.3L3 12l5.8 1.9a2 2 0 0 1 1.3 1.3L12 21l1.9-5.8a2 2 0 0 1 1.3-1.3L21 12l-5.8-1.9a2 2 0 0 1-1.3-1.3Z"/></svg></div>
    <div class="image-counter" id="imageCounter">1 / 1</div>
    <div class="image-viewer-nav prev" id="imgNavPrev" onclick="navigateImage(-1)"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M15 18l-6-6 6-6"/></svg></div>
    <div class="image-viewer-nav next" id="imgNavNext" onclick="navigateImage(1)"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M9 18l6-6-6-6"/></svg></div>
    <div class="image-viewer-content" id="imageViewerContent">
      <img id="imageViewerImg" src="" alt="Full size">
    </div>
    <div class="image-viewer-panel" onclick="event.stopPropagation()">
      <div class="image-meta" id="imageMeta"></div>
      <div class="image-caption-row">
        <button class="caption-edit-btn" onclick="startEditCaption()">Edit</button>
        <div class="image-caption-display" id="imageCaptionDisplay"></div>
      </div>
      <div class="image-notes-wrap" id="imageNotesWrap">
        <textarea class="image-notes" id="imageNotes" placeholder="Add caption or notes..." rows="2"></textarea>
        <div class="image-edit-actions" id="imageEditActions">
          <button class="img-act" onclick="cancelEditCaption()">Cancel</button>
          <button class="img-act primary" onclick="saveCaption()">Save</button>
        </div>
      </div>
      <div class="image-actions" id="imageActions">
        <button class="img-act" onclick="shareImage()">Share</button>
        <button class="img-act" onclick="saveImageToGallery()">Download</button>
        <button class="img-act delete" onclick="deleteFromViewer()">Delete</button>
      </div>
    </div>
  </div>

  <!-- Photo AI Tools Modal -->
  <div class="photo-ai-modal" id="photoAIModal" onclick="if(event.target===this)closePhotoAI()">
    <div class="photo-ai-content">
      <div class="photo-ai-header">
        <h3>AI Tools</h3>
        <p>What would you like to do?</p>
      </div>
      <div class="photo-ai-tools">
        <button class="photo-ai-btn" onclick="runPhotoAI('ocr')">
          <div class="icon"><svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/></svg></div>
          <div class="info">
            <div class="title">Extract Text (OCR)</div>
            <div class="desc">Read and copy text from image</div>
          </div>
        </button>
        <button class="photo-ai-btn" onclick="runPhotoAI('describe')">
          <div class="icon"><svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg></div>
          <div class="info">
            <div class="title">Describe Image</div>
            <div class="desc">AI generates detailed description</div>
          </div>
        </button>
        <button class="photo-ai-btn" onclick="startEditCaption(); closePhotoAI();">
          <div class="icon"><svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg></div>
          <div class="info">
            <div class="title">Edit Caption</div>
            <div class="desc">Add or edit photo notes</div>
          </div>
        </button>
      </div>
      <button class="pill-l sec" onclick="closePhotoAI()">Cancel</button>
    </div>
  </div>

  <!-- Photo AI Result Modal -->
  <div class="photo-ai-result" id="photoAIResult" onclick="if(event.target===this)closePhotoAIResult()">
    <div class="photo-ai-result-content">
      <div class="photo-ai-result-header">
        <h3 id="photoAIResultTitle">Result</h3>
      </div>
      <div class="photo-ai-result-text" id="photoAIResultText"></div>
      <div class="photo-ai-result-actions">
        <button class="pill-l ai" onclick="savePhotoAIToCaption()">Set as Caption</button>
        <button class="pill-l sec" onclick="savePhotoAIToNewDrop()">Create New Drop</button>
        <button class="pill-l sec" onclick="copyPhotoAIResult()">Copy to Clipboard</button>
      </div>
    </div>
  </div>

  <!-- Photo Markers Modal -->
  <div class="photo-markers-modal" id="photoMarkersModal" onclick="if(event.target===this)closePhotoMarkersModal()">
    <div class="photo-markers-content">
      <div class="photo-markers-title">Add Markers</div>
      <div class="photo-markers-grid" id="photoMarkersGrid"></div>
      <button class="photo-markers-done" onclick="closePhotoMarkersModal()">Done</button>
    </div>
  </div>

<script>
if('serviceWorker' in navigator){navigator.serviceWorker.register('sw.js').catch(()=>{});}
let ideas=JSON.parse(localStorage.getItem('droplit_ideas'))||[];

// ============================================
// AUTO-FIX: Repair string IDs (v0.9.58)
// ============================================
(function autoFixIds() {
  let fixed = 0;
  ideas = ideas.map((item, index) => {
    if (typeof item.id === 'string') {
      item.id = Date.now() + index; // Unique numeric ID
      fixed++;
    }
    return item;
  });
  if (fixed > 0) {
    localStorage.setItem('droplit_ideas', JSON.stringify(ideas));
    console.log(` Auto-fixed ${fixed} drop(s) with string IDs`);
  }
})();

// ============================================
// SUPABASE SYNC (v0.9.58)
// ============================================
const SUPABASE_URL = 'https://ughfdhmyflotgsysvrrc.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVnaGZkaG15ZmxvdGdzeXN2cnJjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4NDgwMTEsImV4cCI6MjA4MjQyNDAxMX0.s6oAvyk6gJU0gcJV00HxPnxkvWIbhF2I3pVnPMNVcrE';

let supabaseClient = null;
let currentUser = null;
let syncEnabled = true;
let isSyncing = false;
let syncQueue = [];
let lastSyncTime = null;

// Device ID for tracking
const DEVICE_ID = localStorage.getItem('droplit_device_id') || (() => {
  const id = 'dev_' + Math.random().toString(36).substr(2, 9);
  localStorage.setItem('droplit_device_id', id);
  return id;
})();

console.log(' Device ID:', DEVICE_ID);

// Initialize Supabase
async function initSupabase() {
  try {
    if (typeof window.supabase === 'undefined') {
      console.log(' Supabase SDK not loaded');
      updateSyncUI('offline', 'No SDK');
      return false;
    }
    
    supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    console.log(' Supabase client initialized');
    
    // Check for existing session
    const { data: { session } } = await supabaseClient.auth.getSession();
    
    // If session exists but NOT our test user - sign out first
    const TEST_USER_ID = '10531fa2-b07e-41db-bc41-f6bd955beb26';
    
    if (session && session.user.id !== TEST_USER_ID) {
      console.log(' Wrong user, signing out...', session.user.id.substring(0, 8));
      await supabaseClient.auth.signOut();
      await signInWithTestAccount();
    } else if (session && session.user.id === TEST_USER_ID) {
      currentUser = session.user;
      toast(' User: ' + currentUser.id.substring(0, 8) + '...', 'success');
      console.log(' Correct session found:', currentUser.id.substring(0, 8) + '...');
      await pullFromServer();
      updateSyncUI('synced', 'Synced');
    } else {
      // No session - sign in
      await signInWithTestAccount();
    }
    
    // Listen for auth changes
    supabaseClient.auth.onAuthStateChange((event, session) => {
      if (session) {
        currentUser = session.user;
        console.log(' Auth state changed:', event);
      }
    });
    
    return true;
  } catch (error) {
    console.error(' Supabase init error:', error);
    updateSyncUI('error', 'Error');
    return false;
  }
}

// Sign in with test account (permanent user)
async function signInWithTestAccount() {
  try {
    updateSyncUI('syncing', 'Connecting...');
    toast(' Logging in...', 'info');
    
    const { data, error } = await supabaseClient.auth.signInWithPassword({
      email: 'test2@syntrise.com',
      password: '12345'
    });
    
    if (error) {
      toast(' Login error: ' + error.message, 'error');
      throw error;
    }
    
    currentUser = data.user;
    toast(' Logged in: ' + currentUser.id.substring(0, 8) + '...', 'success');
    console.log(' Signed in as:', currentUser.email, currentUser.id.substring(0, 8) + '...');
    
    // Check if first time - migrate local data
    const migrated = localStorage.getItem('droplit_migrated_' + currentUser.id);
    if (!migrated && ideas.length > 0) {
      await migrateLocalData();
    } else {
      // Sync from server
      await pullFromServer();
    }
    
    updateSyncUI('synced', 'Synced');
    return true;
  } catch (error) {
    console.error(' Sign in error:', error);
    toast(' Auth failed: ' + error.message, 'error');
    updateSyncUI('error', 'Auth error');
    return false;
  }
}

// Legacy anonymous sign in (backup)
async function signInAnonymously() {
  try {
    updateSyncUI('syncing', 'Connecting...');
    
    const { data, error } = await supabaseClient.auth.signInAnonymously();
    
    if (error) throw error;
    
    currentUser = data.user;
    console.log(' Signed in anonymously:', currentUser.id.substring(0, 8) + '...');
    
    // Check if first time - migrate local data
    const migrated = localStorage.getItem('droplit_migrated_' + currentUser.id);
    if (!migrated && ideas.length > 0) {
      await migrateLocalData();
    } else {
      // Sync from server
      await pullFromServer();
    }
    
    updateSyncUI('synced', 'Synced');
    return true;
  } catch (error) {
    console.error(' Anonymous sign in error:', error);
    updateSyncUI('error', 'Auth error');
    return false;
  }
}

// Migrate local data to Supabase
async function migrateLocalData() {
  if (!currentUser || ideas.length === 0) return;
  
  updateSyncUI('syncing', 'Migrating...');
  console.log(` Migrating ${ideas.length} drops to Supabase...`);
  
  try {
    // Filter only text drops (skip media for MVP)
    const textDrops = ideas.filter(i => !i.isMedia && !i.image && !i.audioData);
    
    const dropsToInsert = textDrops.map(idea => ({
      user_id: currentUser.id,
      external_id: String(idea.id),
      content: idea.text || '',
      category: idea.category || 'inbox',
      tags: idea.tags || [],
      markers: idea.markers || [],
      source: 'droplit',
      language: 'ru',
      is_media: false,
      has_local_media: !!(idea.image || idea.audioData),
      is_merged: idea.isMerged || false,
      ai_generated: idea.aiGenerated || false,
      transcription: idea.transcription || null,
      original_text: idea.originalText || null,
      notes: idea.notes || null,
      local_id: String(idea.id),
      device_id: DEVICE_ID,
      metadata: {
        date: idea.date,
        time: idea.time,
        timestamp: idea.timestamp
      }
    }));
    
    if (dropsToInsert.length > 0) {
      // Insert in batches of 50
      for (let i = 0; i < dropsToInsert.length; i += 50) {
        const batch = dropsToInsert.slice(i, i + 50);
        const { error } = await supabaseClient
          .from('drops')
          .upsert(batch, { onConflict: 'external_id', ignoreDuplicates: false });
        
        if (error) {
          console.error('Migration batch error:', error);
        }
      }
    }
    
    // Log migration
    await supabaseClient.from('sync_log').insert({
      user_id: currentUser.id,
      action: 'migrate',
      device_id: DEVICE_ID,
      details: { count: dropsToInsert.length, total_local: ideas.length }
    });
    
    localStorage.setItem('droplit_migrated_' + currentUser.id, 'true');
    console.log(` Migrated ${dropsToInsert.length} text drops`);
    
    updateSyncUI('synced', 'Migrated!');
    toast(`Synced ${dropsToInsert.length} drops to cloud!`, 'success');
    
  } catch (error) {
    console.error(' Migration error:', error);
    updateSyncUI('error', 'Migration failed');
  }
}

// Pull drops from server
async function pullFromServer() {
  if (!currentUser) return;
  
  try {
    const { data, error } = await supabaseClient
      .from('drops')
      .select('*')
      .eq('user_id', currentUser.id)
      .is('deleted_at', null)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    
    if (data && data.length > 0) {
      console.log(` Pulled ${data.length} drops from server`);
      // Merge with local (server wins for now)
      // TODO: proper conflict resolution
    }
    
    lastSyncTime = new Date();
    
  } catch (error) {
    console.error(' Pull error:', error);
  }
}

// Sync single drop to server (create/update)
async function syncDropToServer(idea, action = 'create') {
  if (!syncEnabled || !currentUser || !supabaseClient) {
    console.log(' Sync disabled or not connected');
    return false;
  }
  
  // Skip media drops for MVP
  if (idea.isMedia || idea.image || idea.audioData) {
    console.log(' Skipping media drop sync (MVP)');
    return true;
  }
  
  try {
    updateSyncUI('syncing', 'Saving...');
    
    const dropData = {
      user_id: currentUser.id,
      external_id: String(idea.id),
      content: idea.text || '',
      category: idea.category || 'inbox',
      tags: idea.tags || [],
      markers: idea.markers || [],
      source: 'droplit',
      language: 'ru',
      is_media: !!(idea.isMedia || idea.image || idea.audioData),
      has_local_media: !!(idea.image || idea.audioData),
      is_merged: idea.isMerged || false,
      ai_generated: idea.aiGenerated || false,
      transcription: idea.transcription || null,
      original_text: idea.originalText || null,
      notes: idea.notes || null,
      local_id: String(idea.id),
      device_id: DEVICE_ID,
      metadata: {
        date: idea.date,
        time: idea.time,
        timestamp: idea.timestamp
      }
    };
    
    console.log(' Syncing drop:', dropData.external_id);
    
    const { error, data } = await supabaseClient
      .from('drops')
      .upsert(dropData, { 
        onConflict: 'external_id',
        ignoreDuplicates: false 
      })
      .select();
    
    if (error) {
      console.error('Supabase error:', error);
      throw error;
    }
    
    console.log(` Synced drop ${String(idea.id).substring(0, 8)}... (${action})`);
    updateSyncUI('synced', 'Synced');
    lastSyncTime = new Date();
    
    return true;
  } catch (error) {
    console.error(' Sync error:', error);
    updateSyncUI('error', 'Sync failed');
    return false;
  }
}

// Delete drop from server (soft delete)
async function deleteDropFromServer(ideaId) {
  if (!syncEnabled || !currentUser || !supabaseClient) return false;
  
  try {
    updateSyncUI('syncing', 'Deleting...');
    
    const { error } = await supabaseClient
      .from('drops')
      .delete()
      .eq('external_id', String(ideaId))
      .eq('user_id', currentUser.id);
    
    if (error) throw error;
    
    console.log(` Deleted drop ${String(ideaId).substring(0, 8)}...`);
    updateSyncUI('synced', 'Synced');
    
    return true;
  } catch (error) {
    console.error(' Delete sync error:', error);
    updateSyncUI('error', 'Delete failed');
    return false;
  }
}

// Manual sync button
async function manualSync() {
  if (isSyncing) return;
  
  if (!currentUser) {
    toast('Not connected to cloud', 'warning');
    initSupabase();
    return;
  }
  
  isSyncing = true;
  toast('Syncing...', 'info');
  
  try {
    // Sync all local text drops
    const textDrops = ideas.filter(i => !i.isMedia && !i.image && !i.audioData);
    let synced = 0;
    
    for (const idea of textDrops) {
      const success = await syncDropToServer(idea, 'sync');
      if (success) synced++;
    }
    
    lastSyncTime = new Date();
    updateLastSyncInfo();
    toast(`Synced ${synced} drops to cloud`, 'success');
    
  } catch (error) {
    console.error(' Manual sync error:', error);
    toast('Sync failed: ' + error.message, 'error');
  }
  
  isSyncing = false;
}

// Update last sync info in menu
function updateLastSyncInfo() {
  const el = document.getElementById('lastSyncInfo');
  if (!el) return;
  
  if (lastSyncTime) {
    el.textContent = 'Last sync: ' + lastSyncTime.toLocaleTimeString();
  } else {
    el.textContent = 'Last sync: ';
  }
}

// Legacy function - now uses Supabase
function updateSyncUI(status, text) {
  // Update lastSyncInfo if synced
  if (status === 'synced') {
    lastSyncTime = new Date();
    updateLastSyncInfo();
  }
}

// Initialize on load
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(initSupabase, 500); // Delay to ensure SDK loaded
});

let curCat='all',curTime='all',sortAsc=true,isRec=false,recognition=null,saved=false;
let sendId=null,delId=null,catChangeId=null,editId=null,activeCardId=null;
let selectMode=false,selectedIds=[];
let lastScrollTop=0,longPressTimer=null;

// AI Configuration
const AI_API_URL = '/api/ai';
const STREAMING_ENABLED = true;
let aiProcessing = false;
let showArchived = false;

const CATS={
  tasks:{name:'TASKS',single:'TASK',kw:['task','tasks','todo','','','','',''],isMedia:false},
  ideas:{name:'IDEAS',single:'IDEA',kw:['idea','ideas','','','',''],isMedia:false},
  handmagic:{name:'HANDMAGIC',single:'HANDMAGIC',kw:['handmagic','','',' '],isMedia:false},
  design:{name:'DESIGN',single:'DESIGN',kw:['design','','ui','ux','','',''],isMedia:false},
  bugs:{name:'BUGS',single:'BUG',kw:['bug','bugs','fix','','','','',''],isMedia:false},
  questions:{name:'QUESTIONS',single:'QUESTION',kw:['question','questions','','','','claude',''],isMedia:false},
  link:{name:'LINKS',single:'LINK',kw:['link','url','http','https','www',''],isMedia:false},
  sketch:{name:'SKETCHES',single:'SKETCH',kw:[],isMedia:true},
  scan:{name:'SCANS',single:'SCAN',kw:[],isMedia:true},
  photo:{name:'PHOTOS',single:'PHOTO',kw:[],isMedia:true},
  audio:{name:'AUDIO',single:'AUDIO',kw:[],isMedia:true,isAudio:true},
  inbox:{name:'INBOX',single:'INBOX',kw:[],isMedia:false}
};
const MEDIA_CATS=['photo','sketch','scan','audio'];

// Markers system (scalable for future)
const MARKERS={
  heart:'',
  star:'',
  fire:'',
  done:'',
  trash:'',
  think:''
};
// Currently enabled markers (MVP = only heart)
const ENABLED_MARKERS=['heart'];

// ============================================
// ID GENERATOR (v0.9.58)
// Base62: 16 random characters, no timestamp
// ============================================
const BASE62_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
function generateId(length = 16) {
  const randomBytes = new Uint8Array(length);
  crypto.getRandomValues(randomBytes);
  return Array.from(randomBytes, byte => BASE62_CHARS[byte % 62]).join('');
}

// ============================================
// DROP SOUND (v0.9.58)
// Signature sound when creating a drop
// ============================================
let dropSoundCtx = null;
function playDropSound() {
  try {
    if (!dropSoundCtx) dropSoundCtx = new (window.AudioContext || window.webkitAudioContext)();
    const ctx = dropSoundCtx;
    if (ctx.state === 'suspended') ctx.resume();
    
    // Create a pleasant "drop" sound
    const osc1 = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.frequency.setValueAtTime(880, ctx.currentTime); // A5
    osc1.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.15); // A4
    osc2.frequency.setValueAtTime(1320, ctx.currentTime); // E6
    osc2.frequency.exponentialRampToValueAtTime(660, ctx.currentTime + 0.15); // E5
    
    gain.gain.setValueAtTime(0.3, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
    
    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(ctx.destination);
    
    osc1.start(ctx.currentTime);
    osc2.start(ctx.currentTime);
    osc1.stop(ctx.currentTime + 0.2);
    osc2.stop(ctx.currentTime + 0.2);
  } catch(e) {
    console.log('Sound not available');
  }
}

// ============================================
// TTS - TEXT TO SPEECH (v0.9.58)
// Read drop content aloud
// ============================================
let currentTTSUtterance = null;
let isTTSPlaying = false;

let activeSpeakBtn = null;

function speakAskAIMessage(btn) {
  // If this button is already playing - stop it
  if (btn === activeSpeakBtn) {
    stopTTS();
    btn.classList.remove('speaking');
    activeSpeakBtn = null;
    return;
  }
  
  // Stop any other playback
  stopTTS();
  if (activeSpeakBtn) {
    activeSpeakBtn.classList.remove('speaking');
  }
  
  const msgDiv = btn.closest('.ask-ai-message');
  const bubble = msgDiv?.querySelector('.ask-ai-bubble');
  if (!bubble) return;
  
  const text = bubble.textContent || bubble.innerText;
  if (!text) return;
  
  // Mark button as active
  btn.classList.add('speaking');
  activeSpeakBtn = btn;
  
  speakTextWithCallback(text, function() {
    btn.classList.remove('speaking');
    activeSpeakBtn = null;
  });
}

function speakTextWithCallback(text, onEnd) {
  if (!text) return;
  
  stopTTS();
  
  const provider = localStorage.getItem('tts_provider') || 'browser';
  const apiKey = localStorage.getItem('openai_tts_key');
  const voice = localStorage.getItem('aski_voice') || 'nova';
  
  if (provider === 'openai' && apiKey && apiKey.startsWith('sk-')) {
    speakWithOpenAICallback(text, apiKey, voice, onEnd);
  } else {
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'ru-RU';
      utterance.onend = function() {
        if (onEnd) onEnd();
        unlockVoiceMode();
      };
      window.speechSynthesis.speak(utterance);
    }
  }
}

async function speakWithOpenAICallback(text, apiKey, voice, onEnd) {
  try {
    const response = await fetch('https://api.openai.com/v1/audio/speech', {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer ' + apiKey,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'tts-1',
        input: text,
        voice: voice
      })
    });
    
    if (!response.ok) throw new Error('OpenAI TTS error');
    
    const blob = await response.blob();
    const url = URL.createObjectURL(blob);
    currentTTSAudio = new Audio(url);
    
    currentTTSAudio.onended = function() {
      URL.revokeObjectURL(url);
      currentTTSAudio = null;
      if (onEnd) onEnd();
      unlockVoiceMode();
    };
    
    currentTTSAudio.play();
  } catch (e) {
    console.error('OpenAI TTS error:', e);
    if (onEnd) onEnd();
    unlockVoiceMode();
  }
}

let currentTTSAudio = null;

function speakText(text) {
  if (!text) return;
  
  stopTTS();
  updateChatControlLeft('stop');
  
  const provider = localStorage.getItem('tts_provider') || 'browser';
  const openaiKey = localStorage.getItem('openai_tts_key');
  const openaiVoice = localStorage.getItem('aski_voice') || 'nova';
  const elevenlabsKey = localStorage.getItem('elevenlabs_tts_key');
  const elevenlabsVoice = localStorage.getItem('elevenlabs_voice_id') || 'EXAVITQu4vr4xnSDxMaL';
  
  if (provider === 'openai' && openaiKey && openaiKey.startsWith('sk-')) {
    speakWithOpenAI(text, openaiKey, openaiVoice);
  } else if (provider === 'elevenlabs' && elevenlabsKey) {
    speakWithElevenLabs(text, elevenlabsKey, elevenlabsVoice);
  } else {
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'ru-RU';
      utterance.onend = function() { unlockVoiceMode(); };
      window.speechSynthesis.speak(utterance);
    }
  }
}

async function speakWithElevenLabs(text, apiKey, voiceId) {
  try {
    const response = await fetch('https://api.elevenlabs.io/v1/text-to-speech/' + voiceId, {
      method: 'POST',
      headers: {
        'xi-api-key': apiKey,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: text,
        model_id: 'eleven_multilingual_v2'
      })
    });
    
    if (!response.ok) throw new Error('ElevenLabs TTS error');
    
    const blob = await response.blob();
    const url = URL.createObjectURL(blob);
    currentTTSAudio = new Audio(url);
    
    currentTTSAudio.onended = function() {
      URL.revokeObjectURL(url);
      currentTTSAudio = null;
      unlockVoiceMode();
    };
    
    currentTTSAudio.play();
  } catch (e) {
    console.error('ElevenLabs TTS error:', e);
    unlockVoiceMode();
  }
}

async function speakWithOpenAI(text, apiKey, voice) {
  try {
    const response = await fetch('https://api.openai.com/v1/audio/speech', {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer ' + apiKey,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'tts-1',
        input: text,
        voice: voice
      })
    });
    
    if (!response.ok) throw new Error('OpenAI TTS error');
    
    const blob = await response.blob();
    const url = URL.createObjectURL(blob);
    currentTTSAudio = new Audio(url);
    
    currentTTSAudio.onended = function() {
      URL.revokeObjectURL(url);
      currentTTSAudio = null;
      unlockVoiceMode();
    };
    
    currentTTSAudio.play();
  } catch (e) {
    console.error('OpenAI TTS error:', e);
    unlockVoiceMode();
  }
}

function stopTTS() {
  if (currentTTSAudio) {
    currentTTSAudio.pause();
    currentTTSAudio = null;
  }
  if ('speechSynthesis' in window) {
    window.speechSynthesis.cancel();
  }
  updateChatControlLeft('hide');
}

function speakDrop(id, e) {
  if (e) e.stopPropagation();
  
  const item = ideas.find(x => x.id === id);
  if (!item) return;
  
  // Get text to speak
  let textToSpeak = '';
  if (item.category === 'audio' && item.transcription) {
    textToSpeak = item.transcription;
  } else if (item.text) {
    textToSpeak = item.text;
  } else if (item.notes) {
    textToSpeak = item.notes;
  }
  
  if (!textToSpeak) {
    toast('Nothing to read', 'warning');
    return;
  }
  
  // Stop if already playing
  if (isTTSPlaying || currentTTSAudio) {
    stopTTS();
    speechSynthesis.cancel();
    isTTSPlaying = false;
    updateTTSButton(id, false);
    toast('Stopped', 'info');
    return;
  }
  
  // Use settings-based TTS
  isTTSPlaying = true;
  updateTTSButton(id, true);
  
  speakTextWithCallback(textToSpeak, function() {
    isTTSPlaying = false;
    updateTTSButton(id, false);
  });
  
  toast('Reading...', 'info');
}

function updateTTSButton(id, isPlaying) {
  const btn = document.querySelector(`.card[data-id="${id}"] .act-tts`);
  if (btn) {
    btn.innerHTML = isPlaying ? 'Stop' : 'Read';
    btn.classList.toggle('playing', isPlaying);
  }
}

function stopAllTTS() {
  speechSynthesis.cancel();
  isTTSPlaying = false;
}

function parseD(s){
  if(!s||typeof s!=='string')return new Date(0);
  const parts=s.split('.');
  if(parts.length!==3)return new Date(0);
  const[d,m,y]=parts.map(Number);
  return new Date(y,m-1,d);
}
function inDays(s,n){
  if(!s)return false;
  try{return(new Date()-parseD(s))/(864e5)<=n;}catch(e){return false;}
}
function isToday(s){
  if(!s)return false;
  return s===new Date().toLocaleDateString('ru-RU');
}

const ideasWrap=document.getElementById('ideasWrap');
const scrollTopBtn=document.getElementById('scrollTop');
const scrollBottomBtn=document.getElementById('scrollBottom');
let scrollTimeout=null;

ideasWrap.addEventListener('scroll',()=>{
  const st=ideasWrap.scrollTop;
  const maxScroll=ideasWrap.scrollHeight-ideasWrap.clientHeight;
  const dir=st>lastScrollTop?1:-1;
  lastScrollTop=st;
  clearTimeout(scrollTimeout);
  scrollTopBtn.classList.remove('show');
  scrollBottomBtn.classList.remove('show');
  if(maxScroll>300){
    if(dir<0 && st>200) scrollTopBtn.classList.add('show');
    else if(dir>0 && st<maxScroll-200) scrollBottomBtn.classList.add('show');
  }
  scrollTimeout=setTimeout(()=>{
    scrollTopBtn.classList.remove('show');
    scrollBottomBtn.classList.remove('show');
  },2000);
});

function scrollToTop(){ideasWrap.scrollTo({top:0,behavior:'smooth'});scrollTopBtn.classList.remove('show');}
function scrollToBottom(){ideasWrap.scrollTo({top:ideasWrap.scrollHeight,behavior:'smooth'});scrollBottomBtn.classList.remove('show');}
function scrollToBottomInstant(){ideasWrap.scrollTo({top:ideasWrap.scrollHeight,behavior:'instant'});}
function toggleSort(){sortAsc=!sortAsc;document.getElementById('sortBtn').innerHTML=sortAsc?'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M18 15l-6-6-6 6"/></svg>':'<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l6 6 6-6"/></svg>';document.getElementById('sortBtn').classList.toggle('desc',!sortAsc);render();}

// Selection mode
function enterSelectMode(id){
  selectMode=true;
  selectedIds=[id];
  activeCardId=null;
  document.body.classList.add('select-mode');
  document.getElementById('fabRecord').style.display='none';
  document.getElementById('fabCamera').style.display='none';
  updateSelectBar();
  render();
}

function cancelSelect(){
  selectMode=false;
  selectedIds=[];
  document.body.classList.remove('select-mode');
  document.getElementById('selectBar').classList.remove('show');
  document.getElementById('fabRecord').style.display='flex';
  document.getElementById('fabCamera').style.display='flex';
  render();
}

function deleteSelected(){
  if(selectedIds.length===0)return;
  const count=selectedIds.length;
  if(confirm('Delete '+count+' selected items?')){
    ideas=ideas.filter(i=>!selectedIds.includes(i.id));
    save();
    cancelSelect();
    render();counts();
    toast(count+' items deleted','info');
  }
}

function toggleSelect(id){
  if(selectedIds.includes(id)){
    selectedIds=selectedIds.filter(x=>x!==id);
    if(selectedIds.length===0) cancelSelect();
  } else {
    selectedIds.push(id);
  }
  updateSelectBar();
  render();
}

function updateSelectBar(){
  document.getElementById('selectCount').textContent=selectedIds.length;
  document.getElementById('selectBar').classList.toggle('show',selectMode&&selectedIds.length>0);
}

function getMergedText(simple=false){
  const selected=ideas.filter(i=>selectedIds.includes(i.id));
  // Sort by timestamp
  selected.sort((a,b)=>new Date(a.timestamp)-new Date(b.timestamp));
  
  if(simple){
    // Simple merge - just text, double newline between
    return selected.map(i=>{
      if(i.isMedia){
        return i.notes||'[Photo '+i.date+' '+i.time+']';
      }
      return i.text;
    }).join('\n\n');
  }
  
  // List merge with headers
  return selected.map(i=>{
    const cat=CATS[i.category]?.name||'INBOX';
    if(i.isMedia){
      const content=i.notes||'[Photo '+i.date+' '+i.time+']';
      return `- [${cat}] ${content}`;
    }
    return `- [${cat}] ${i.text}`;
  }).join('\n');
}

function updateMergePreview(){
  const simple=document.getElementById('mergeSimple').checked;
  document.getElementById('mergePreview').textContent=getMergedText(simple);
}

function showMergePreview(){
  if(selectedIds.length<2){toast('Select at least 2 cards','warning');return;}
  // Check if any selected item is media
  const hasMedia=selectedIds.some(id=>{
    const item=ideas.find(x=>x.id===id);
    return item&&item.isMedia;
  });
  if(hasMedia){toast('Cannot merge media items','warning');return;}
  
  // Get current checkbox state and update preview accordingly
  const simple=document.getElementById('mergeSimple').checked;
  const mergedText = getMergedText(simple);
  document.getElementById('mergePreview').textContent=mergedText;
  
  // Warning for large merge
  const charCount = mergedText.length;
  if (charCount > 10000) {
    toast(`Large merge: ${Math.round(charCount/1000)}K chars`, 'warning');
  }
  
  document.getElementById('mergeModal').classList.add('show');
}

function closeMergeModal(){document.getElementById('mergeModal').classList.remove('show');}

function copyMerged(){
  const simple=document.getElementById('mergeSimple').checked;
  navigator.clipboard.writeText(getMergedText(simple));
  toast('Copied to clipboard!','success');
  closeMergeModal();
}

function saveMerged(){
  const simple=document.getElementById('mergeSimple').checked;
  const text=getMergedText(simple);
  
  // Check size limit
  const MAX_DROP_SIZE = 50000; // 50KB
  if (text.length > MAX_DROP_SIZE) {
    toast(`Too large! Max: ${MAX_DROP_SIZE/1000}K chars`, 'error');
    return;
  }
  
  const mergedId = Date.now();
  const idea={id:mergedId,text:text,category:'inbox',timestamp:new Date().toISOString(),date:new Date().toLocaleDateString('ru-RU'),time:new Date().toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'}),isMerged:true};
  ideas.push(idea);
  
  // Save undo
  saveUndo('merge', { mergedId: mergedId, count: selectedIds.length });
  
  save();
  playDropSound(); // Play signature sound
  closeMergeModal();
  cancelSelect();
  resetToShowAll();
  toast('Merged & saved!','success');
}

// Card interactions
function handleCardClick(id,e){
  // Ignore clicks on category badge, action buttons, textarea, checkbox, markers
  if(e.target.closest('.card-cat')||e.target.closest('.act')||e.target.closest('.card-ta')||e.target.closest('.card-checkbox')||e.target.closest('.card-markers'))return;
  
  // Ignore clicks on audio player buttons only
  if(e.target.closest('.audio-btn'))return;
  
  const item=ideas.find(x=>x.id===id);
  
  if(selectMode){
    // In select mode - always toggle selection
    toggleSelect(id);
  } else if(editId && editId !== id) {
    // If editing another card, don't activate this one
    return;
  } else if(item && item.isMedia && item.category !== 'audio') {
    // For image/photo cards - open viewer directly (NOT for audio)
    viewImage(id,e);
  } else {
    // For text cards AND audio cards - toggle expand/collapse
    const prevId = activeCardId;
    activeCardId = activeCardId===id ? null : id;
    
    // Remove active from previous card
    if(prevId) {
      const prevCard = document.querySelector('.card[data-id="'+prevId+'"]');
      if(prevCard) prevCard.classList.remove('active');
    }
    
    // Add active to new card (or none if deactivating)
    if(activeCardId) {
      const newCard = document.querySelector('.card[data-id="'+activeCardId+'"]');
      if(newCard) newCard.classList.add('active');
    }
  }
}

function toggleMarker(id,marker,e){
  if(e){e.stopPropagation();}
  const item=ideas.find(x=>x.id===id);
  if(!item)return;
  
  // Initialize markers array if needed
  if(!item.markers)item.markers=[];
  
  // Toggle marker (silent - no toast per B3 fix)
  const idx=item.markers.indexOf(marker);
  if(idx===-1){
    item.markers.push(marker);
  } else {
    item.markers.splice(idx,1);
  }
  
  save();
  render();
  
  // Update photo markers button if in image viewer
  if(currentImageId === id) {
    updatePhotoMarkersButton();
  }
}

function handleCardLongPress(id){
  if(!selectMode){
    enterSelectMode(id);
    if(navigator.vibrate)navigator.vibrate(50);
  }
}

let touchStartX=0,touchStartY=0;

function cardTouchStart(id,e){
  if(selectMode||editId)return;
  const touch=e.touches[0];
  touchStartX=touch.clientX;
  touchStartY=touch.clientY;
  longPressTimer=setTimeout(()=>handleCardLongPress(id),800);
}

function cardTouchMove(e){
  if(!longPressTimer)return;
  const touch=e.touches[0];
  const dx=Math.abs(touch.clientX-touchStartX);
  const dy=Math.abs(touch.clientY-touchStartY);
  // Cancel if moved more than 10px (scrolling)
  if(dx>10||dy>10){
    clearTimeout(longPressTimer);
    longPressTimer=null;
  }
}

function cardTouchEnd(){
  clearTimeout(longPressTimer);
  longPressTimer=null;
}

document.addEventListener('click',(e)=>{
  if(activeCardId&&!e.target.closest('.card')&&!e.target.closest('.overlay')&&!e.target.closest('.fab-record')&&!e.target.closest('.select-bar')){
    const prevCard = document.querySelector('.card[data-id="'+activeCardId+'"]');
    if(prevCard) prevCard.classList.remove('active');
    activeCardId=null;
  }
});

function initSR(){
  const SR=window.SpeechRecognition||window.webkitSpeechRecognition;
  if(!SR){document.getElementById('warning').style.display='block';document.getElementById('fabRecord').style.opacity='0.5';return false;}
  recognition=new SR();
  recognition.lang='ru-RU';
  recognition.continuous=false;
  recognition.interimResults=true;
  recognition.maxAlternatives=1;
  recognition.onstart=async()=>{isRec=true;saved=false;updateRecUI(true);await acquireWakeLock();};
  recognition.onresult=(e)=>{
    let f='',i='';
    for(let x=0;x<e.results.length;x++){if(e.results[x].isFinal)f+=e.results[x][0].transcript;else i+=e.results[x][0].transcript;}
    document.getElementById('recText').textContent=(f||i)||'Listening...';
    if(f&&!saved){saved=true;saveIdea(f.trim());}
  };
  recognition.onerror=(e)=>{
    if(e.error==='no-speech')toast('No speech detected','warning');
    else if(e.error==='not-allowed')toast('Microphone access denied','error');
    isRec=false;updateRecUI(false);releaseWakeLock();
  };
  recognition.onend=()=>{isRec=false;updateRecUI(false);releaseWakeLock();};
  return true;
}

// B4 FIX: Wake Lock to prevent screen from turning off during recording
let wakeLock = null;
async function acquireWakeLock() {
  if ('wakeLock' in navigator) {
    try { 
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock acquired');
      // Re-acquire if released (e.g., when tab becomes visible again)
      wakeLock.addEventListener('release', () => {
        console.log('Wake Lock released');
        wakeLock = null;
      });
    } 
    catch (err) { console.log('Wake Lock error:', err); }
  }
}
function releaseWakeLock() {
  if (wakeLock) { 
    wakeLock.release(); 
    wakeLock = null; 
    console.log('Wake Lock released manually');
  }
}

// ===== FAB DOUBLE-TAP & LONG-PRESS =====
let fabLastTap = 0;
let fabLongPressTimer = null;

function handleFabClick(event) {
  const now = Date.now();
  const timeDiff = now - fabLastTap;
  fabLastTap = now;
  
  // Double-tap detection (within 300ms)
  if (timeDiff < 300 && timeDiff > 0) {
    event.preventDefault();
    openAudioRecorder();
    return;
  }
  
  // Single tap - normal voice recognition
  toggleRec();
}

function fabTouchStart() {
  // Long press detection (500ms)
  fabLongPressTimer = setTimeout(() => {
    openAudioRecorder();
    fabLongPressTimer = null;
  }, 500);
}

function fabTouchEnd() {
  if (fabLongPressTimer) {
    clearTimeout(fabLongPressTimer);
    fabLongPressTimer = null;
  }
}

function toggleRec(){if(isRec)recognition.stop();else{saved=false;recognition.start();}}
function updateRecUI(on){
  const fab=document.getElementById('fabRecord'),status=document.getElementById('recStatus');
  if(on){fab.classList.add('recording');status.classList.add('show');document.getElementById('recText').textContent='Listening...';}
  else{fab.classList.remove('recording');status.classList.remove('show');}
}
function detectCat(t){
  const l=t.toLowerCase();
  for(const[k,v]of Object.entries(CATS)){
    if(k==='inbox'||!v.kw||v.kw.length===0)continue;
    for(const w of v.kw){
      // Check: starts with word, contains word with spaces, or ends with word
      if(l.startsWith(w+' ')||l.startsWith(w+',')||l.startsWith(w+'.')||
         l.includes(' '+w+' ')||l.includes(' '+w+',')||l.includes(' '+w+'.')||
         l.endsWith(' '+w)||l===w)return k;
    }
  }
  return'inbox';
}
function saveIdea(t){
  // ============================================
  // SLASH COMMANDS (v0.9.58)
  // ============================================
  if (t.startsWith('/')) {
    const cmd = t.toLowerCase().trim();
    
    if (cmd === '/fix') {
      // Fix string IDs
      let fixed = 0;
      ideas = ideas.map((item, index) => {
        if (typeof item.id === 'string') {
          item.id = Date.now() + index;
          fixed++;
        }
        return item;
      });
      if (fixed > 0) {
        localStorage.setItem('droplit_ideas', JSON.stringify(ideas));
        toast(` Fixed ${fixed} drop(s)!`, 'success');
        render();
      } else {
        toast('All IDs are OK!', 'info');
      }
      return;
    }
    
    if (cmd === '/debug') {
      // Show debug info
      const total = ideas.length;
      const stringIds = ideas.filter(i => typeof i.id === 'string').length;
      const merged = ideas.filter(i => i.isMerged).length;
      const audio = ideas.filter(i => i.category === 'audio').length;
      const userId = currentUser ? currentUser.id.substring(0, 8) + '...' : 'Not logged in';
      const deviceId = DEVICE_ID || 'Not set';
      const syncStatus = syncEnabled ? 'Enabled' : 'Disabled';
      alert(`DropLit Debug v0.9.58\n\n=== DROPS ===\nTotal: ${total}\nString IDs: ${stringIds}\nMerged: ${merged}\nAudio: ${audio}\n\n=== SYNC ===\nUser ID: ${userId}\nDevice ID: ${deviceId}\nSync: ${syncStatus}\n\n=== STORAGE ===\nLocalStorage: ${(localStorage.getItem('droplit_ideas')?.length / 1024).toFixed(1)} KB`);
      return;
    }
    
    if (cmd === '/clear') {
      if (confirm(' Delete ALL drops? This cannot be undone!')) {
        ideas = [];
        localStorage.removeItem('droplit_ideas');
        toast('All drops deleted', 'warning');
        render();
        counts();
      }
      return;
    }
    
    if (cmd === '/help') {
      alert('DropLit Commands:\n\n/fix - Repair broken IDs\n/debug - Show stats\n/clear - Delete all drops\n/help - This message');
      return;
    }
  }
  
  const c=detectCat(t);
  const idea={id:Date.now(),text:t,category:c,timestamp:new Date().toISOString(),date:new Date().toLocaleDateString('ru-RU'),time:new Date().toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'}),isMedia:false};
  ideas.push(idea);save(idea);
  playDropSound(); // Play signature sound
  resetToShowAll();
  toast('Saved to '+CATS[c].name,'success');
}

function resetToShowAll(){
  try{
    // Reset filter variables
    curCat='all';
    curTime='7days';
    activeCardId=null;
    sortAsc=true;
    // Update sort button UI
    const sortBtn=document.getElementById('sortBtn');
    if(sortBtn){
      sortBtn.innerHTML='<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M18 15l-6-6-6 6"/></svg>';
      sortBtn.classList.remove('desc');
    }
    // Remove active class from category buttons
    document.querySelectorAll('.cat').forEach(x=>x.classList.remove('active'));
    // Update time buttons - activate 7d
    document.querySelectorAll('.time-btn').forEach(x=>x.classList.remove('active'));
    const btn7d=document.querySelector('.time-btn[data-time="7days"]');
    if(btn7d)btn7d.classList.add('active');
    // Render and scroll (instant, no animation)
    render();
    counts();
    setTimeout(()=>{
      const wrap=document.getElementById('ideasWrap');
      if(wrap)wrap.scrollTo({top:wrap.scrollHeight,behavior:'auto'});
    },50);
  }catch(err){
    console.error('resetToShowAll error:',err);
  }
}

function handlePhoto(e){
  const file=e.target.files[0];
  if(!file)return;
  
  toast('Processing photo...','info');
  
  // Compress image before saving
  const img=new Image();
  img.onload=function(){
    const canvas=document.createElement('canvas');
    const maxSize=1200; // Max dimension
    let w=img.width,h=img.height;
    
    if(w>maxSize||h>maxSize){
      if(w>h){h=Math.round(h*maxSize/w);w=maxSize;}
      else{w=Math.round(w*maxSize/h);h=maxSize;}
    }
    
    canvas.width=w;
    canvas.height=h;
    const ctx=canvas.getContext('2d');
    ctx.drawImage(img,0,0,w,h);
    
    // Compress to JPEG 70% quality
    const dataUrl=canvas.toDataURL('image/jpeg',0.7);
    savePhoto(dataUrl,null);
  };
  img.onerror=function(){
    toast('Failed to load photo','error');
  };
  
  const reader=new FileReader();
  reader.onload=function(ev){
    img.src=ev.target.result;
  };
  reader.onerror=function(){
    toast('Failed to read photo','error');
  };
  reader.readAsDataURL(file);
  e.target.value='';
}

function savePhoto(dataUrl,geo){
  const idea={
    id:Date.now(),
    text:'',
    notes:'',
    image:dataUrl,
    category:'photo',
    timestamp:new Date().toISOString(),
    date:new Date().toLocaleDateString('ru-RU'),
    time:new Date().toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'}),
    geo:geo,
    isMedia:true
  };
  ideas.push(idea);
  save();
  playDropSound(); // Play signature sound
  toast('Photo saved!','success');
  try{
    resetToShowAll();
  }catch(err){
    // Silent fail - photo is saved
  }
}

// ============================================
// ASK AI CHAT FUNCTIONS
// ============================================

let askAIMessages = [];
let lastUserMessage = ''; // For retry functionality
let askAIVoiceRecognition = null;

function openAskAI() {
  const panel = document.getElementById('askAIPanel');
  panel.classList.add('show');
  document.body.classList.add('chat-open');
  // No auto-focus - voice-first approach, keyboard won't popup
  
  // Keep screen on while chat is open (like TikTok)
  acquireWakeLock();
  
  // Update UI based on Voice Mode
  updateVoiceModeUI();
  
  // Update AutoDrop indicator
  updateAutoDropIndicator();
  
  // Show/hide bottom controls based on mode
  const controlsBottom = document.getElementById('askAIControlsBottom');
  const voiceLarge = document.getElementById('askAIVoiceLarge');
  
  if (isVoiceModeEnabled()) {
    // Voice mode - show new bottom controls
	panel.classList.add('voice-mode');
    if (controlsBottom) controlsBottom.style.display = 'flex';
    if (voiceLarge) voiceLarge.style.display = 'none';
    
    voiceModeLocked = false;
    voiceModeSleeping = true;
    askiIsProcessing = false;
    updateVoiceModeIndicator('sleeping');
    updateChatControlLeft('hide');
  } else {
    // Text mode - hide voice controls
    if (controlsBottom) controlsBottom.style.display = 'none';
    if (voiceLarge) voiceLarge.style.display = 'none';
	panel.classList.remove('voice-mode');
  }
}

function handleChatControlLeft() {
  // If ASKI is speaking - stop it
  if (askiIsSpeaking || currentTTSAudio) {
    askiStopSpeaking();
    stopTTS();
    updateChatControlLeft('hide');
    return;
  }
  // Otherwise - close chat
  closeAskAI();
}

function updateChatControlLeft(state) {
  const btn = document.getElementById('askAIControlLeft');
  if (!btn) return;
  
  if (state === 'stop') {
    btn.textContent = 'STOP';
    btn.classList.add('stop');
  } else {
    btn.textContent = 'HIDE';
    btn.classList.remove('stop');
  }
}

function closeAskAI() {
  const panel = document.getElementById('askAIPanel');
  panel.classList.remove('show', 'voice-mode-active', 'aski-busy');
  document.body.classList.remove('chat-open');
  
  // Stop everything and reset all voice states
  voiceModeLocked = true;
  voiceModeSleeping = false;
  
  clearVoiceModeTimeout();
  stopVoiceModeListening();
  askiStopSpeaking();
  stopTTS();
  updateVoiceModeIndicator('');
  
  // Allow screen to sleep when chat is closed
  releaseWakeLock();
}

// Update UI based on Voice Mode setting
function updateVoiceModeUI() {
  const panel = document.getElementById('askAIPanel');
  if (isVoiceModeEnabled()) {
    panel.classList.add('voice-mode-active');
  } else {
    panel.classList.remove('voice-mode-active');
  }
}

// Set Aski busy state (processing or speaking)
function setAskiBusy(busy) {
  const panel = document.getElementById('askAIPanel');
  if (busy) {
    panel.classList.add('aski-busy');
  } else {
    panel.classList.remove('aski-busy');
  }
}

// Stop Aski response (speaking or waiting for API)
function stopAskiResponse() {
  console.log('Stopping Aski response');
  askiStopSpeaking();
  askiIsProcessing = false;
  voiceModeLocked = false;
  setAskiBusy(false);
  
  // Go to sleep mode
  if (isVoiceModeEnabled()) {
    voiceModeSleeping = true;
    updateVoiceModeIndicator('sleeping');
  }
  toast('Stopped');
}

function setAskAIPrompt(text) {
  const input = document.getElementById('askAIInput');
  input.value = text;
  updateAskAICharCount();
  input.focus();
}

function updateAskAICharCount() {
  const input = document.getElementById('askAIInput');
  const count = input.value.length;
  const counter = document.getElementById('askAICharCount');
  counter.textContent = `${count} / 2000`;
  counter.classList.toggle('warning', count > 1800);
  document.getElementById('askAISendBtn').disabled = count === 0;
}

// Auto-resize textarea as user types
function autoResizeTextarea(textarea) {
  textarea.style.height = 'auto';
  const maxHeight = 120; // Max 5-6 lines
  textarea.style.height = Math.min(textarea.scrollHeight, maxHeight) + 'px';
}

// ============================================
// ASKI VOICE (Text-to-Speech) + VOICE MODE
// ============================================

let askiIsSpeaking = false;
let askiCurrentUtterance = null;
let askiVoice = localStorage.getItem('aski_voice') || 'nova'; // OpenAI TTS voice
let askiApiKey = localStorage.getItem('openai_tts_key') || '';

// TTS Provider settings
let ttsProvider = localStorage.getItem('tts_provider') || 'openai'; // openai, elevenlabs, browser
let elevenlabsApiKey = localStorage.getItem('elevenlabs_tts_key') || '';
let elevenlabsVoice = localStorage.getItem('elevenlabs_voice') || 'Nadia';
let elevenlabsVoiceId = localStorage.getItem('elevenlabs_voice_id') || 'gedzfqL7OGdPbwm0ynTP';

// ElevenLabs voices - Russian native speakers
const ELEVENLABS_VOICES = {
  // Russian voices (tested & working)
  'Nadia': 'gedzfqL7OGdPbwm0ynTP',      // Russian female - RECOMMENDED
  'Larisa': 'AB9XsbSA4eLG12t2myjN',     // Russian female
  'Dmitry': 'kwajW3Xh5svCeKU5ky2S',     // Russian male
  // Multilingual voices (English + Russian)
  'Bella': 'EXAVITQu4vr4xnSDxMaL',      // English/Russian female
  'Rachel': '21m00Tcm4TlvDq8ikWAM'      // English/Russian female
};

// Loaded voices from API (will be populated dynamically)
let elevenlabsLoadedVoices = [];

// Load voices from ElevenLabs API
async function loadElevenLabsVoices() {
  if (!elevenlabsApiKey) {
    toast('Enter ElevenLabs API key first');
    return;
  }
  
  toast('Loading voices...');
  
  try {
    const response = await fetch('https://api.elevenlabs.io/v1/voices', {
      method: 'GET',
      headers: {
        'xi-api-key': elevenlabsApiKey
      }
    });
    
    if (!response.ok) {
      toast('Failed to load voices');
      return;
    }
    
    const data = await response.json();
    elevenlabsLoadedVoices = data.voices || [];
    
    console.log('Loaded voices:', elevenlabsLoadedVoices.length);
    
    // Update voice selector with loaded voices
    updateElevenLabsVoiceSelector();
    
    toast(`Loaded ${elevenlabsLoadedVoices.length} voices`);
    
  } catch (error) {
    console.error('Error loading voices:', error);
    toast('Error loading voices');
  }
}

// Update ElevenLabs voice selector with loaded voices
function updateElevenLabsVoiceSelector() {
  const selector = document.getElementById('elevenlabsVoiceSelector');
  if (!selector) return;
  
  // If we have loaded voices, show them
  if (elevenlabsLoadedVoices.length > 0) {
    let html = '';
    
    // Group by category: default voices first, then others
    const defaultVoices = elevenlabsLoadedVoices.filter(v => v.category === 'premade' || v.category === 'default');
    const otherVoices = elevenlabsLoadedVoices.filter(v => v.category !== 'premade' && v.category !== 'default');
    
    // Show default voices
    defaultVoices.slice(0, 12).forEach(voice => {
      const isActive = elevenlabsVoiceId === voice.voice_id;
      html += `<button class="pill-m ${isActive ? 'active' : ''}" data-voice="${voice.name}" data-voiceid="${voice.voice_id}" onclick="selectElevenLabsVoice('${voice.name}', '${voice.voice_id}')">${voice.name}</button>`;
    });
    
    // Add separator if there are other voices
    if (otherVoices.length > 0) {
      html += `<div style="width: 100%; font-size: 0.7rem; color: var(--color-text-muted); margin: 8px 0 4px;">Library voices:</div>`;
      otherVoices.slice(0, 12).forEach(voice => {
        const isActive = elevenlabsVoiceId === voice.voice_id;
        html += `<button class="pill-m ${isActive ? 'active' : ''}" data-voice="${voice.name}" data-voiceid="${voice.voice_id}" onclick="selectElevenLabsVoice('${voice.name}', '${voice.voice_id}')">${voice.name}</button>`;
      });
    }
    
    selector.innerHTML = html;
  }
}

// Select ElevenLabs voice
function selectElevenLabsVoice(name, voiceId) {
  elevenlabsVoice = name;
  elevenlabsVoiceId = voiceId;
  localStorage.setItem('elevenlabs_voice', name);
  localStorage.setItem('elevenlabs_voice_id', voiceId);
  
  // Update UI - remove active from all, add to selected
  document.querySelectorAll('#elevenlabsVoiceSelector .pill-m').forEach(btn => {
    btn.classList.remove('active');
  });
  const selectedBtn = document.querySelector(`#elevenlabsVoiceSelector .pill-m[data-voiceid="${voiceId}"]`);
  if (selectedBtn) {
    selectedBtn.classList.add('active');
  }
  
  // Preview
  previewElevenLabsVoice(name);
}

// Remove emojis from text before speaking
function removeEmojis(text) {
  return text.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{231A}-\u{231B}]|[\u{23E9}-\u{23F3}]|[\u{23F8}-\u{23FA}]|[\u{25AA}-\u{25AB}]|[\u{25B6}]|[\u{25C0}]|[\u{25FB}-\u{25FE}]|[\u{2614}-\u{2615}]|[\u{2648}-\u{2653}]|[\u{267F}]|[\u{2693}]|[\u{26A1}]|[\u{26AA}-\u{26AB}]|[\u{26BD}-\u{26BE}]|[\u{26C4}-\u{26C5}]|[\u{26CE}]|[\u{26D4}]|[\u{26EA}]|[\u{26F2}-\u{26F3}]|[\u{26F5}]|[\u{26FA}]|[\u{26FD}]|[\u{2702}]|[\u{2705}]|[\u{2708}-\u{270D}]|[\u{270F}]|[\u{2712}]|[\u{2714}]|[\u{2716}]|[\u{271D}]|[\u{2721}]|[\u{2728}]|[\u{2733}-\u{2734}]|[\u{2744}]|[\u{2747}]|[\u{274C}]|[\u{274E}]|[\u{2753}-\u{2755}]|[\u{2757}]|[\u{2763}-\u{2764}]|[\u{2795}-\u{2797}]|[\u{27A1}]|[\u{27B0}]|[\u{27BF}]|[\u{2934}-\u{2935}]|[\u{2B05}-\u{2B07}]|[\u{2B1B}-\u{2B1C}]|[\u{2B50}]|[\u{2B55}]|[\u{3030}]|[\u{303D}]|[\u{3297}]|[\u{3299}]|[\u{1F004}]|[\u{1F0CF}]|[\u{1F170}-\u{1F171}]|[\u{1F17E}-\u{1F17F}]|[\u{1F18E}]|[\u{1F191}-\u{1F19A}]|[\u{1F201}-\u{1F202}]|[\u{1F21A}]|[\u{1F22F}]|[\u{1F232}-\u{1F23A}]|[\u{1F250}-\u{1F251}]||||||||||||||||||||/gu, '').trim();
}

// Detect language from text
function detectLanguage(text) {
  const japaneseRegex = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/;
  const chineseRegex = /[\u4E00-\u9FFF]/;
  const koreanRegex = /[\uAC00-\uD7AF\u1100-\u11FF]/;
  const cyrillicRegex = /[\u0400-\u04FF]/;
  const arabicRegex = /[\u0600-\u06FF]/;
  const hebrewRegex = /[\u0590-\u05FF]/;
  
  if (japaneseRegex.test(text) && !chineseRegex.test(text.replace(/[\u4E00-\u9FAF]/g, ''))) {
    return 'ja-JP';
  }
  if (chineseRegex.test(text)) return 'zh-CN';
  if (koreanRegex.test(text)) return 'ko-KR';
  if (cyrillicRegex.test(text)) return 'ru-RU';
  if (arabicRegex.test(text)) return 'ar-SA';
  if (hebrewRegex.test(text)) return 'he-IL';
  
  return 'en-US';
}

// Get best available voice for language and gender preference
function getVoiceForLang(lang) {
  const voices = speechSynthesis.getVoices();
  const langPrefix = lang.split('-')[0];
  
  // Filter voices by language
  let langVoices = voices.filter(v => v.lang === lang || v.lang.startsWith(langPrefix));
  
  if (langVoices.length === 0) {
    langVoices = voices;
  }
  
  // Try to find voice matching gender preference (for browser TTS fallback)
  // Map OpenAI voices to gender preference
  const femaleVoices = ['nova', 'shimmer'];
  const preferFemale = femaleVoices.includes(askiVoice);
  
  // Common female voice name patterns
  const femalePatterns = /female|woman|samantha|victoria|karen|moira|tessa|milena|anna|elena|irina|natasha|yuna|mei|xiaoxiao|huihui|sayaka|kyoko|siri.*female/i;
  // Common male voice name patterns  
  const malePatterns = /male|man|daniel|alex|tom|oliver|boris|yuri|maxim|ichiro|otoya|siri.*male/i;
  
  let preferredVoice = null;
  
  if (preferFemale) {
    preferredVoice = langVoices.find(v => femalePatterns.test(v.name));
  } else {
    preferredVoice = langVoices.find(v => malePatterns.test(v.name));
  }
  
  return preferredVoice || langVoices[0] || voices[0];
}

// ===== AUDIO PLAYBACK via AudioContext (for Android compatibility) =====
let globalAudioContext = null;
let currentAudioSource = null;

function getAudioContext() {
  if (!globalAudioContext) {
    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  return globalAudioContext;
}

// Play audio blob using AudioContext (works on Android!)
async function playAudioBlob(blob, onEnd = null) {
  try {
    const ctx = getAudioContext();
    
    // Resume if suspended (required after page load)
    if (ctx.state === 'suspended') {
      await ctx.resume();
    }
    
    // Stop current playback
    if (currentAudioSource) {
      try { currentAudioSource.stop(); } catch(e) {}
      currentAudioSource = null;
    }
    
    // Decode audio
    const arrayBuffer = await blob.arrayBuffer();
    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
    
    // Create source and play
    const source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(ctx.destination);
    
    source.onended = () => {
      currentAudioSource = null;
      if (onEnd) onEnd();
    };
    
    currentAudioSource = source;
    source.start();
    
    return true;
  } catch (error) {
    console.error('AudioContext playback error:', error);
    return false;
  }
}

// Stop current audio playback
function stopAudioPlayback() {
  if (currentAudioSource) {
    try { currentAudioSource.stop(); } catch(e) {}
    currentAudioSource = null;
  }
}

// ===== TTS Functions =====

// Speak text with Aski's voice
let askiAudio = null; // Current audio element for OpenAI TTS

async function askiSpeak(text, lang = null, onEnd = null) {
  if (askiIsSpeaking) {
    askiStopSpeaking();
  }
  
  // Remove emojis before speaking
  const cleanText = removeEmojis(text);
  if (!cleanText) {
    if (onEnd) onEnd();
    return;
  }
  
  // :    localStorage   
  ttsProvider = localStorage.getItem('tts_provider') || 'openai';
  elevenlabsApiKey = localStorage.getItem('elevenlabs_tts_key') || '';
  elevenlabsVoiceId = localStorage.getItem('elevenlabs_voice_id') || 'gedzfqL7OGdPbwm0ynTP';
  askiApiKey = localStorage.getItem('openai_tts_key') || '';
  
  // Route to appropriate TTS provider
  if (ttsProvider === 'elevenlabs') {
    if (elevenlabsApiKey) {
      await askiSpeakElevenLabs(cleanText, onEnd);
    } else {
      toast('ElevenLabs: no API key');
      askiSpeakBrowser(cleanText, lang, onEnd);
    }
  } else if (ttsProvider === 'openai') {
    if (askiApiKey) {
      await askiSpeakOpenAI(cleanText, onEnd);
    } else {
      askiSpeakBrowser(cleanText, lang, onEnd);
    }
  } else {
    // Browser TTS
    askiSpeakBrowser(cleanText, lang, onEnd);
  }
}

// OpenAI TTS
async function askiSpeakOpenAI(text, onEnd = null) {
  try {
    askiIsSpeaking = true;
    updateSpeakingIndicator(true);
    updateVoiceModeIndicator('speaking');
    
    const response = await fetch('https://api.openai.com/v1/audio/speech', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${askiApiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'tts-1',
        input: text,
        voice: askiVoice,
        response_format: 'mp3'
      })
    });
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      toast('TTS error: ' + (error.error?.message || response.status));
      askiIsSpeaking = false;
      updateSpeakingIndicator(false);
      askiSpeakBrowser(text, null, onEnd);
      return;
    }
    
    const blob = await response.blob();
    
    // Play using AudioContext (works on Android!)
    const success = await playAudioBlob(blob, () => {
      askiIsSpeaking = false;
      updateSpeakingIndicator(false);
      if (onEnd) onEnd();
    });
    
    if (!success) {
      // Fallback to browser TTS
      askiIsSpeaking = false;
      updateSpeakingIndicator(false);
      askiSpeakBrowser(text, null, onEnd);
    }
    
  } catch (error) {
    console.error('OpenAI TTS error:', error);
    askiIsSpeaking = false;
    updateSpeakingIndicator(false);
    askiSpeakBrowser(text, null, onEnd);
  }
}

// ElevenLabs TTS
async function askiSpeakElevenLabs(text, onEnd = null) {
  // Check if we have API key
  if (!elevenlabsApiKey) {
    toast('ElevenLabs: no API key');
    askiSpeakBrowser(text, null, onEnd);
    return;
  }
  
  try {
    askiIsSpeaking = true;
    updateSpeakingIndicator(true);
    updateVoiceModeIndicator('speaking');
    
    // Use stored voice ID
    const voiceId = elevenlabsVoiceId || 'gedzfqL7OGdPbwm0ynTP';
    
    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
      method: 'POST',
      headers: {
        'xi-api-key': elevenlabsApiKey,
        'Content-Type': 'application/json',
        'Accept': 'audio/mpeg'
      },
      body: JSON.stringify({
        text: text,
        model_id: 'eleven_multilingual_v2',
        voice_settings: {
          stability: 0.5,
          similarity_boost: 0.75
        }
      })
    });
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      const errMsg = error.detail?.message || error.detail?.status || error.detail || response.status;
      toast('ElevenLabs: ' + errMsg);
      askiIsSpeaking = false;
      updateSpeakingIndicator(false);
      askiSpeakBrowser(text, null, onEnd);
      return;
    }
    
    const blob = await response.blob();
    
    // Play using AudioContext (works on Android!)
    const success = await playAudioBlob(blob, () => {
      askiIsSpeaking = false;
      updateSpeakingIndicator(false);
      if (onEnd) onEnd();
    });
    
    if (!success) {
      askiIsSpeaking = false;
      updateSpeakingIndicator(false);
      askiSpeakBrowser(text, null, onEnd);
    }
    
  } catch (error) {
    toast('ElevenLabs: ' + (error.message || 'network error'));
    askiIsSpeaking = false;
    updateSpeakingIndicator(false);
    askiSpeakBrowser(text, null, onEnd);
  }
}

// ===== AUDIO DROP FUNCTIONS =====

// Audio recording state
let audioRecorder = null;
let audioRecordingChunks = [];
let audioRecordingStream = null;
let currentPlayingAudioId = null;
let currentAudioElement = null;

// Format duration in M:SS
function formatDuration(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return mins + ':' + secs.toString().padStart(2, '0');
}

// Format file size
function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + 'B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + 'KB';
  return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
}

// Update audio record button UI
function updateAudioRecordButton(isRecording) {
  // Removed - now using modal
}

// ===== AUDIO RECORDER MODAL (WORKING VERSION) =====
let recorderState = 'ready'; // ready, recording, paused, stopped
let recorderStartTime = null;
let recorderTimerInterval = null;
let recorderBlob = null;

function openAudioRecorder() {
  closePlusMenu();
  recorderState = 'ready';
  recorderBlob = null;
  audioRecordingChunks = [];
  document.getElementById('recorderTime').textContent = '0:00';
  updateRecorderUI();
  
  document.getElementById('audioRecorderModal').classList.add('show');
  acquireWakeLock();
}

function closeAudioRecorder() {
  if (audioRecorder && audioRecorder.state === 'recording') {
    audioRecorder.stop();
  }
  if (recorderTimerInterval) {
    clearInterval(recorderTimerInterval);
    recorderTimerInterval = null;
  }
  if (currentAudioElement) {
    currentAudioElement.pause();
    currentAudioElement = null;
  }
  document.getElementById('audioRecorderModal').classList.remove('show');
  releaseWakeLock();
}

function updateRecorderUI() {
  const mainBtn = document.getElementById('recorderMainBtn');
  const mainText = document.getElementById('recorderMainText');
  const waveform = document.getElementById('recorderWaveform');
  const stopBtn = document.getElementById('recorderStopBtn');
  const playBtn = document.getElementById('recorderPlayBtn');
  const rewindBtn = document.querySelector('#audioRecorderModal .ctrl-btn.rewind');
  const forwardBtn = document.querySelector('#audioRecorderModal .ctrl-btn.forward');
  const deleteBtn = document.querySelector('#audioRecorderModal .act-btn.delete');
  const createBtn = document.querySelector('#audioRecorderModal .act-btn.create');
  const shareBtn = document.querySelector('#audioRecorderModal .act-btn.share');
  
  // Main button class
  mainBtn.className = 'audio-recorder-main-btn ' + recorderState;
  
  // Main button text
  if (recorderState === 'ready') {
    mainText.textContent = 'TAP TO RECORD';
  } else if (recorderState === 'recording') {
    mainText.textContent = 'TAP TO PAUSE';
  } else if (recorderState === 'paused') {
    mainText.textContent = 'TAP TO RESUME';
  } else if (recorderState === 'stopped') {
    mainText.textContent = 'TAP TO RE-RECORD';
  }
  
  // Waveform animation
  if (waveform) {
    waveform.className = 'audio-recorder-waveform' + (recorderState === 'recording' ? ' recording' : '');
  }
  
  // Stop button - show during recording or paused
  if (stopBtn) stopBtn.style.display = (recorderState === 'recording' || recorderState === 'paused') ? 'block' : 'none';
  
  // Play/rewind/forward - show when stopped with recording
  const hasRecording = recorderState === 'stopped' && recorderBlob !== null;
  if (playBtn) playBtn.style.display = hasRecording ? 'block' : 'none';
  if (rewindBtn) rewindBtn.style.display = hasRecording ? 'block' : 'none';
  if (forwardBtn) forwardBtn.style.display = hasRecording ? 'block' : 'none';
  
  // Action buttons
  if (deleteBtn) { deleteBtn.disabled = !hasRecording; deleteBtn.style.opacity = hasRecording ? '1' : '0.4'; }
  if (createBtn) { createBtn.disabled = !hasRecording; createBtn.style.opacity = hasRecording ? '1' : '0.4'; }
  if (shareBtn) { shareBtn.disabled = !hasRecording; shareBtn.style.opacity = hasRecording ? '1' : '0.4'; }
}

function updateRecorderTime() {
  const elapsed = Date.now() - recorderStartTime;
  const secs = Math.floor(elapsed / 1000);
  const mins = Math.floor(secs / 60);
  document.getElementById('recorderTime').textContent = mins + ':' + (secs % 60).toString().padStart(2, '0');
}

function recorderToggleRecord() {
  if (recorderState === 'ready' || recorderState === 'stopped') {
    startRecorderRecording();
  } else if (recorderState === 'recording') {
    pauseRecorderRecording();
  } else if (recorderState === 'paused') {
    resumeRecorderRecording();
  }
}

function pauseRecorderRecording() {
  if (audioRecorder && audioRecorder.state === 'recording') {
    audioRecorder.pause();
    recorderState = 'paused';
    if (recorderTimerInterval) {
      clearInterval(recorderTimerInterval);
      recorderTimerInterval = null;
    }
    updateRecorderUI();
  }
}

function resumeRecorderRecording() {
  if (audioRecorder && audioRecorder.state === 'paused') {
    audioRecorder.resume();
    recorderState = 'recording';
    recorderTimerInterval = setInterval(updateRecorderTime, 100);
    updateRecorderUI();
  }
}

async function startRecorderRecording() {
  try {
    audioRecordingChunks = [];
    recorderBlob = null;
    
    audioRecordingStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    
    const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4';
    audioRecorder = new MediaRecorder(audioRecordingStream, { mimeType: mimeType });
    
    audioRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) {
        audioRecordingChunks.push(e.data);
      }
    };
    
    audioRecorder.onstop = () => {
      recorderBlob = new Blob(audioRecordingChunks, { type: mimeType });
      audioRecordingStream.getTracks().forEach(t => t.stop());
      recorderState = 'stopped';
      updateRecorderUI();
    };
    
    audioRecorder.start(100);
    recorderState = 'recording';
    recorderStartTime = Date.now();
    recorderTimerInterval = setInterval(updateRecorderTime, 100);
    updateRecorderUI();
    
  } catch (err) {
    toast('Microphone access denied');
  }
}

function recorderStop() {
  if (audioRecorder && audioRecorder.state !== 'inactive') {
    audioRecorder.stop();
    if (recorderTimerInterval) {
      clearInterval(recorderTimerInterval);
      recorderTimerInterval = null;
    }
  }
}

function recorderDelete() {
  if (currentAudioElement) {
    currentAudioElement.pause();
    currentAudioElement = null;
  }
  recorderBlob = null;
  audioRecordingChunks = [];
  recorderState = 'ready';
  document.getElementById('recorderTime').textContent = '0:00';
  updateRecorderUI();
  toast('Recording deleted');
}

function recorderCreateDrop() {
  if (!recorderBlob) return;
  
  const createBtn = document.querySelector('#audioRecorderModal .act-btn.create');
  const deleteBtn = document.querySelector('#audioRecorderModal .act-btn.delete');
  const shareBtn = document.querySelector('#audioRecorderModal .act-btn.share');
  
  // Disable all buttons
  createBtn.textContent = 'SAVING...';
  createBtn.disabled = true;
  if (deleteBtn) deleteBtn.disabled = true;
  if (shareBtn) shareBtn.disabled = true;
  
  const reader = new FileReader();
  
  reader.onload = function() {
    try {
      const base64Data = reader.result;
      
      const timeText = document.getElementById('recorderTime').textContent;
      const parts = timeText.split(':');
      const duration = parseInt(parts[0]) * 60 + parseInt(parts[1]);
      
      const now = new Date();
      const drop = {
        id: Date.now(),
        text: '',
        category: 'audio',
        timestamp: now.toISOString(),
        date: now.toLocaleDateString('ru-RU'),
        time: now.toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit', second:'2-digit'}),
        isMedia: true,
        audioData: base64Data,
        audioFormat: recorderBlob.type.split('/')[1] || 'webm',
        audioSize: recorderBlob.size,
        audioBitrate: duration > 0 ? Math.round((recorderBlob.size * 8) / duration) : 0,
        duration: duration,
        waveform: [],
        notes: ''
      };
      
      ideas.unshift(drop);
      save(drop);
      playDropSound(); // Play signature sound
      render();
      counts();
      
      // Success
      createBtn.textContent = 'CREATED!';
      createBtn.style.background = '#10B981';
      createBtn.style.color = 'white';
      toast('Audio saved!', 'success');
      
      // Reset
      recorderBlob = null;
      recorderState = 'ready';
      document.getElementById('recorderTime').textContent = '0:00';
      updateRecorderUI();
      
      setTimeout(() => {
        createBtn.textContent = 'CREATE DROP';
        createBtn.style.background = '#D1FAE5';
        createBtn.style.color = '#065F46';
      }, 1500);
      
    } catch (err) {
      console.error('recorderCreateDrop error:', err);
      createBtn.textContent = 'ERROR';
      createBtn.style.background = '#FEE2E2';
      toast('Error: ' + err.message, 'error');
      setTimeout(() => {
        createBtn.textContent = 'CREATE DROP';
        createBtn.style.background = '#D1FAE5';
        createBtn.style.color = '#065F46';
        createBtn.disabled = false;
        if (deleteBtn) deleteBtn.disabled = false;
        if (shareBtn) shareBtn.disabled = false;
      }, 2000);
    }
  };
  
  reader.onerror = function() {
    createBtn.textContent = 'ERROR';
    toast('File read error', 'error');
  };
  
  reader.readAsDataURL(recorderBlob);
}

async function recorderShare() {
  if (!recorderBlob) return;
  
  const fileName = 'droplit-audio.' + (recorderBlob.type.includes('mp4') ? 'm4a' : 'webm');
  const file = new File([recorderBlob], fileName, { type: recorderBlob.type });
  
  if (typeof navigator.share === 'function') {
    try {
      await navigator.share({
        files: [file],
        title: 'DropLit Audio'
      });
      toast('Shared!');
    } catch (err) {
      if (err.name === 'AbortError') {
        return;
      }
      // Try without files
      try {
        await navigator.share({
          title: 'DropLit Audio',
          text: 'Audio ' + document.getElementById('recorderTime').textContent
        });
        toast('Shared (text only)');
      } catch (err2) {
        downloadRecorderFile();
      }
    }
  } else {
    downloadRecorderFile();
  }
  
  function downloadRecorderFile() {
    const url = URL.createObjectURL(recorderBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    toast('Downloaded');
  }
}

function recorderPlayPause() {
  if (recorderState !== 'stopped' || !recorderBlob) return;
  
  const playBtn = document.getElementById('recorderPlayBtn');
  
  if (currentAudioElement) {
    currentAudioElement.pause();
    currentAudioElement = null;
    playBtn.textContent = 'PLAY';
    return;
  }
  
  const url = URL.createObjectURL(recorderBlob);
  currentAudioElement = new Audio(url);
  currentAudioElement.onended = () => {
    currentAudioElement = null;
    playBtn.textContent = 'PLAY';
    URL.revokeObjectURL(url);
  };
  currentAudioElement.play();
  playBtn.textContent = 'PAUSE';
}

function recorderRewind() {
  if (currentAudioElement) {
    currentAudioElement.currentTime = Math.max(0, currentAudioElement.currentTime - 10);
  }
}

function recorderForward() {
  if (currentAudioElement) {
    currentAudioElement.currentTime = Math.min(currentAudioElement.duration, currentAudioElement.currentTime + 10);
  }
}

// Generate simple waveform from audio buffer
async function generateWaveform(blob, numBars = 40) {
  try {
    const ctx = getAudioContext();
    const arrayBuffer = await blob.arrayBuffer();
    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
    const rawData = audioBuffer.getChannelData(0);
    const blockSize = Math.floor(rawData.length / numBars);
    const waveform = [];
    
    for (let i = 0; i < numBars; i++) {
      let sum = 0;
      for (let j = 0; j < blockSize; j++) {
        sum += Math.abs(rawData[i * blockSize + j] || 0);
      }
      waveform.push(Math.min(1, (sum / blockSize) * 3)); // Normalize and amplify
    }
    
    return waveform;
  } catch (e) {
    console.error('Waveform generation error:', e);
    return Array(numBars).fill(0.3); // Default waveform
  }
}

// Save audio drop
async function saveAudioDrop(blob) {
  try {
    // Get duration first
    const ctx = getAudioContext();
    const arrayBuffer = await blob.arrayBuffer();
    const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
    const duration = audioBuffer.duration;
    
    // Convert blob to base64
    const base64Data = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = () => reject(new Error('Failed to read audio'));
      reader.readAsDataURL(blob);
    });
    
    const now = new Date();
    const drop = {
      id: Date.now(),
      text: '',
      category: 'audio',
      timestamp: now.toISOString(),
      date: now.toLocaleDateString('ru-RU'),
      time: now.toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit', second:'2-digit'}),
      isMedia: true,
      audioData: base64Data,
      audioFormat: blob.type.split('/')[1] || 'webm',
      audioSize: blob.size,
      audioBitrate: Math.round((blob.size * 8) / duration),
      duration: duration,
      waveform: [],
      notes: ''
    };
    
    ideas.unshift(drop);
    save(drop);
    playDropSound(); // Play signature sound
    render();
    counts();
    
    toast('Audio saved! ' + formatDuration(duration));
    return drop;
    
  } catch (error) {
    console.error('Save audio error:', error);
    toast('Error saving audio');
    throw error;
  }
}

// Play audio drop
function playAudioDrop(id, event) {
  if (event) event.stopPropagation();
  
  const item = ideas.find(x => x.id === id);
  if (!item || !item.audioData) {
    toast('Audio not found');
    return;
  }
  
  // Stop current playback
  if (currentAudioElement) {
    currentAudioElement.pause();
    currentAudioElement = null;
    
    // Reset previous play button
    if (currentPlayingAudioId) {
      const prevBtn = document.getElementById('playbtn-' + currentPlayingAudioId);
      if (prevBtn) {
        prevBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
      }
    }
    
    // If same audio, just stop
    if (currentPlayingAudioId === id) {
      currentPlayingAudioId = null;
      return;
    }
  }
  
  currentPlayingAudioId = id;
  currentAudioElement = new Audio(item.audioData);
  
  const playBtn = document.getElementById('playbtn-' + id);
  const timeEl = document.getElementById('audiotime-' + id);
  
  currentAudioElement.onplay = () => {
    if (playBtn) {
      playBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>';
    }
  };
  
  currentAudioElement.ontimeupdate = () => {
    if (timeEl) {
      timeEl.textContent = formatDuration(currentAudioElement.currentTime);
    }
    // Update waveform progress
    updateWaveformProgress(id, currentAudioElement.currentTime / currentAudioElement.duration);
  };
  
  currentAudioElement.onended = () => {
    if (playBtn) {
      playBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>';
    }
    if (timeEl) {
      timeEl.textContent = '0:00';
    }
    updateWaveformProgress(id, 0);
    currentPlayingAudioId = null;
    currentAudioElement = null;
  };
  
  currentAudioElement.onerror = () => {
    toast('Error playing audio');
    currentPlayingAudioId = null;
    currentAudioElement = null;
  };
  
  currentAudioElement.play();
}

// Toggle play/pause for audio in card
function togglePlayAudio(id, event) {
  if (event) event.stopPropagation();
  playAudioDrop(id, event);
}

// Seek audio
function seekAudio(id, seconds, event) {
  if (event) event.stopPropagation();
  
  if (currentPlayingAudioId === id && currentAudioElement) {
    currentAudioElement.currentTime = Math.max(0, Math.min(
      currentAudioElement.duration,
      currentAudioElement.currentTime + seconds
    ));
  }
}

// Update waveform progress visualization
function updateWaveformProgress(id, progress) {
  const waveform = document.getElementById('waveform-' + id);
  if (!waveform) return;
  
  const bars = waveform.querySelectorAll('.audio-waveform-bar');
  const playedBars = Math.floor(bars.length * progress);
  
  bars.forEach((bar, i) => {
    if (i < playedBars) {
      bar.classList.add('played');
    } else {
      bar.classList.remove('played');
    }
  });
}

// Transcribe audio using Whisper API
async function transcribeAudio(id) {
  const item = ideas.find(x => x.id === id);
  if (!item || !item.audioData) {
    toast('Audio not found');
    return;
  }
  
  if (!askiApiKey) {
    toast('Enter OpenAI API key first');
    return;
  }
  
  toast('Transcribing...');
  
  try {
    // Convert base64 to blob
    const response = await fetch(item.audioData);
    const blob = await response.blob();
    
    // Create form data
    const formData = new FormData();
    formData.append('file', blob, 'audio.' + (item.audioFormat || 'webm'));
    formData.append('model', 'whisper-1');
    
    const result = await fetch('https://api.openai.com/v1/audio/transcriptions', {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer ' + askiApiKey
      },
      body: formData
    });
    
    if (!result.ok) {
      const error = await result.json().catch(() => ({}));
      toast('Transcription error: ' + (error.error?.message || result.status));
      return;
    }
    
    const data = await result.json();
    const transcript = data.text;
    
    // Update the drop with transcript
    item.notes = transcript;
    item.text = transcript;
    updateDrop(item);
    render();
    
    toast('Transcribed: ' + transcript.substring(0, 50) + '...');
    
  } catch (error) {
    console.error('Transcription error:', error);
    toast('Transcription failed');
  }
}

// Fallback browser TTS
function askiSpeakBrowser(text, lang = null, onEnd = null) {
  if (!('speechSynthesis' in window)) {
    toast('Voice not supported');
    if (onEnd) onEnd();
    return;
  }
  
  const detectedLang = lang || detectLanguage(text);
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = detectedLang;
  utterance.rate = 0.95;
  utterance.volume = 1.0;
  
  const voice = getVoiceForLang(detectedLang);
  if (voice) utterance.voice = voice;
  
  utterance.onstart = () => {
    askiIsSpeaking = true;
    updateSpeakingIndicator(true);
    updateVoiceModeIndicator('speaking');
  };
  
  utterance.onend = () => {
    askiIsSpeaking = false;
    askiCurrentUtterance = null;
    updateSpeakingIndicator(false);
    if (onEnd) onEnd();
  };
  
  utterance.onerror = () => {
    askiIsSpeaking = false;
    askiCurrentUtterance = null;
    updateSpeakingIndicator(false);
    if (onEnd) onEnd();
  };
  
  askiCurrentUtterance = utterance;
  speechSynthesis.speak(utterance);
}

// Stop speaking
function askiStopSpeaking() {
  // Stop our new TTS audio
  stopTTS();
  // Stop AudioContext playback
  stopAudioPlayback();
  // Stop legacy Audio element (if any)
  if (askiAudio) {
    askiAudio.pause();
    askiAudio.currentTime = 0;
    askiAudio = null;
  }
  // Stop browser TTS
  if (speechSynthesis.speaking) {
    speechSynthesis.cancel();
  }
  askiIsSpeaking = false;
  askiCurrentUtterance = null;
  updateSpeakingIndicator(false);
}

// Toggle speak for a message
function toggleAskiSpeak(btn) {
  if (askiIsSpeaking) {
    askiStopSpeaking();
    return;
  }
  
  const bubble = btn.closest('.ask-ai-message').querySelector('.ask-ai-bubble');
  const text = bubble.textContent;
  askiSpeak(text);
}

// Update speaking indicator in header
function updateSpeakingIndicator(isSpeaking) {
  // Removed - status shown in subtitle instead
}

// ============================================
// VOICE MODE (Full voice conversation)
// ============================================

let voiceModeEnabled = false;
let voiceModeRecognition = null;
let askiIsProcessing = false; // True when waiting for API response
let voiceModeLocked = false;  // Prevents mic when Aski is speaking/processing
let voiceModeSleeping = false; // Sleep mode - waiting for user tap
let voiceModeTimeout = null;  // Timer (kept for potential future use)
let voiceModeCyclesLeft = 0;  // How many listening cycles before sleep

// Audio feedback for voice mode
function playVoiceBeep(type) {
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    if (type === 'start') {
      // Rising tone - mic ON
      osc.frequency.setValueAtTime(600, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(900, ctx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.15, ctx.currentTime);
    } else {
      // Falling tone - mic OFF / sleep
      osc.frequency.setValueAtTime(600, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(400, ctx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.1, ctx.currentTime);
    }
    
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.15);
  } catch(e) {
    // Audio not available
  }
}

function isVoiceModeEnabled() {
  return localStorage.getItem('aski_voice_mode') === 'true';
}

function setVoiceMode(enabled) {
  localStorage.setItem('aski_voice_mode', enabled ? 'true' : 'false');
  voiceModeEnabled = enabled;
  
  if (enabled) {
    // Also enable auto-speak
    localStorage.setItem('aski_auto_speak', 'true');
    document.getElementById('autoSpeakToggle')?.classList.add('active');
  }
}

function isAutoSpeakEnabled() {
  return localStorage.getItem('aski_auto_speak') === 'true' || isVoiceModeEnabled();
}

function setAutoSpeak(enabled) {
  localStorage.setItem('aski_auto_speak', enabled ? 'true' : 'false');
  toast(enabled ? 'Auto-speak enabled' : 'Auto-speak disabled');
}

// Voice Mode: Start listening (only when NOT locked)
function startVoiceModeListening() {
  // Check all conditions
  if (!isVoiceModeEnabled()) return;
  if (voiceModeLocked) {
    console.log('Voice mode locked, skipping');
    return;
  }
  if (voiceModeSleeping) {
    console.log('Voice mode sleeping, tap to wake');
    return;
  }
  if (askiIsSpeaking || askiIsProcessing) {
    console.log('Aski is busy, skipping mic start');
    return;
  }
  if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    toast('Voice not supported in this browser');
    return;
  }
  
  // Stop any existing recognition first
  if (voiceModeRecognition) {
    try { voiceModeRecognition.abort(); } catch(e) {}
    voiceModeRecognition = null;
  }
  
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  voiceModeRecognition = new SpeechRecognition();
  voiceModeRecognition.continuous = false;
  voiceModeRecognition.interimResults = false;
  voiceModeRecognition.lang = navigator.language || 'ru-RU';
  
  voiceModeRecognition.onstart = () => {
    document.getElementById('askAIVoiceBtn')?.classList.add('recording');
    updateVoiceModeIndicator('listening');
  };
  
  voiceModeRecognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    if (transcript.trim()) {
      // User spoke real words
      clearVoiceModeTimeout();
      
      // LOCK voice mode before sending
      voiceModeLocked = true;
      stopVoiceModeListening();
      
      // Send the message
      document.getElementById('askAIInput').value = transcript;
      sendAskAIMessage();
    } else {
      // Empty result = noise without words = go to sleep
      console.log('Empty transcript - going to sleep');
      enterVoiceModeSleep();
    }
  };
  
  voiceModeRecognition.onend = () => {
    document.getElementById('askAIVoiceBtn')?.classList.remove('recording');
    
    // If locked (sending message) - don't do anything
    if (voiceModeLocked) return;
    
    // Check if we have cycles left
    if (voiceModeCyclesLeft > 0) {
      voiceModeCyclesLeft--;
      console.log('Cycles left:', voiceModeCyclesLeft);
      updateVoiceModeIndicator('waiting');
      setTimeout(startVoiceModeListening, 300);
    } else {
      enterVoiceModeSleep();
    }
  };
  
  voiceModeRecognition.onerror = (e) => {
    document.getElementById('askAIVoiceBtn')?.classList.remove('recording');
    
    if (e.error !== 'aborted') {
      console.log('Voice mode:', e.error);
    }
    
    // If locked - don't do anything
    if (voiceModeLocked) return;
    
    // Check if we have cycles left
    if (voiceModeCyclesLeft > 0) {
      voiceModeCyclesLeft--;
      console.log('Cycles left:', voiceModeCyclesLeft);
      updateVoiceModeIndicator('waiting');
      setTimeout(startVoiceModeListening, 500);
    } else {
      enterVoiceModeSleep();
    }
  };
  
  try {
    voiceModeRecognition.start();
  } catch (e) {
    console.error('Could not start voice mode:', e);
  }
}

// Clear any pending timeout
function clearVoiceModeTimeout() {
  if (voiceModeTimeout) {
    clearTimeout(voiceModeTimeout);
    voiceModeTimeout = null;
  }
}

// Enter sleep mode
function enterVoiceModeSleep() {
  console.log('Voice mode entering sleep');
  voiceModeSleeping = true;
  voiceModeCyclesLeft = 0;
  stopVoiceModeListening();
  clearVoiceModeTimeout();
  playVoiceBeep('stop');
  updateVoiceModeIndicator('sleeping');
}

// Wake up from sleep mode (user tapped mic button)
function wakeVoiceMode() {
  console.log('Voice mode waking up (manual tap)');
  voiceModeSleeping = false;
  voiceModeLocked = false;
  voiceModeCyclesLeft = 1; // Manual tap = 1 cycle only
  playVoiceBeep('start');
  updateVoiceModeIndicator('waiting');
  setTimeout(startVoiceModeListening, 300);
}

function stopVoiceModeListening() {
  if (voiceModeRecognition) {
    try {
      voiceModeRecognition.abort();
    } catch (e) {}
    voiceModeRecognition = null;
  }
  document.getElementById('askAIVoiceBtn')?.classList.remove('recording');
}

// Unlock and restart listening (called after Aski finishes speaking)
function unlockVoiceMode() {
  voiceModeLocked = false;
  askiIsProcessing = false;
  
  // After Aski finishes speaking - auto-start listening for conversation flow
  if (isVoiceModeEnabled() && document.getElementById('askAIPanel')?.classList.contains('show')) {
    voiceModeSleeping = false;
    voiceModeCyclesLeft = getListenCycles(); // Use setting
    playVoiceBeep('start');
    updateVoiceModeIndicator('waiting');
    setTimeout(startVoiceModeListening, 500);
  }
}

function updateVoiceModeIndicator(state) {
  const largeBtn = document.getElementById('askAIVoiceLarge');
  const largeBtnText = document.getElementById('voiceLargeText');
  const controlRight = document.getElementById('askAIControlRight');
  const controlRightText = document.getElementById('askAIControlRightText');
  
  // Update only the large button at bottom
  switch(state) {
    case 'listening':
      if (largeBtn) {
        largeBtn.classList.add('listening');
        largeBtnText.textContent = 'Listening...';
      }
      if (controlRight) {
        controlRight.classList.add('listening');
        controlRight.classList.remove('processing');
        if (controlRightText) controlRightText.textContent = 'LISTENING...';
      }
      break;
    case 'processing':
      setAskiBusy(true);
      if (largeBtn) {
        largeBtn.classList.remove('listening');
        largeBtnText.textContent = 'Thinking...';
      }
      if (controlRight) {
        controlRight.classList.remove('listening');
        controlRight.classList.add('processing');
        if (controlRightText) controlRightText.textContent = 'THINKING...';
      }
      updateChatControlLeft('stop');
      break;
    case 'speaking':
      setAskiBusy(true);
      if (largeBtn) {
        largeBtn.classList.remove('listening');
        largeBtnText.textContent = 'Speaking...';
      }
      if (controlRight) {
        controlRight.classList.remove('listening');
        controlRight.classList.add('processing');
        if (controlRightText) controlRightText.textContent = 'SPEAKING...';
      }
      updateChatControlLeft('stop');
      break;
    case 'locked':
      if (largeBtn) {
        largeBtn.classList.remove('listening');
        largeBtnText.textContent = 'Please wait...';
      }
      if (controlRight) {
        controlRight.classList.remove('listening');
        controlRight.classList.remove('processing');
        if (controlRightText) controlRightText.textContent = 'WAIT...';
      }
      break;
    case 'waiting':
      setAskiBusy(false);
      if (largeBtn) {
        largeBtn.classList.remove('listening');
        largeBtnText.textContent = 'Tap to talk';
      }
      if (controlRight) {
        controlRight.classList.remove('listening');
        controlRight.classList.remove('processing');
        if (controlRightText) controlRightText.textContent = 'TAP TO TALK';
      }
      updateChatControlLeft('hide');
      break;
    case 'sleeping':
      setAskiBusy(false);
      if (largeBtn) {
        largeBtn.classList.remove('listening');
        largeBtnText.textContent = 'Tap to talk';
      }
      if (controlRight) {
        controlRight.classList.remove('listening');
        controlRight.classList.remove('processing');
        if (controlRightText) controlRightText.textContent = 'TAP TO TALK';
      }
      updateChatControlLeft('hide');
      break;
    default:
      setAskiBusy(false);
      if (largeBtn) {
        largeBtn.classList.remove('listening');
        largeBtnText.textContent = 'Tap to talk';
      }
      if (controlRight) {
        controlRight.classList.remove('listening');
        controlRight.classList.remove('processing');
        if (controlRightText) controlRightText.textContent = 'TAP TO TALK';
      }
      updateChatControlLeft('hide');
  }
}

// Set voice (OpenAI TTS)
function setAskiVoice(voice) {
  askiVoice = voice;
  localStorage.setItem('aski_voice', voice);
  // Update UI - remove active from all, add to selected
  document.querySelectorAll('#voiceSelector .pill-m').forEach(btn => {
    btn.classList.remove('active');
  });
  const selectedBtn = document.querySelector(`#voiceSelector .pill-m[data-voice="${voice}"]`);
  if (selectedBtn) {
    selectedBtn.classList.add('active');
  }
  // Preview voice
  previewVoice(voice);
}

// Preview voice with sample text
async function previewVoice(voice) {
  if (!askiApiKey) {
    toast('Enter API key to preview');
    return;
  }
  
  const samples = {
    'nova': 'Hi! I\'m Nova, friendly and warm.',
    'shimmer': 'Hello, I\'m Shimmer, soft and gentle.',
    'alloy': 'Hey there, I\'m Alloy, balanced and clear.',
    'onyx': 'Hello, I\'m Onyx, deep and confident.',
    'echo': 'Hi, I\'m Echo, calm and measured.',
    'fable': 'Hello! I\'m Fable, expressive and British.'
  };
  
  const text = samples[voice] || `This is ${voice} voice.`;
  askiSpeak(text, 'en', null);
}

// Save OpenAI API key
function saveOpenAIKey() {
  const input = document.getElementById('openaiApiKeyInput');
  const key = input.value.trim();
  askiApiKey = key;
  localStorage.setItem('openai_tts_key', key);
  
  const status = document.getElementById('apiKeyStatus');
  if (key) {
    if (key.startsWith('sk-')) {
      status.textContent = 'Key saved';
      status.style.color = '#10B981';
    } else {
      status.textContent = 'Invalid key format (should start with sk-)';
      status.style.color = '#EF4444';
    }
  } else {
    status.textContent = 'Using browser voice (lower quality)';
    status.style.color = 'var(--color-text-muted)';
  }
}

// Toggle API key visibility
function toggleApiKeyVisibility() {
  const input = document.getElementById('openaiApiKeyInput');
  const btn = document.getElementById('apiKeyToggleBtn');
  if (input.type === 'password') {
    input.type = 'text';
    btn.textContent = 'Hide';
  } else {
    input.type = 'password';
    btn.textContent = 'Show';
  }
}

// Load API key on init
function loadOpenAIKey() {
  const input = document.getElementById('openaiApiKeyInput');
  if (input && askiApiKey) {
    input.value = askiApiKey;
    saveOpenAIKey(); // Update status
  }
}

// TTS Provider functions
function setTTSProvider(provider) {
  ttsProvider = provider;
  localStorage.setItem('tts_provider', provider);
  
  // Update UI - remove active from all, add to selected
  document.querySelectorAll('#ttsProviderSelector .pill-m').forEach(btn => {
    btn.classList.remove('active');
  });
  const selectedBtn = document.querySelector(`#ttsProviderSelector .pill-m[data-provider="${provider}"]`);
  if (selectedBtn) {
    selectedBtn.classList.add('active');
  }
  
  // Show/hide provider-specific settings
  const openaiSettings = document.getElementById('openaiVoiceSettings');
  const elevenlabsSettings = document.getElementById('elevenlabsVoiceSettings');
  
  if (openaiSettings) {
    openaiSettings.style.display = (provider === 'openai') ? 'block' : 'none';
  }
  if (elevenlabsSettings) {
    elevenlabsSettings.style.display = (provider === 'elevenlabs') ? 'block' : 'none';
    // Load ElevenLabs key into input when switching to ElevenLabs
    if (provider === 'elevenlabs') {
      elevenlabsApiKey = localStorage.getItem('elevenlabs_tts_key') || '';
      elevenlabsVoiceId = localStorage.getItem('elevenlabs_voice_id') || 'gedzfqL7OGdPbwm0ynTP';
      
      const input = document.getElementById('elevenlabsApiKeyInput');
      if (input) {
        input.value = elevenlabsApiKey;
        const status = document.getElementById('elevenlabsApiKeyStatus');
        if (status && elevenlabsApiKey) {
          status.textContent = 'Key loaded';
          status.style.color = '#10B981';
        }
      }
      
      // Update voice selector
      document.querySelectorAll('#elevenlabsVoiceSelector .pill-m').forEach(btn => {
        btn.classList.remove('active');
      });
      const voiceBtn = document.querySelector(`#elevenlabsVoiceSelector .pill-m[data-voiceid="${elevenlabsVoiceId}"]`);
      if (voiceBtn) {
        voiceBtn.classList.add('active');
      }
    }
  }
  
  toast(`TTS: ${provider === 'openai' ? 'OpenAI' : provider === 'elevenlabs' ? 'ElevenLabs' : 'Browser'}`);
}

// ElevenLabs voice selection (legacy, kept for compatibility)
function setElevenLabsVoice(voice) {
  const voiceId = ELEVENLABS_VOICES[voice];
  if (voiceId) {
    selectElevenLabsVoice(voice, voiceId);
  }
}

// Preview ElevenLabs voice
async function previewElevenLabsVoice(voice) {
  //    localStorage
  elevenlabsApiKey = localStorage.getItem('elevenlabs_tts_key') || '';
  
  if (!elevenlabsApiKey) {
    toast('Enter ElevenLabs API key');
    return;
  }
  
  //  voice ID  
  const voiceId = ELEVENLABS_VOICES[voice];
  
  if (!voiceId) {
    toast('Unknown voice: ' + voice);
    return;
  }
  
  // ENGLISH text to avoid encoding issues
  const text = 'Hello! This is ' + voice + ' voice test.';
  
  toast('Loading...');
  
  try {
    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
      method: 'POST',
      headers: {
        'xi-api-key': elevenlabsApiKey,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: text,
        model_id: 'eleven_multilingual_v2'
      })
    });
    
    if (!response.ok) {
      toast('API error: ' + response.status);
      return;
    }
    
    const blob = await response.blob();
    toast('Playing...');
    
    // Play using AudioContext (works on Android!)
    const success = await playAudioBlob(blob);
    if (!success) {
      toast('Playback error');
    }
    
  } catch (error) {
    toast('Error: ' + error.message);
  }
}

// Save ElevenLabs API key
function saveElevenLabsKey() {
  const input = document.getElementById('elevenlabsApiKeyInput');
  if (!input) {
    toast('Input not found');
    return;
  }
  
  const key = input.value.trim();
  
  elevenlabsApiKey = key;
  localStorage.setItem('elevenlabs_tts_key', key);
  
  // Verify save
  const saved = localStorage.getItem('elevenlabs_tts_key');
  console.log('Key saved to localStorage, verified length:', saved?.length);
  
  const status = document.getElementById('elevenlabsApiKeyStatus');
  if (key) {
    status.textContent = `Key saved (${key.length} chars)`;
    status.style.color = '#10B981';
  } else {
    status.textContent = '';
  }
}

// Toggle API key visibility (supports both providers)
function toggleApiKeyVisibility(provider = 'openai') {
  if (provider === 'elevenlabs') {
    const input = document.getElementById('elevenlabsApiKeyInput');
    const btn = document.getElementById('elevenlabsApiKeyToggleBtn');
    if (input.type === 'password') {
      input.type = 'text';
      btn.textContent = 'Hide';
    } else {
      input.type = 'password';
      btn.textContent = 'Show';
    }
  } else {
    const input = document.getElementById('openaiApiKeyInput');
    const btn = document.getElementById('apiKeyToggleBtn');
    if (input.type === 'password') {
      input.type = 'text';
      btn.textContent = 'Hide';
    } else {
      input.type = 'password';
      btn.textContent = 'Show';
    }
  }
}

// Load ElevenLabs key on init
function loadElevenLabsKey() {
  // Debug
  console.log('loadElevenLabsKey called, key exists:', !!elevenlabsApiKey, 'length:', elevenlabsApiKey?.length);
  
  const input = document.getElementById('elevenlabsApiKeyInput');
  if (input) {
    if (elevenlabsApiKey) {
      input.value = elevenlabsApiKey;
      const status = document.getElementById('elevenlabsApiKeyStatus');
      if (status) {
        status.textContent = 'Key loaded';
        status.style.color = '#10B981';
      }
    }
  } else {
    // Input not found yet, retry after short delay
    console.log('elevenlabsApiKeyInput not found, will retry...');
  }
}

// Initialize TTS provider UI -     initVoiceSettings()
function initTTSProviderUI() {
  // Deprecated - use initVoiceSettings() instead
}

// Get listen cycles setting (stored as seconds, convert to cycles)
function getListenCycles() {
  const seconds = parseInt(localStorage.getItem('aski_listen_seconds') || '15');
  return Math.round(seconds / 5); // ~5 sec per cycle
}

// Set listen time in seconds
function setListenCycles(seconds) {
  localStorage.setItem('aski_listen_seconds', seconds.toString());
  // Update UI
  document.querySelectorAll('#listenCyclesSelector .pill-m').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.cycles === seconds.toString());
  });
  toast(`Listen time: ${seconds} sec`);
}

// Load voices (some browsers need this)
if ('speechSynthesis' in window) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Streaming response handler v2 - supports tools
async function handleStreamingResponse(response) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  const messagesDiv = document.getElementById('askAIMessages');
  const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  
  const msgDiv = document.createElement('div');
  msgDiv.className = 'ask-ai-message ai';
  msgDiv.innerHTML = '<div class="ask-ai-bubble"><span class="streaming-text"></span><span class="streaming-indicator"></span></div><div class="ask-ai-time">' + time + '</div>';
  messagesDiv.appendChild(msgDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
  
  const textSpan = msgDiv.querySelector('.streaming-text');
  const indicator = msgDiv.querySelector('.streaming-indicator');
  let fullText = '';
  let buffer = '';
  let toolsUsed = [];
  let createDropData = null;
  
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') break;
          try {
            const parsed = JSON.parse(data);
            
            // New API v4.5 format
            if (parsed.type === 'text' && parsed.content) {
              fullText += parsed.content;
              textSpan.textContent = fullText;
              messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            // Tool started - show indicator
            if (parsed.type === 'tool_start') {
              if (indicator) {
                indicator.textContent = toolStatusText(parsed.tool);
                indicator.classList.add('tool-active');
              }
            }
            
            // Tool completed
            if (parsed.type === 'tool_result') {
              if (indicator) {
                indicator.classList.remove('tool-active');
                indicator.textContent = '';
              }
            }
            
            // Stream done - get metadata
            if (parsed.type === 'done') {
              toolsUsed = parsed.toolsUsed || [];
              createDropData = parsed.createDrop;
            }
            
            // Error
            if (parsed.type === 'error') {
              console.error('Stream error:', parsed.error);
              textSpan.textContent = 'Error: ' + parsed.error;
            }
            
            // Legacy format support (fallback)
            if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
              fullText += parsed.delta.text;
              textSpan.textContent = fullText;
              messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
          } catch (e) {}
        }
      }
    }
  } catch (e) {
    console.error('Streaming error:', e);
  }
  
  // Remove indicator
  if (indicator) indicator.remove();
  
  // Add action buttons
  const bubble = msgDiv.querySelector('.ask-ai-bubble');
  const actionsDiv = document.createElement('div');
  actionsDiv.className = 'ask-ai-actions';
  actionsDiv.innerHTML = '<button class="ask-ai-action-btn" onclick="copyAskAIMessage(this)">Copy</button><button class="ask-ai-action-btn" onclick="speakAskAIMessage(this)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg> Speak</button><button class="ask-ai-action-btn" onclick="createDropFromAI(this)">Create Drop</button>';
  bubble.after(actionsDiv);
  
  // Save to history
  askAIMessages.push({ text: fullText, isUser: false });
  
  // Handle create_drop from tool
  if (createDropData?.drop) {
    const drop = createDropData.drop;
    const newIdea = {
      id: Date.now().toString(),
      text: drop.text,
      category: drop.category || 'inbox',
      date: new Date().toISOString().split('T')[0],
      time: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false }),
      isMedia: false
    };
    ideas.unshift(newIdea);
    save();
    render();
    toast('Drop created by Aski', 'success');
  }
  
  // AutoDrop
  if (isAutoDropEnabled()) autoSaveMessageAsDrop(fullText, false);
  
  // Auto-speak
  if (isAutoSpeakEnabled() && fullText) {
    try {
      speakText(fullText);
    } catch (e) {
      console.error('TTS error:', e);
      unlockVoiceMode();
    }
  } else {
    unlockVoiceMode();
  }
}

// Helper for tool status
function toolStatusText(toolName) {
  const names = {
    'web_search': 'Searching...',
    'create_drop': 'Creating drop...',
    'fetch_recent_drops': 'Reading notes...',
    'search_drops': 'Searching notes...',
    'get_summary': 'Summarizing...'
  };
  return names[toolName] || 'Processing...';
}
}

function addAskAIMessage(text, isUser = true) {
  const messagesDiv = document.getElementById('askAIMessages');
  const emptyState = document.getElementById('askAIEmpty');
  
  if (emptyState) emptyState.style.display = 'none';
  
  const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  const autoDropEnabled = isAutoDropEnabled();
  
  const msgDiv = document.createElement('div');
  msgDiv.className = `ask-ai-message ${isUser ? 'user' : 'ai'}`;
  
  // Determine button state based on AutoDrop
  const createDropBtn = autoDropEnabled 
    ? `<button class="ask-ai-action-btn created autodrop-saved">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
        Saved
      </button>`
    : `<button class="ask-ai-action-btn" onclick="createDropFromAI(this)">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
        Create Drop
      </button>`;
  
  if (isUser) {
    msgDiv.innerHTML = `
      <div class="ask-ai-bubble">${escapeHtml(text)}</div>
      <div class="ask-ai-actions">
        ${createDropBtn}
        <button class="ask-ai-action-btn" onclick="copyAIResponse(this)">Copy</button>
      </div>
      <div class="ask-ai-time">${time}</div>
    `;
  } else {
    msgDiv.innerHTML = `
      <div class="ask-ai-bubble">${text}</div>
      <div class="ask-ai-actions">
        <button class="ask-ai-action-btn speak-btn" onclick="toggleAskiSpeak(this)" title="Speak">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
          Speak
        </button>
        ${createDropBtn}
        <button class="ask-ai-action-btn" onclick="copyAIResponse(this)">Copy</button>
      </div>
      <div class="ask-ai-time">${time}</div>
    `;
    
    // Auto-speak if enabled
    if (isAutoSpeakEnabled()) {
      updateVoiceModeIndicator('speaking');
      setTimeout(() => {
        askiSpeak(text, null, () => {
          // After speaking, UNLOCK voice mode (this will restart listening)
          unlockVoiceMode();
        });
      }, 300);
    } else {
      // No auto-speak, unlock immediately
      unlockVoiceMode();
    }
  }
  
  messagesDiv.appendChild(msgDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
  
  askAIMessages.push({ text, isUser, time });
  
  // AutoDrop: automatically save message as drop
  if (autoDropEnabled) {
    autoSaveMessageAsDrop(text, isUser);
  }
}

function showAskAITyping() {
  const messagesDiv = document.getElementById('askAIMessages');
  const typingDiv = document.createElement('div');
  typingDiv.className = 'ask-ai-message ai';
  typingDiv.id = 'askAITyping';
  typingDiv.innerHTML = `
    <div class="ask-ai-typing">
      <div class="ask-ai-typing-dot"></div>
      <div class="ask-ai-typing-dot"></div>
      <div class="ask-ai-typing-dot"></div>
    </div>
  `;
  messagesDiv.appendChild(typingDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function hideAskAITyping() {
  const typing = document.getElementById('askAITyping');
  if (typing) typing.remove();
}

async function sendAskAIMessage() {
  console.log('sendAskAIMessage called');
  const input = document.getElementById('askAIInput');
  const text = input.value.trim();
  console.log('Text:', text);
  if (!text) {
    console.log('No text, returning');
    return;
  }
  
  // LOCK voice mode while processing
  voiceModeLocked = true;
  askiIsProcessing = true;
  stopVoiceModeListening();
  updateVoiceModeIndicator('processing');
  
  // Save for retry
  lastUserMessage = text;
  
  addAskAIMessage(text, true);
  input.value = '';
  input.style.height = 'auto'; // Reset textarea height
  updateAskAICharCount();
  
  showAskAITyping();
  
  // Get context from Supabase (v0.9.58 - Dynamic Context)
  let contextForAI = null;
  try {
    const supabaseContext = await getSupabaseContext(text, {
      limit: 20,
      recentHours: 24,
      searchEnabled: true
    });
    contextForAI = formatContextForAI(supabaseContext);
    if (contextForAI) {
      console.log(' Context loaded for ASKI');
    }
  } catch (e) {
    console.warn('Context fetch skipped:', e.message);
  }
  
  // Legacy: Also try Syntrise CORE if enabled
  let syntriseContext = [];
  if (window.SyntriseCore && SYNTRISE_CONFIG?.ENABLED) {
    try {
      syntriseContext = await getSyntriseContext(text);
      console.log('Syntrise context:', syntriseContext?.length || 0, 'drops found');
    } catch (e) {
      console.warn('Syntrise context fetch skipped');
    }
  }
  
  console.log('Sending to:', AI_API_URL);
  
  // v2 API: Send structured context, server handles formatting
  const INJECT_CONTEXT_INTO_MESSAGE = false; // v2: Server handles context
  
  // Prepare context object for server
  let contextObject = null;
  try {
    if (supabaseContext?.recent?.length || supabaseContext?.relevant?.length) {
      contextObject = {
        recent: supabaseContext.recent || [],
        relevant: supabaseContext.relevant || []
      };
    }
  } catch (e) {
    console.warn('Context preparation error:', e);
  }
  
  try {
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'chat',
        text: text,  // Clean text, no injection
        history: askAIMessages.slice(-10),
        syntriseContext: syntriseContext, // Legacy
        dropContext: contextObject, // v2: Structured context for server
        stream: STREAMING_ENABLED,
		enableTools: false, // v2: Enable Tool Calling
        userId: currentUser?.id // v3: For CORE Memory integration
      })
    });
    
    console.log('Response status:', response.status);
	const contentType = response.headers.get('content-type') || '';

	if (STREAMING_ENABLED && contentType.includes('text/event-stream')) {
	hideAskAITyping();
	try {
	await handleStreamingResponse(response);
	} catch (e) {
	console.error('Streaming error:', e);
	}
	return;
	}
    const data = await response.json();
    console.log('Response data:', data);
    
    // Log tools used (v2)
    if (data.toolsUsed?.length) {
      console.log(' AI used tools:', data.toolsUsed.join(', '));
    }
    
    hideAskAITyping();
    
    if (data.success && data.result) {
      addAskAIMessage(data.result, false);
      
      // Handle AI-initiated drop creation (v2 Tool Calling)
      // Only create if AutoDrop is enabled OR user explicitly asked
      if (data.createDrop?.action === 'create_drop') {
        const autoDropEnabled = isAutoDropEnabled();
        
        if (autoDropEnabled) {
          const dropText = data.createDrop.text;
          const dropCategory = data.createDrop.category || 'inbox';
          
          // Create the drop
          const now = new Date();
          const newIdea = {
            id: Date.now(),
            text: dropText,
            category: dropCategory,
            date: now.toLocaleDateString('ru-RU'),
            time: now.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' }),
            timestamp: now.toISOString(),
            aiGenerated: true
          };
          
          ideas.unshift(newIdea);
          save(newIdea);
          render();
          counts();
          
          console.log(' AI created drop:', dropText.substring(0, 50) + '...');
          toast(`Aski created: ${dropCategory}`, 'success');
        } else {
          console.log(' AI wanted to create drop but AutoDrop is OFF');
        }
      }
    } else {
      console.log('Error in response:', data);
      addAskAIMessage('Sorry, I could not process your request. ' + (data.error || ''), false);
      // Unlock on error if no auto-speak
      if (!isAutoSpeakEnabled()) {
        unlockVoiceMode();
      }
    }
  } catch (error) {
    hideAskAITyping();
    console.error('Ask AI error:', error);
    addErrorMessage('Connection error. Please check your internet connection.');
    // Unlock on error
    unlockVoiceMode();
  }
}

// Add error message with Retry button
function addErrorMessage(text) {
  const messagesDiv = document.getElementById('askAIMessages');
  const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  
  const msgDiv = document.createElement('div');
  msgDiv.className = 'ask-ai-message ai error';
  msgDiv.innerHTML = `
    <div class="ask-ai-bubble" style="background: #FEE2E2; color: #DC2626;">${text}</div>
    <div class="ask-ai-actions">
      <button class="ask-ai-action-btn retry-btn" onclick="retryLastMessage(this)" style="border-color: #DC2626; color: #DC2626;">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>
        Retry
      </button>
    </div>
    <div class="ask-ai-time">${time}</div>
  `;
  
  messagesDiv.appendChild(msgDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

// Retry last message
function retryLastMessage(btn) {
  if (!lastUserMessage) {
    toast('No message to retry');
    return;
  }
  
  // Remove error message
  const errorMsg = btn.closest('.ask-ai-message');
  if (errorMsg) errorMsg.remove();
  
  // Set input and send
  document.getElementById('askAIInput').value = lastUserMessage;
  sendAskAIMessage();
}

function createDropFromAI(btn) {
  console.log('createDropFromAI called');
  
  // Check if already created
  if (btn.classList.contains('created')) {
    toast('Drop already created');
    return;
  }
  
  const msgDiv = btn.closest('.ask-ai-message');
  if (!msgDiv) {
    console.error('Could not find message div');
    return;
  }
  
  const bubble = msgDiv.querySelector('.ask-ai-bubble');
  if (!bubble) {
    console.error('Could not find bubble');
    return;
  }
  
  const text = bubble.textContent;
  const isUserMessage = msgDiv.classList.contains('user');
  
  console.log('Creating drop:', text.substring(0, 50) + '...');
  
  const drop = {
    id: Date.now(),
    text: text,
    category: 'inbox',
    timestamp: new Date().toISOString(),
    date: new Date().toLocaleDateString('ru-RU'),
    time: new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}),
    isMedia: false
  };
  
  ideas.unshift(drop);
  save(drop);
  render();
  counts();
  
  // Update button to show "created" state
  btn.classList.add('created');
  btn.innerHTML = `
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
    Drop created
  `;
  btn.blur(); // Remove focus to prevent red outline
  
  console.log('Drop created successfully');
  
  // Sync with Syntrise if enabled
  if (typeof syncDropToSyntrise === 'function') {
    syncDropToSyntrise(drop);
  }
  
  toast('Drop created');
}

function copyAIResponse(btn) {
  const bubble = btn.closest('.ask-ai-message').querySelector('.ask-ai-bubble');
  const text = bubble.textContent;
  
  navigator.clipboard.writeText(text).then(() => {
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
  }).catch(() => {
    toast('Failed to copy');
  });
}

function toggleAskAIVoice() {
  const btn = document.getElementById('askAIVoiceBtn');
  
  // === VOICE MODE ENABLED ===
  if (isVoiceModeEnabled()) {
    // If sleeping - wake up
    if (voiceModeSleeping) {
      wakeVoiceMode();
      return;
    }
    
    // If listening/active - go to sleep (user wants to stop)
    if (voiceModeRecognition || btn.classList.contains('recording')) {
      enterVoiceModeSleep();
      return;
    }
    
    // If locked (Aski speaking/processing) - just show message
    if (voiceModeLocked || askiIsProcessing || askiIsSpeaking) {
      toast('Wait for Aski to finish');
      return;
    }
    
    // Otherwise start listening
    wakeVoiceMode();
    return;
  }
  
  // === VOICE MODE DISABLED (manual mode) ===
  if (btn.classList.contains('recording')) {
    if (askAIVoiceRecognition) {
      askAIVoiceRecognition.stop();
    }
    btn.classList.remove('recording');
  } else {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
      toast('Voice not supported in this browser');
      return;
    }
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    askAIVoiceRecognition = new SpeechRecognition();
    askAIVoiceRecognition.continuous = false;
    askAIVoiceRecognition.interimResults = false;
    askAIVoiceRecognition.lang = navigator.language || 'en-US';
    
    askAIVoiceRecognition.onstart = () => {
      btn.classList.add('recording');
    };
    
    askAIVoiceRecognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      document.getElementById('askAIInput').value = transcript;
      updateAskAICharCount();
    };
    
    askAIVoiceRecognition.onend = () => {
      btn.classList.remove('recording');
    };
    
    askAIVoiceRecognition.onerror = () => {
      btn.classList.remove('recording');
      toast('Voice recognition error');
    };
    
    askAIVoiceRecognition.start();
  }
}

// Ask AI input event listeners
document.addEventListener('DOMContentLoaded', () => {
  const askAIInput = document.getElementById('askAIInput');
  if (askAIInput) {
    askAIInput.addEventListener('input', updateAskAICharCount);
    askAIInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !document.getElementById('askAISendBtn').disabled) {
        sendAskAIMessage();
      }
    });
  }
  
  // Load API key
  // (API key is stored on server, not needed here)
  
  // Swipe down to close Ask AI - ONLY on handle and header (not message area)
  // This prevents conflict with system notification panel and allows normal scroll
  const askAIHandle = document.querySelector('.ask-ai-handle');
  const askAIHeader = document.querySelector('.ask-ai-header');
  let swipeStartY = 0;
  
  function handleSwipeStart(e) {
    swipeStartY = e.touches[0].clientY;
  }
  
  function handleSwipeEnd(e) {
    const swipeEndY = e.changedTouches[0].clientY;
    if (swipeEndY - swipeStartY > 50) { // Reduced threshold for header area
      closeAskAI();
    }
  }
  
  // Attach to handle bar
  if (askAIHandle) {
    askAIHandle.addEventListener('touchstart', handleSwipeStart);
    askAIHandle.addEventListener('touchend', handleSwipeEnd);
  }
  
  // Attach to header
  if (askAIHeader) {
    askAIHeader.addEventListener('touchstart', handleSwipeStart);
    askAIHeader.addEventListener('touchend', handleSwipeEnd);
  }
  
  // Swipe UP on Ask AI FAB button to open chat
  const fabAskAI = document.getElementById('fabAskAI');
  let fabStartY = 0;
  fabAskAI.addEventListener('touchstart', (e) => {
    fabStartY = e.touches[0].clientY;
  });
  fabAskAI.addEventListener('touchend', (e) => {
    const fabEndY = e.changedTouches[0].clientY;
    if (fabStartY - fabEndY > 30) { // Swipe up threshold
      openAskAI();
    }
  });
});

// ============================================
// PLUS MENU FUNCTIONS
// ============================================

function togglePlusMenu(){
  const menu=document.getElementById('plusMenu');
  const backdrop=document.getElementById('plusBackdrop');
  
  if(menu.classList.contains('show')){
    closePlusMenu();
  } else {
    menu.classList.add('show');
    backdrop.classList.add('show');
  }
}

function closePlusMenu(){
  document.getElementById('plusMenu').classList.remove('show');
  document.getElementById('plusBackdrop').classList.remove('show');
}

// TEXT NOTE
function openTextInput(){
  closePlusMenu();
  document.getElementById('textInputModal').classList.add('show');
  setTimeout(()=>{
    document.getElementById('textInputArea').focus();
  },100);
}

function closeTextInput(){
  document.getElementById('textInputModal').classList.remove('show');
  document.getElementById('textInputArea').value='';
}

function saveTextNote(){
  const text=document.getElementById('textInputArea').value.trim();
  if(!text){
    toast('Please enter some text','error');
    return;
  }
  
  const category=detectCat(text);
  const idea={
    id:Date.now(),
    text:text,
    category:category,
    timestamp:new Date().toISOString(),
    date:new Date().toLocaleDateString('ru-RU'),
    time:new Date().toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'})
  };
  ideas.push(idea);
  save();
  playDropSound();
  toast('Note saved!','success');
  closeTextInput();
  resetToShowAll();
}

// PASTE LINK
async function pasteLink(){
  closePlusMenu();
  
  try{
    // Try to read from clipboard
    const text=await navigator.clipboard.readText();
    
    if(text&&isUrl(text.trim())){
      createLinkCard(text.trim());
    } else if(text&&text.trim()){
      // Not a URL but has text - ask user
      toast('Clipboard: "'+text.substring(0,30)+'..."','info');
      // Create as text note with the link
      const category=detectCat(text);
      const idea={
        id:Date.now(),
        text:text.trim(),
        category:category,
        timestamp:new Date().toISOString(),
        date:new Date().toLocaleDateString('ru-RU'),
        time:new Date().toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'})
      };
      ideas.push(idea);
      save();
      playDropSound();
      toast('Saved from clipboard!','success');
      resetToShowAll();
    } else {
      toast('Clipboard is empty','error');
    }
  }catch(err){
    // Clipboard API not available or denied
    toast('Cannot access clipboard. Please paste manually.','error');
    openTextInput();
  }
}

function isUrl(str){
  return /^(https?:\/\/|www\.)/i.test(str);
}

function createLinkCard(url){
  // Ensure URL has protocol
  let href=url;
  if(url.startsWith('www.'))href='https://'+url;
  
  const idea={
    id:Date.now(),
    text:href,
    category:'link',
    timestamp:new Date().toISOString(),
    date:new Date().toLocaleDateString('ru-RU'),
    time:new Date().toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'}),
    isLink:true
  };
  ideas.push(idea);
  save();
  playDropSound();
  toast('Link saved!','success');
  resetToShowAll();
}

// UPLOAD IMAGE
function uploadImage(){
  closePlusMenu();
  document.getElementById('imageUpload').click();
}

function handleUploadedImage(e){
  const file=e.target.files[0];
  if(!file)return;
  
  toast('Processing image...','info');
  
  // Compress image before saving
  const img=new Image();
  img.onload=function(){
    const canvas=document.createElement('canvas');
    const maxSize=1200;
    let w=img.width,h=img.height;
    
    if(w>maxSize||h>maxSize){
      if(w>h){h=Math.round(h*maxSize/w);w=maxSize;}
      else{w=Math.round(w*maxSize/h);h=maxSize;}
    }
    
    canvas.width=w;
    canvas.height=h;
    const ctx=canvas.getContext('2d');
    ctx.drawImage(img,0,0,w,h);
    
    const dataUrl=canvas.toDataURL('image/jpeg',0.7);
    
    // Save as uploaded image (no geo)
    const idea={
      id:Date.now(),
      text:'',
      notes:'',
      image:dataUrl,
      category:'photo',
      timestamp:new Date().toISOString(),
      date:new Date().toLocaleDateString('ru-RU'),
      time:new Date().toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'}),
      geo:null,
      isMedia:true,
      isUploaded:true
    };
    ideas.push(idea);
    save();
    playDropSound();
    toast('Image uploaded!','success');
    resetToShowAll();
  };
  img.onerror=function(){
    toast('Failed to load image','error');
  };
  
  const reader=new FileReader();
  reader.onload=function(ev){
    img.src=ev.target.result;
  };
  reader.onerror=function(){
    toast('Failed to read image','error');
  };
  reader.readAsDataURL(file);
  e.target.value='';
}

// ============================================
// FILE UPLOAD (v0.8.2)
// ============================================

const MAX_FILE_SIZE = 50 * 1024; // 50KB limit
const SUPPORTED_TEXT_EXTENSIONS = ['txt', 'md', 'csv', 'json'];

function uploadFile(){
  closePlusMenu();
  document.getElementById('fileUpload').click();
}

function handleUploadedFile(e){
  const file = e.target.files[0];
  if (!file) return;
  
  // Check extension
  const ext = file.name.split('.').pop().toLowerCase();
  if (!SUPPORTED_TEXT_EXTENSIONS.includes(ext)) {
    toast('Supported: .txt, .md, .csv, .json', 'error');
    e.target.value = '';
    return;
  }
  
  // Check size
  if (file.size > MAX_FILE_SIZE) {
    const sizeKB = Math.round(file.size / 1024);
    toast(`File too large (${sizeKB}KB). Max: 50KB`, 'error');
    e.target.value = '';
    return;
  }
  
  toast('Reading file...', 'info');
  
  const reader = new FileReader();
  reader.onload = function(ev) {
    const text = ev.target.result;
    
    if (!text || text.trim().length === 0) {
      toast('File is empty', 'error');
      return;
    }
    
    // Create drop from file content
    const idea = {
      id: Date.now(),
      text: text.trim(),
      category: detectCat(text.trim()),
      timestamp: new Date().toISOString(),
      date: new Date().toLocaleDateString('ru-RU'),
      time: new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}),
      isImported: true,
      sourceFile: file.name
    };
    
    ideas.push(idea);
    save();
    
    const charCount = text.length;
    toast(`Imported! ${charCount} chars from ${file.name}`, 'success');
    resetToShowAll();
  };
  
  reader.onerror = function() {
    toast('Failed to read file', 'error');
  };
  
  reader.readAsText(file);
  e.target.value = '';
}

function aiProcess(id){toast('AI processing coming soon!','info');}
function openCatModal(id){
  catChangeId=id;
  const item=ideas.find(x=>x.id===id);
  const isMedia=item?.isMedia;
  const grid=document.querySelector('#catModal .cat-grid');
  // Show only appropriate categories
  grid.querySelectorAll('.cat-opt').forEach(btn=>{
    const cat=btn.dataset.cat;
    if(isMedia){
      // Media items can only go to sketch, scan, inbox
      btn.style.display=MEDIA_CATS.includes(cat)?'block':'none';
    } else {
      // Text items can go to all except sketch, scan
      btn.style.display=!CATS[cat]?.isMedia?'block':'none';
    }
  });
  document.getElementById('catModal').classList.add('show');
}
function closeCatModal(){document.getElementById('catModal').classList.remove('show');catChangeId=null;}
function changeCat(c){if(catChangeId){const i=ideas.find(x=>x.id===catChangeId);if(i){saveUndo('category',{id:i.id,previousCategory:i.category,newCategory:c});i.category=c;save();render();counts();toast('Moved to '+CATS[c].name,'success');}}closeCatModal();}
function reqDel(id){delId=id;document.getElementById('delModal').classList.add('show');}
function closeDelModal(){document.getElementById('delModal').classList.remove('show');delId=null;}
function confirmDel(){
  if(delId){
    const delItem=ideas.find(x=>x.id===delId);
    if(delItem) {
      saveUndo('delete',{...delItem});
      // Sync delete to Supabase (v0.9.58)
      if (syncEnabled && currentUser) {
        deleteDropFromServer(delId);
      }
    }
    ideas=ideas.filter(x=>x.id!==delId);
    save();
    activeCardId=null;
    render();
    counts();
    toast('Deleted','info');
  }
  closeDelModal();
}
function startEdit(id){if(editId)cancelEdit(editId);editId=id;activeCardId=id;document.body.classList.add('editing-mode');render();setTimeout(()=>{const card=document.querySelector('[data-id="'+id+'"]');const ta=card?.querySelector('.card-ta');if(ta){card.scrollIntoView({behavior:'smooth',block:'center'});ta.focus();}},100);}
function saveEdit(id){
  const card=document.querySelector('[data-id="'+id+'"]'),ta=card?.querySelector('.card-ta');
  if(ta){
    const t=ta.value.trim();
    if(t){
      const i=ideas.find(x=>x.id===id);
      if(i&&t!==i.text){
        saveUndo('edit',{id:i.id,previousText:i.text});
        i.text=t;
        i.category=detectCat(t);
        save();
        // Sync update to Supabase (v0.9.58)
        if (syncEnabled && currentUser) {
          syncDropToServer(i, 'update');
        }
        toast('Saved','success');
      }
    }
  }
  editId=null;
  document.body.classList.remove('editing-mode');
  render();
  counts();
}
function cancelEdit(id){editId=null;document.body.classList.remove('editing-mode');render();}
function openSendModal(id){sendId=id;document.getElementById('sendModal').classList.add('show');}
function closeSendModal(){document.getElementById('sendModal').classList.remove('show');sendId=null;}
function sendAI(){const i=ideas.find(x=>x.id===sendId);if(i){navigator.clipboard.writeText(i.text);window.open('https://claude.ai','_blank');toast('Copied to clipboard!','success');}closeSendModal();}
function shareNative(){const i=ideas.find(x=>x.id===sendId);if(i&&navigator.share)navigator.share({title:'DropLit',text:i.text}).catch(()=>{});else if(i){navigator.clipboard.writeText(i.text);toast('Copied','success');}closeSendModal();}
function sendMail(){const i=ideas.find(x=>x.id===sendId);if(i)window.open('mailto:?subject='+encodeURIComponent('DropLit: '+CATS[i.category].name)+'&body='+encodeURIComponent(i.text));closeSendModal();}
function copyClip(){const i=ideas.find(x=>x.id===sendId);if(i){navigator.clipboard.writeText(i.text);toast('Copied','success');}closeSendModal();}
function copyIdea(id){const i=ideas.find(x=>x.id===id);if(i){navigator.clipboard.writeText(i.text);toast('Copied','success');}}

function duplicateCard(id){
  const item=ideas.find(x=>x.id===id);
  if(!item)return;
  
  // Create copy with new timestamp
  const now=new Date();
  const copy={
    id: Date.now(),
    text: item.text,
    category: item.category,
    timestamp: now.toISOString(),
    date: now.toLocaleDateString('ru-RU'),
    time: now.toLocaleTimeString('ru-RU',{hour:'2-digit',minute:'2-digit'}),
    markers: item.markers ? [...item.markers] : [],
    notes: item.notes || ''
  };
  
  // Copy media if exists
  if(item.isMedia){
    copy.isMedia = true;
    copy.image = item.image;
  }
  
  ideas.push(copy);
  save();
  activeCardId=null;
  render();
  
  toast('Duplicated!','success');
  
  // Scroll to the new card at bottom
  setTimeout(()=>{
    const card=document.querySelector('[data-id="'+copy.id+'"]');
    if(card)card.scrollIntoView({behavior:'smooth',block:'center'});
  },100);
}
function save(newDrop){
  try{
    const data=JSON.stringify(ideas);
    localStorage.setItem('droplit_ideas',data);
    
    // Sync to Supabase (v0.9.58)
    if (newDrop && syncEnabled && currentUser) {
      syncDropToServer(newDrop, 'create');
    }
    
    // Legacy: Sync to Syntrise CORE
    if (newDrop && window.SyntriseCore) {
      syncDropToCore(newDrop);
    }
  }catch(err){
    // Storage full - usually QuotaExceededError
    const sizeMB=(JSON.stringify(ideas).length/1024/1024).toFixed(1);
    toast('Storage full ('+sizeMB+'MB)! Delete old photos','error');
  }
}
function smartTime(i){const td=new Date().toLocaleDateString('ru-RU'),yd=new Date(Date.now()-864e5).toLocaleDateString('ru-RU');if(i.date===td)return i.time;if(i.date===yd)return'Yesterday '+i.time;const p=i.date.split('.');return p[0]+'.'+p[1]+' '+i.time;}

// NEW badge for drops < 15 minutes old
function isNewDrop(i) {
  if (!i.date || !i.time) return false;
  const [d, m, y] = i.date.split('.');
  const [h, min] = i.time.split(':');
  const created = new Date(+y, +m - 1, +d, +h, +min);
  const diff = Date.now() - created.getTime();
  return diff < 15 * 60 * 1000; // 15 minutes
}
function filtered(){
  let f=[...ideas].filter(x=>x&&x.date); // Filter out invalid entries
  
  // Apply search filter
  if(searchMode && searchQuery) {
    f = f.filter(x => {
      const text = (x.text || '').toLowerCase();
      const notes = (x.notes || '').toLowerCase();
      return text.includes(searchQuery) || notes.includes(searchQuery);
    });
    return f; // Skip other filters when searching
  }
  
  if(curTime==='today')f=f.filter(x=>isToday(x.date));
  else if(curTime==='7days')f=f.filter(x=>inDays(x.date,7));
  if(curCat!=='all')f=f.filter(x=>x.category===curCat);
  return f;
}

function render(){
  const wrap=document.getElementById('ideasList'),empty=document.getElementById('emptyState'),list=filtered();
  if(!list.length){wrap.innerHTML='';empty.style.display='flex';return;}
  empty.style.display='none';
  const grp={};for(const i of list){if(!grp[i.date])grp[i.date]=[];grp[i.date].push(i);}
  let dates=Object.keys(grp).sort((a,b)=>sortAsc?parseD(a)-parseD(b):parseD(b)-parseD(a));
  let h='';
  const td=new Date().toLocaleDateString('ru-RU'),yd=new Date(Date.now()-864e5).toLocaleDateString('ru-RU');
  for(const d of dates){
    let lbl=d;if(d===td)lbl='Today';else if(d===yd)lbl='Yesterday';
    h+='<div class="date-sep">'+lbl+'</div>';
    // Sort within day by timestamp (precise to millisecond)
    let dayIdeas=grp[d].slice().sort((a,b)=>{
      // Use timestamp for precise sorting (includes seconds/ms)
      const tsA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
      const tsB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
      return sortAsc ? tsA - tsB : tsB - tsA;
    });
    for(const i of dayIdeas){
      const isActive=activeCardId===i.id;
      const isEditing=editId===i.id;
      const isSelected=selectedIds.includes(i.id);
      const cc=i.isMedia?0:(i.text?.length||0);
      const isTruncated=cc>1000; /* ~20 lines */
      h+='<div class="card'+(isActive?' active':'')+(isEditing?' editing':'')+(isSelected?' selected':'')+'" data-id="'+i.id+'" onclick="handleCardClick('+i.id+',event)" ontouchstart="cardTouchStart('+i.id+',event)" ontouchmove="cardTouchMove(event)" ontouchend="cardTouchEnd()" ontouchcancel="cardTouchEnd()" oncontextmenu="return false;">';
      h+='<div class="card-checkbox">'+(isSelected?'V':'')+'</div>';
      h+='<div class="card-head"><span class="card-cat '+i.category+'" onclick="openCatModal('+i.id+')">'+(CATS[i.category]?.single||'INBOX')+'</span>';
      // Markers (right after category)
      if(i.markers&&i.markers.length){
        h+='<span class="card-marker">'+i.markers.map(m=>MARKERS[m]||'').join('')+'</span>';
      }
      // Counter: text=chars, audio=duration, image=dimensions
      if(i.category==='audio'){
        h+='<span class="card-chars">'+formatDuration(i.duration||0)+'</span>';
      } else if(i.isMedia&&i.imageDimensions){
        h+='<span class="card-chars">'+i.imageDimensions+'</span>';
      } else if(i.isMedia){
        h+='<span class="card-chars">IMG</span>';
      } else {
        h+='<span class="card-chars">'+cc+'</span>';
      }
      if(isNewDrop(i))h+='<span class="new-badge">NEW</span>';
      h+='<span class="card-time">'+smartTime(i)+'</span>';
      h+='</div>';
      // Audio player
      if(i.category==='audio'&&i.audioData){
        h+='<div class="card-audio-player" data-audio-id="'+i.id+'">';
        h+='<div class="audio-waveform" id="waveform-'+i.id+'">';
        for(let bi=0;bi<30;bi++){
          const bh=8+Math.random()*32;
          h+='<div class="audio-waveform-bar" style="height:'+bh+'px"></div>';
        }
        h+='</div>';
        h+='<div class="audio-controls">';
        h+='<button class="audio-btn" onclick="seekAudio('+i.id+',-10,event)">&lt;&lt;</button>';
        h+='<button class="audio-btn play" onclick="togglePlayAudio('+i.id+',event)" id="playbtn-'+i.id+'">PLAY</button>';
        h+='<button class="audio-btn" onclick="seekAudio('+i.id+',10,event)">&gt;&gt;</button>';
        h+='</div>';
        h+='<div class="audio-time"><span id="audiotime-'+i.id+'">0:00</span><span>'+formatDuration(i.duration||0)+'</span></div>';
        if(i.audioFormat)h+='<div class="audio-format">'+i.audioFormat.toUpperCase()+'</div>';
        h+='</div>';
      } else if(i.isMedia&&i.image){
        h+='<img class="card-image" src="'+i.image+'" alt="Photo" loading="lazy">';
        // Show date/geo and notes under image
        h+='<div class="card-media-meta">';
        h+='<span>'+i.date+' '+i.time+'</span>';
        if(i.geo)h+='<span>'+i.geo.lat.toFixed(2)+','+i.geo.lng.toFixed(2)+'</span>';
        h+='</div>';
        if(i.notes){
          const notesLong = i.notes.length > 100;
          h+='<div class="card-notes'+(notesLong?'':' expanded')+'" id="notes-'+i.id+'">'+esc(i.notes)+'</div>';
          if(notesLong)h+='<div class="card-more show" onclick="toggleNotesExpand('+i.id+',event)">Show more</div>';
        }
      }
      if(i.text){
        h+='<div class="card-text'+(isTruncated?' truncated':'')+'" id="text-'+i.id+'">'+linkify(i.text)+'</div>';
        if(isTruncated)h+='<div class="card-more show" onclick="toggleExpand('+i.id+',event)">Show more</div>';
      }
      if(!i.isMedia){
        h+='<div class="card-edit"><textarea class="card-ta">'+esc(i.text||'')+'</textarea></div>';
      }
      h+='<div class="card-actions">';
      if(i.category==='audio'){
        h+='<button class="act ai" onclick="transcribeAudio('+i.id+')">Transcribe</button>';
        h+='<button class="act act-tts" onclick="speakDrop('+i.id+',event)">Read</button>';
        h+='<button class="act" onclick="openSendModal('+i.id+')">Share</button>';
        h+='<button class="act" onclick="copyIdea('+i.id+')">Copy</button>';
        h+='<button class="act" onclick="duplicateCard('+i.id+')">Dup</button>';
        h+='<button class="act danger" onclick="reqDel('+i.id+')">Del</button>';
      } else if(i.isMedia){
        h+='<button class="act" onclick="viewImage('+i.id+',event)">View</button>';
        h+='<button class="act act-tts" onclick="speakDrop('+i.id+',event)">Read</button>';
        h+='<button class="act" onclick="openSendModal('+i.id+')">Share</button>';
        h+='<button class="act" onclick="copyIdea('+i.id+')">Copy</button>';
        h+='<button class="act" onclick="duplicateCard('+i.id+')">Dup</button>';
        h+='<button class="act danger" onclick="reqDel('+i.id+')">Del</button>';
      } else {
        h+='<button class="act ai" onclick="openAITools('+i.id+')">AI Tools</button>';
        h+='<button class="act act-tts" onclick="speakDrop('+i.id+',event)">Read</button>';
        h+='<button class="act" onclick="startEdit('+i.id+')">Edit</button>';
        h+='<button class="act" onclick="openSendModal('+i.id+')">Share</button>';
        h+='<button class="act" onclick="copyIdea('+i.id+')">Copy</button>';
        h+='<button class="act" onclick="duplicateCard('+i.id+')">Dup</button>';
        h+='<button class="act danger" onclick="reqDel('+i.id+')">Del</button>';
      }
      h+='</div>';
      if(!i.isMedia){
        h+='<div class="card-edit-actions"><button class="act primary" onclick="saveEdit('+i.id+')">Save</button><button class="act secondary" onclick="cancelEdit('+i.id+')">Cancel</button></div>';
      }
      // Markers panel at bottom
      h+='<div class="card-markers">';
      for(const mk of Object.keys(MARKERS)){
        const isMarked=i.markers&&i.markers.includes(mk);
        h+='<button class="marker-btn'+(isMarked?' active':'')+'" onclick="toggleMarker('+i.id+',\''+mk+'\',event)">'+MARKERS[mk]+'</button>';
      }
      h+='</div>';
      h+='</div>';
    }
  }
  wrap.innerHTML=h;
}

function esc(t){const d=document.createElement('div');d.textContent=t;return d.innerHTML;}

function linkify(text){
  // First escape HTML, then convert URLs to links
  const escaped=esc(text);
  // URL regex - matches http, https, and www
  const urlRegex=/(\b(https?:\/\/|www\.)[^\s<]+[^\s<.,;:!?\)\]'"])/gi;
  return escaped.replace(urlRegex,(url)=>{
    let href=url;
    if(url.startsWith('www.'))href='https://'+url;
    return '<a href="'+href+'" target="_blank" rel="noopener" onclick="event.stopPropagation()">'+url+'</a>';
  });
}

function toggleExpand(id,e){
  e.stopPropagation();
  const textEl=document.getElementById('text-'+id);
  const btn=e.target;
  if(textEl.classList.contains('expanded')){
    textEl.classList.remove('expanded');
    textEl.classList.add('truncated');
    btn.textContent='Show more';
  } else {
    textEl.classList.add('expanded');
    textEl.classList.remove('truncated');
    btn.textContent='Show less';
  }
}

function toggleNotesExpand(id,e){
  e.stopPropagation();
  const notesEl=document.getElementById('notes-'+id);
  const btn=e.target;
  if(notesEl.classList.contains('expanded')){
    notesEl.classList.remove('expanded');
    btn.textContent='Show more';
  } else {
    notesEl.classList.add('expanded');
    btn.textContent='Show less';
  }
}

let currentImageId=null;
let allMediaIds=[];
let currentMediaIndex=0;
let currentImageOrientation='';

// ============================================
// ZOOM/PAN SYSTEM (iOS/Android standard)
// ============================================

// State
let scale = 1;           // Current zoom level (1 = fit-to-screen)
let offsetX = 0;         // Pan offset X
let offsetY = 0;         // Pan offset Y
const MIN_SCALE = 1;     // Fit to screen
const MAX_SCALE = 4;     // Maximum zoom
const DOUBLE_TAP_SCALE = 2; // Double-tap zoom level

// Touch tracking
let lastTapTime = 0;
let lastTapX = 0;
let lastTapY = 0;

// Pinch state
let isPinching = false;
let pinchStartScale = 1;
let pinchStartDistance = 0;
let pinchCenterX = 0;
let pinchCenterY = 0;

// Pan state  
let isPanning = false;
let panStartX = 0;
let panStartY = 0;
let panStartOffsetX = 0;
let panStartOffsetY = 0;

// Swipe state
let swipeStartX = 0;
let swipeStartY = 0;
let isSwiping = false;

// Caption edit state
let isEditingCaption=false;

function getMediaItems(){
  return ideas.filter(i=>i.isMedia&&i.image);
}

function viewImage(id,e){
  if(e)e.stopPropagation();
  const item=ideas.find(x=>x.id===id);
  if(!item||!item.image)return;
  
  allMediaIds=getMediaItems().map(i=>i.id);
  currentMediaIndex=allMediaIds.indexOf(id);
  currentImageId=id;
  isEditingCaption=false;
  
  // Reset zoom/pan
  resetTransform();
  
  showImagePanel();
  loadCurrentImage();
  updateNavigation();
  updatePhotoMarkersButton();
  
  document.getElementById('imageViewer').classList.add('show');
  
  const content=document.getElementById('imageViewerContent');
  content.addEventListener('touchstart',handleTouchStart,{passive:false});
  content.addEventListener('touchmove',handleTouchMove,{passive:false});
  content.addEventListener('touchend',handleTouchEnd,{passive:false});
}

function loadCurrentImage(){
  const item=ideas.find(x=>x.id===currentImageId);
  if(!item)return;
  
  const img=document.getElementById('imageViewerImg');
  img.classList.remove('portrait','landscape','zoomed');
  img.style.opacity = '1';
  
  // Reset transform
  resetTransform();
  applyTransform(false);
  
  // Detect orientation
  const tempImg=new Image();
  tempImg.onload=function(){
    currentImageOrientation=(this.height>this.width)?'portrait':'landscape';
    img.classList.add(currentImageOrientation);
  };
  tempImg.src=item.image;
  img.src=item.image;
  
  // Meta info
  let meta='<span>'+item.date+' '+item.time+'</span>';
  if(item.geo){
    meta+='<span>'+item.geo.lat.toFixed(4)+', '+item.geo.lng.toFixed(4)+'</span>';
  }
  document.getElementById('imageMeta').innerHTML=meta;
  
  // Caption display
  updateCaptionDisplay(item);
  
  // Reset to view mode
  showImagePanel();
}

function updateCaptionDisplay(item){
  const display=document.getElementById('imageCaptionDisplay');
  if(item.notes&&item.notes.trim()){
    display.textContent=item.notes;
    display.classList.remove('empty');
  } else {
    display.textContent='No caption';
    display.classList.add('empty');
  }
}

function showImagePanel(){
  isEditingCaption=false;
  
  // Show caption row, hide edit area
  const captionRow=document.querySelector('.image-caption-row');
  const notesWrap=document.getElementById('imageNotesWrap');
  
  if(captionRow) captionRow.style.display='flex';
  if(notesWrap) notesWrap.classList.remove('editing');
}

function updateNavigation(){
  const counter=document.getElementById('imageCounter');
  const prevBtn=document.getElementById('imgNavPrev');
  const nextBtn=document.getElementById('imgNavNext');
  
  counter.textContent=(currentMediaIndex+1)+' / '+allMediaIds.length;
  
  if(allMediaIds.length>1){
    prevBtn.classList.toggle('show',currentMediaIndex>0);
    nextBtn.classList.toggle('show',currentMediaIndex<allMediaIds.length-1);
  } else {
    prevBtn.classList.remove('show');
    nextBtn.classList.remove('show');
  }
}

function navigateImage(direction){
  const newIndex=currentMediaIndex+direction;
  if(newIndex<0||newIndex>=allMediaIds.length)return;
  
  if(isEditingCaption){
    saveCaption();
  }
  
  // Reset zoom before navigating
  resetTransform();
  
  const img = document.getElementById('imageViewerImg');
  
  // Quick fade transition for button navigation
  img.style.transition = 'opacity 0.15s ease-out';
  img.style.opacity = '0';
  
  setTimeout(() => {
    currentMediaIndex=newIndex;
    currentImageId=allMediaIds[currentMediaIndex];
    loadCurrentImageNoReset();
    
    img.style.transition = 'opacity 0.15s ease-out';
    img.style.opacity = '1';
    updateNavigation();
    updatePhotoMarkersButton();
  }, 100);
}

function loadCurrentImageNoReset(){
  const item=ideas.find(x=>x.id===currentImageId);
  if(!item)return;
  
  const img=document.getElementById('imageViewerImg');
  img.classList.remove('portrait','landscape','zoomed');
  
  // Detect orientation
  const tempImg=new Image();
  tempImg.onload=function(){
    currentImageOrientation=(this.height>this.width)?'portrait':'landscape';
    img.classList.add(currentImageOrientation);
  };
  tempImg.src=item.image;
  img.src=item.image;
  
  // Meta info
  let meta='<span>'+item.date+' '+item.time+'</span>';
  if(item.geo){
    meta+='<span>'+item.geo.lat.toFixed(4)+', '+item.geo.lng.toFixed(4)+'</span>';
  }
  document.getElementById('imageMeta').innerHTML=meta;
  
  // Caption display
  updateCaptionDisplay(item);
  
  // Reset to view mode
  showImagePanel();
}

// ============================================
// TRANSFORM HELPERS
// ============================================

function resetTransform(){
  scale = 1;
  offsetX = 0;
  offsetY = 0;
}

function applyTransform(animate = true){
  const img = document.getElementById('imageViewerImg');
  if(!img) return;
  
  img.style.transition = animate ? 'transform 0.25s ease-out' : 'none';
  img.style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
  
  // Update class for CSS
  if(scale > 1){
    img.classList.remove('portrait','landscape');
    img.classList.add('zoomed');
  } else {
    img.classList.remove('zoomed');
    if(currentImageOrientation){
      img.classList.add(currentImageOrientation);
    }
  }
}

function clampOffset(){
  // Restrict pan so image doesn't go outside bounds
  const img = document.getElementById('imageViewerImg');
  const content = document.getElementById('imageViewerContent');
  if(!img || !content) return;
  
  const contentRect = content.getBoundingClientRect();
  
  // Calculate how much image can move based on scale
  // When scale=1, no movement allowed. When scale>1, allow proportional movement.
  const imgWidth = img.offsetWidth || 300;
  const imgHeight = img.offsetHeight || 300;
  
  const scaledWidth = imgWidth * scale;
  const scaledHeight = imgHeight * scale;
  
  // Max offset is half the overflow (scaled size - container size) / 2, divided by scale
  const maxOffsetX = Math.max(0, (scaledWidth - contentRect.width) / 2 / scale);
  const maxOffsetY = Math.max(0, (scaledHeight - contentRect.height) / 2 / scale);
  
  offsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, offsetX));
  offsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, offsetY));
}

// ============================================
// TOUCH HANDLERS
// ============================================

function handleTouchStart(e){
  const touches = e.touches;
  
  if(touches.length === 2){
    // PINCH START
    e.preventDefault();
    isPinching = true;
    isPanning = false;
    isSwiping = false;
    
    pinchStartScale = scale;
    pinchStartDistance = getPinchDistance(touches);
    
  } else if(touches.length === 1){
    // SINGLE TOUCH START
    const x = touches[0].clientX;
    const y = touches[0].clientY;
    
    if(scale > 1){
      // Zoomed in - start panning
      isPanning = true;
      isSwiping = false;
      panStartX = x;
      panStartY = y;
      panStartOffsetX = offsetX;
      panStartOffsetY = offsetY;
    } else {
      // Not zoomed - could be swipe or tap
      isSwiping = true;
      isPanning = false;
      swipeStartX = x;
      swipeStartY = y;
    }
    
    isPinching = false;
  }
}

function handleTouchMove(e){
  const touches = e.touches;
  
  if(isPinching && touches.length === 2){
    // PINCH MOVE
    e.preventDefault();
    
    const newDistance = getPinchDistance(touches);
    const scaleChange = newDistance / pinchStartDistance;
    let newScale = pinchStartScale * scaleChange;
    
    // Clamp scale
    newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
    scale = newScale;
    
    // Apply without animation for smooth feel
    applyTransform(false);
    
  } else if(isPanning && touches.length === 1){
    // PAN MOVE
    e.preventDefault();
    
    const x = touches[0].clientX;
    const y = touches[0].clientY;
    
    // Calculate delta and apply to offset (divide by scale for correct movement)
    offsetX = panStartOffsetX + (x - panStartX) / scale;
    offsetY = panStartOffsetY + (y - panStartY) / scale;
    
    // Clamp to bounds
    clampOffset();
    
    // Apply without animation
    applyTransform(false);
    
  } else if(isSwiping && touches.length === 1 && scale <= 1){
    // SWIPE MOVE - image follows finger
    const deltaX = touches[0].clientX - swipeStartX;
    const deltaY = touches[0].clientY - swipeStartY;
    
    // Only horizontal swipe
    if(Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 5){
      e.preventDefault();
      
      // Move image with finger (with resistance at edges)
      const img = document.getElementById('imageViewerImg');
      let moveX = deltaX;
      
      // Add resistance if at first/last image
      if((currentMediaIndex === 0 && deltaX > 0) || 
         (currentMediaIndex === allMediaIds.length - 1 && deltaX < 0)){
        moveX = deltaX * 0.3; // Rubber band effect
      }
      
      img.style.transition = 'none';
      img.style.transform = `translateX(${moveX}px)`;
      img.style.opacity = Math.max(0.5, 1 - Math.abs(deltaX) / 500);
    }
  }
}

function handleTouchEnd(e){
  const changedTouches = e.changedTouches;
  
  if(isPinching){
    // PINCH END
    isPinching = false;
    
    // Snap to 1 if close
    if(scale < 1.1){
      scale = 1;
      offsetX = 0;
      offsetY = 0;
    } else {
      // Clamp offset after pinch
      clampOffset();
    }
    
    applyTransform(true);
    return;
  }
  
  if(isPanning){
    // PAN END
    isPanning = false;
    
    // Check for double-tap while zoomed (to reset)
    const now = Date.now();
    const x = changedTouches[0].clientX;
    const y = changedTouches[0].clientY;
    const dx = Math.abs(x - panStartX);
    const dy = Math.abs(y - panStartY);
    
    // If didn't move much, might be a tap
    if(dx < 10 && dy < 10){
      if(now - lastTapTime < 300){
        // Double tap while zoomed - reset to fit
        e.preventDefault();
        resetTransform();
        applyTransform(true);
        lastTapTime = 0;
        return;
      }
      lastTapTime = now;
    }
    return;
  }
  
  if(isSwiping && scale <= 1){
    // SWIPE END (not zoomed)
    isSwiping = false;
    
    const x = changedTouches[0].clientX;
    const y = changedTouches[0].clientY;
    const deltaX = x - swipeStartX;
    const deltaY = y - swipeStartY;
    const img = document.getElementById('imageViewerImg');
    
    // Check for SWIPE (horizontal, more than 80px threshold)
    if(Math.abs(deltaX) > 80 && Math.abs(deltaY) < 100){
      // Animate current image out
      const direction = deltaX > 0 ? 1 : -1;
      const canNavigate = (direction > 0 && currentMediaIndex > 0) || 
                          (direction < 0 && currentMediaIndex < allMediaIds.length - 1);
      
      if(canNavigate){
        // Slide out completely
        img.style.transition = 'transform 0.2s ease-out, opacity 0.15s ease-out';
        img.style.transform = `translateX(${direction * 300}px)`;
        img.style.opacity = '0';
        
        setTimeout(() => {
          // Update index
          currentMediaIndex += (direction > 0 ? -1 : 1);
          currentImageId = allMediaIds[currentMediaIndex];
          
          // Position for slide in
          img.style.transition = 'none';
          img.style.transform = `translateX(${-direction * 100}px)`;
          
          loadCurrentImageNoReset();
          
          // Animate in
          setTimeout(() => {
            img.style.transition = 'transform 0.2s ease-out, opacity 0.15s ease-out';
            img.style.transform = 'translateX(0)';
            img.style.opacity = '1';
            updateNavigation();
            updatePhotoMarkersButton();
          }, 20);
        }, 150);
        return;
      }
    }
    
    // Return to center (swipe cancelled or at edge)
    img.style.transition = 'transform 0.25s ease-out, opacity 0.15s ease-out';
    img.style.transform = 'translateX(0)';
    img.style.opacity = '1';
    
    // Check for DOUBLE TAP (to zoom in)
    const now = Date.now();
    const tapDist = Math.sqrt(
      Math.pow(x - lastTapX, 2) + Math.pow(y - lastTapY, 2)
    );
    
    if(now - lastTapTime < 300 && tapDist < 30 && Math.abs(deltaX) < 10){
      // DOUBLE TAP - zoom to 2x centered on tap point
      e.preventDefault();
      doubleTapZoom(x, y);
      lastTapTime = 0;
      lastTapX = 0;
      lastTapY = 0;
    } else {
      lastTapTime = now;
      lastTapX = x;
      lastTapY = y;
    }
  }
  
  isSwiping = false;
  isPanning = false;
}

function doubleTapZoom(tapX, tapY){
  if(scale > 1){
    // Already zoomed - reset to fit
    resetTransform();
  } else {
    // Zoom to 2x, centered on tap point
    const content = document.getElementById('imageViewerContent');
    const img = document.getElementById('imageViewerImg');
    if(!content || !img) return;
    
    const rect = content.getBoundingClientRect();
    
    // Calculate offset to center on tap point
    const tapRelX = tapX - (rect.left + rect.width / 2);
    const tapRelY = tapY - (rect.top + rect.height / 2);
    
    // New scale
    scale = DOUBLE_TAP_SCALE;
    
    // Offset to keep tap point in same screen position
    offsetX = -tapRelX / scale;
    offsetY = -tapRelY / scale;
    
    // Clamp
    clampOffset();
  }
  
  applyTransform(true);
}

function getPinchDistance(touches){
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Caption editing
function startEditCaption(){
  isEditingCaption=true;
  const item=ideas.find(x=>x.id===currentImageId);
  
  document.getElementById('imageNotes').value=item?.notes||'';
  
  // Show edit area, hide caption row
  document.querySelector('.image-caption-row').style.display='none';
  document.getElementById('imageNotesWrap').classList.add('editing');
  
  setTimeout(()=>{
    document.getElementById('imageNotes').focus();
  },100);
}

function saveCaption(){
  const notes=document.getElementById('imageNotes').value.trim();
  const item=ideas.find(x=>x.id===currentImageId);
  if(item){
    item.notes=notes;
    save();
    render();
    updateCaptionDisplay(item);
  }
  showImagePanel();
}

function cancelEditCaption(){
  showImagePanel();
}

function handleImageViewerClick(e){
  if(e.target.classList.contains('image-viewer')){
    closeImageViewer();
  }
}

function closeImageViewer(){
  if(isEditingCaption){
    saveCaption();
  }
  
  // Reset zoom/pan state
  resetTransform();
  isPinching=false;
  isPanning=false;
  isSwiping=false;
  isEditingCaption=false;
  
  const content=document.getElementById('imageViewerContent');
  content.removeEventListener('touchstart',handleTouchStart);
  content.removeEventListener('touchmove',handleTouchMove);
  content.removeEventListener('touchend',handleTouchEnd);
  
  currentImageId=null;
  allMediaIds=[];
  document.getElementById('imageViewer').classList.remove('show');
  document.getElementById('imageViewerImg').src='';
}

function shareImage(){
  const item=ideas.find(x=>x.id===currentImageId);
  if(!item)return;
  
  fetch(item.image)
    .then(res=>res.blob())
    .then(blob=>{
      const file=new File([blob],'droplit-sketch.jpg',{type:'image/jpeg'});
      if(navigator.share&&navigator.canShare&&navigator.canShare({files:[file]})){
        navigator.share({
          files:[file],
          title:'DropLit Sketch',
          text:item.notes||'Shared from DropLit'
        }).catch(()=>{});
      } else {
        window.open(item.image,'_blank');
        toast('Use browser menu to share','info');
      }
    });
}

function saveImageToGallery(){
  const item=ideas.find(x=>x.id===currentImageId);
  if(!item)return;
  
  const link=document.createElement('a');
  link.href=item.image;
  link.download='droplit-sketch-'+item.id+'.jpg';
  link.click();
  toast('Image saved!','success');
}

// ============================================
// AI FUNCTIONS (v0.8.2)
// ============================================

async function ocrImage() {
  if (aiProcessing) {
    toast('AI is processing...', 'info');
    return;
  }
  
  const item = ideas.find(x => x.id === currentImageId);
  if (!item || !item.image) {
    toast('No image to process', 'error');
    return;
  }

  aiProcessing = true;
  showAILoading('ocr', false);

  try {
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'ocr', image: item.image }),
    });

    const data = await response.json();

    hideAILoading();

    if (data.success && data.result) {
      const existingNotes = item.notes || '';
      const ocrText = data.result;
      
      if (existingNotes) {
        item.notes = existingNotes + '\n\n--- OCR ---\n' + ocrText;
      } else {
        item.notes = ocrText;
      }
      
      if (!item.text) {
        item.text = ocrText.substring(0, 200) + (ocrText.length > 200 ? '...' : '');
      }
      
      save();
      
      const notesArea = document.getElementById('imgNotes');
      if (notesArea) notesArea.value = item.notes;
      
      toast('Text extracted! ', 'success');
      showAIResult('OCR Result', ocrText);
    } else {
      toast(data.error || 'OCR failed', 'error');
    }
  } catch (error) {
    console.error('OCR error:', error);
    hideAILoading();
    toast('Connection error', 'error');
  } finally {
    aiProcessing = false;
  }
}

async function aiDescribe() {
  if (aiProcessing) {
    toast('AI is processing...', 'info');
    return;
  }
  
  const item = ideas.find(x => x.id === currentImageId);
  if (!item || !item.image) {
    toast('No image to process', 'error');
    return;
  }

  aiProcessing = true;
  showAILoading('describe', false);

  try {
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'describe', image: item.image }),
    });

    const data = await response.json();

    hideAILoading();

    if (data.success && data.result) {
      const description = data.result;
      const existingNotes = item.notes || '';
      
      if (existingNotes) {
        item.notes = existingNotes + '\n\n--- AI Description ---\n' + description;
      } else {
        item.notes = description;
      }
      
      if (!item.text) {
        item.text = description.substring(0, 200) + (description.length > 200 ? '...' : '');
      }
      
      save();
      
      const notesArea = document.getElementById('imgNotes');
      if (notesArea) notesArea.value = item.notes;
      
      toast('Image analyzed! ', 'success');
      showAIResult('AI Description', description);
    } else {
      toast(data.error || 'Analysis failed', 'error');
    }
  } catch (error) {
    console.error('AI describe error:', error);
    hideAILoading();
    toast('Connection error', 'error');
  } finally {
    aiProcessing = false;
  }
}

// AI Result Modal
function showAIResult(title, text) {
  let modal = document.getElementById('aiResultModal');
  
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'aiResultModal';
    modal.className = 'ai-result-modal';
    modal.onclick = function(e) { if(e.target === this) closeAIResult(); };
    modal.innerHTML = `
      <div class="ai-result-content">
        <div class="ai-result-header" style="background: linear-gradient(135deg, #8B5CF6, #EC4899);">
          <h2 id="aiResultTitle">AI Result</h2>
        </div>
        <div class="ai-result-body">
          <div id="aiResultContent" style="font-size: 0.95rem; line-height: 1.6; white-space: pre-wrap;"></div>
        </div>
        <div class="ai-result-actions">
          <button class="pill-l magic" onclick="createDropFromResult()">Create Drop</button>
          <div class="pill-row">
            <button class="pill-l sec" onclick="shareResult()">Share</button>
            <button class="pill-l sec" onclick="copyAIResult()">Copy</button>
          </div>
          <button class="pill-l sec" onclick="closeAIResult()">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }
  
  document.getElementById('aiResultTitle').textContent = title;
  document.getElementById('aiResultContent').textContent = text;
  modal.classList.add('show');
}

function closeAIResult() {
  const modal = document.getElementById('aiResultModal');
  if (modal) modal.classList.remove('show');
}

function copyAIResult() {
  const content = document.getElementById('aiResultContent');
  if (content) {
    navigator.clipboard.writeText(content.textContent);
    toast('Copied!', 'success');
  }
}

// Create Drop from AI result
function createDropFromResult() {
  const content = document.getElementById('aiResultContent');
  if (!content) return;
  
  const text = content.textContent;
  const title = document.getElementById('aiResultTitle').textContent;
  
  // Determine category based on title
  let category = 'ideas';
  if (title.includes('Poem') || title.includes('')) category = 'ideas';
  if (title.includes('Speech') || title.includes('')) category = 'ideas';
  if (title.includes('Greeting') || title.includes('')) category = 'ideas';
  
  const idea = {
    id: Date.now(),
    text: text,
    category: category,
    timestamp: new Date().toISOString(),
    date: new Date().toLocaleDateString('ru-RU'),
    time: new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}),
    aiGenerated: true // Mark as AI generated
  };
  
  ideas.push(idea);
  save();
  closeAIResult();
  render();
  counts();
  toast('Drop created!', 'success');
}

// Share AI result
function shareResult() {
  const content = document.getElementById('aiResultContent');
  if (!content) return;
  
  const text = content.textContent;
  
  if (navigator.share) {
    navigator.share({
      text: text
    }).catch(() => {});
  } else {
    navigator.clipboard.writeText(text);
    toast('Copied! Paste to share', 'success');
  }
}

// ============================================
// AI MAGIC FUNCTIONS (v0.8.2)
// ============================================

let currentMagicType = 'poem';
let magicRecognition = null;
let isMagicRecording = false;
let magicPhotoData = null; // Store selected photo

const MAGIC_CONFIG = {
  poem: {
    title: 'Create Poem',
    subtitle: 'Tell me what it should be about',
    placeholder: 'Example: Birthday greeting for mom, she loves gardening and has 2 grandkids...',
    styles: [
      { id: 'classic', label: 'Classic' },
      { id: 'funny', label: 'Funny' },
      { id: 'tender', label: 'Tender' },
      { id: 'epic', label: 'Epic' }
    ]
  },
  greeting: {
    title: 'Create Greeting',
    subtitle: 'Who is it for and what occasion?',
    placeholder: 'Example: New Year greeting for colleagues, warm and professional...',
    styles: [
      { id: 'warm', label: 'Warm' },
      { id: 'funny', label: 'Funny' },
      { id: 'formal', label: 'Formal' },
      { id: 'poetic', label: 'Poetic' }
    ]
  },
  speech: {
    title: 'Create Speech',
    subtitle: 'What occasion? Who is the audience?',
    placeholder: 'Example: Wedding toast for my best friend, he loves fishing, we know each other 15 years...',
    styles: [
      { id: 'short', label: 'Short (1-2 min)' },
      { id: 'medium', label: 'Medium (3-5 min)' },
      { id: 'long', label: 'Long (7-10 min)' }
    ]
  }
};

function openMagic(type) {
  closePlusMenu();
  currentMagicType = type;
  magicPhotoData = null; // Reset photo
  
  const config = MAGIC_CONFIG[type];
  if (!config) return;
  
  // Update UI
  document.getElementById('magicTitle').textContent = config.title;
  document.getElementById('magicSubtitle').textContent = config.subtitle;
  document.getElementById('magicInput').placeholder = config.placeholder;
  document.getElementById('magicInput').value = '';
  
  // Reset photo UI
  document.getElementById('magicPhotoBtn').classList.remove('has-photo');
  document.getElementById('magicPhotoBtnText').textContent = 'Add photo (optional)';
  document.getElementById('magicPhotoPreview').style.display = 'none';
  document.getElementById('magicPhotoMenu').classList.remove('show');
  
  // Update styles
  const stylesContainer = document.getElementById('magicStyles');
  stylesContainer.innerHTML = config.styles.map((s, i) => 
    `<button class="magic-style${i === 0 ? ' active' : ''}" data-style="${s.id}">${s.label}</button>`
  ).join('');
  
  // Add click handlers to styles
  stylesContainer.querySelectorAll('.magic-style').forEach(btn => {
    btn.onclick = () => {
      stylesContainer.querySelectorAll('.magic-style').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    };
  });
  
  // Show modal
  document.getElementById('magicModal').classList.add('show');
  // Removed autofocus to prevent keyboard popup
}

function closeMagic() {
  document.getElementById('magicModal').classList.remove('show');
  document.getElementById('magicPhotoMenu').classList.remove('show');
  if (isMagicRecording) {
    stopMagicVoice();
  }
}

// ============================================
// MAGIC PHOTO FUNCTIONS
// ============================================

function togglePhotoMenu() {
  const menu = document.getElementById('magicPhotoMenu');
  menu.classList.toggle('show');
}

function takeMagicPhoto() {
  document.getElementById('magicPhotoMenu').classList.remove('show');
  document.getElementById('magicCameraInput').click();
}

function chooseMagicPhoto() {
  document.getElementById('magicPhotoMenu').classList.remove('show');
  document.getElementById('magicPhotoInput').click();
}

function handleMagicPhoto(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (e) => {
    magicPhotoData = e.target.result;
    showMagicPhotoPreview(magicPhotoData);
  };
  reader.readAsDataURL(file);
  
  // Reset input so same file can be selected again
  event.target.value = '';
}

function showMagicPhotoPreview(dataUrl) {
  document.getElementById('magicPhotoImg').src = dataUrl;
  document.getElementById('magicPhotoPreview').style.display = 'block';
  document.getElementById('magicPhotoBtn').classList.add('has-photo');
  document.getElementById('magicPhotoBtnText').textContent = 'Photo added ';
  document.getElementById('magicInputLabel').textContent = 'Add details about this photo (optional)';
}

function removeMagicPhoto() {
  magicPhotoData = null;
  document.getElementById('magicPhotoPreview').style.display = 'none';
  document.getElementById('magicPhotoBtn').classList.remove('has-photo');
  document.getElementById('magicPhotoBtnText').textContent = 'Add photo (optional)';
  document.getElementById('magicInputLabel').textContent = 'Add details (optional if photo added)';
}

// Drops Picker
function openDropsPicker() {
  document.getElementById('magicPhotoMenu').classList.remove('show');
  
  // Get all photo drops
  const photoDrops = ideas.filter(i => i.image);
  const grid = document.getElementById('dropsPickerGrid');
  
  if (photoDrops.length === 0) {
    grid.innerHTML = '<div class="drops-picker-empty">No photo drops yet.<br>Take some photos first!</div>';
  } else {
    grid.innerHTML = photoDrops.map(drop => `
      <div class="drops-picker-item" onclick="selectDropPhoto('${drop.id}')">
        <img src="${drop.image}" alt="Drop photo">
      </div>
    `).join('');
  }
  
  document.getElementById('dropsPicker').classList.add('show');
}

function closeDropsPicker() {
  document.getElementById('dropsPicker').classList.remove('show');
}

function selectDropPhoto(id) {
  const drop = ideas.find(i => i.id == id);
  if (drop && drop.image) {
    magicPhotoData = drop.image;
    showMagicPhotoPreview(drop.image);
  }
  closeDropsPicker();
}

function toggleMagicVoice() {
  if (isMagicRecording) {
    stopMagicVoice();
  } else {
    startMagicVoice();
  }
}

function startMagicVoice() {
  if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    toast('Speech not supported', 'error');
    return;
  }
  
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  magicRecognition = new SpeechRecognition();
  magicRecognition.continuous = false; // Single phrase, no duplicates
  magicRecognition.interimResults = true;
  magicRecognition.maxAlternatives = 1;
  magicRecognition.lang = 'ru-RU';
  
  const inputEl = document.getElementById('magicInput');
  const existingText = inputEl.value;
  let finalTranscript = '';
  
  magicRecognition.onresult = (e) => {
    let interim = '';
    for (let i = 0; i < e.results.length; i++) {
      if (e.results[i].isFinal) {
        finalTranscript += e.results[i][0].transcript;
      } else {
        interim += e.results[i][0].transcript;
      }
    }
    // Show interim while speaking
    document.getElementById('magicVoiceText').textContent = interim || finalTranscript || 'Listening...';
  };
  
  magicRecognition.onerror = (e) => {
    if (e.error === 'no-speech') toast('No speech detected', 'warning');
    stopMagicVoice();
  };
  
  magicRecognition.onend = () => {
    // Append final result to existing text
    if (finalTranscript) {
      inputEl.value = existingText + (existingText ? ' ' : '') + finalTranscript.trim();
    }
    stopMagicVoice();
  };
  
  magicRecognition.start();
  isMagicRecording = true;
  document.getElementById('magicVoiceBtn').classList.add('recording');
  document.getElementById('magicVoiceText').textContent = 'Listening...';
}

function stopMagicVoice() {
  if (magicRecognition) {
    magicRecognition.stop();
    magicRecognition = null;
  }
  isMagicRecording = false;
  document.getElementById('magicVoiceBtn').classList.remove('recording');
  document.getElementById('magicVoiceText').textContent = 'Tap to speak';
}

async function generateMagic() {
  const input = document.getElementById('magicInput').value.trim();
  
  // Need either text or photo
  if (!input && !magicPhotoData) {
    toast('Add a photo or describe what you want', 'error');
    return;
  }
  
  const activeStyle = document.querySelector('.magic-style.active');
  const style = activeStyle ? activeStyle.dataset.style : 'classic';
  
  // Get context
  const context = {
    timeOfDay: getTimeOfDay(),
    location: null
  };
  
  // Show loading in modal
  const loadingLabels = {
    poem: 'Creating your poem',
    greeting: 'Crafting your greeting',
    speech: 'Writing your speech'
  };
  document.getElementById('magicLoadingLabel').textContent = (loadingLabels[currentMagicType] || 'Creating magic') + '...';
  document.getElementById('magicForm').classList.add('hidden');
  document.getElementById('magicLoading').classList.add('show');
  
  try {
    const requestBody = {
      action: currentMagicType,
      text: input,
      style: style,
      context: context
    };
    
    // Add photo if present
    if (magicPhotoData) {
      requestBody.image = magicPhotoData;
    }
    
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });
    
    const data = await response.json();
    
    // Hide loading and close modal
    document.getElementById('magicLoading').classList.remove('show');
    document.getElementById('magicForm').classList.remove('hidden');
    closeMagic();
    
    if (data.success && data.result) {
      const titles = {
        poem: 'Your Poem',
        greeting: 'Your Greeting',
        speech: 'Your Speech'
      };
      
      showAIResult(titles[currentMagicType] || 'AI Result', data.result);
    } else {
      toast(data.error || 'Generation failed', 'error');
    }
  } catch (error) {
    console.error('Magic error:', error);
    document.getElementById('magicLoading').classList.remove('show');
    document.getElementById('magicForm').classList.remove('hidden');
    toast('Connection error', 'error');
  }
}

// ============================================
// AI LOADING INDICATOR (compact, inside modal)
// ============================================

const AI_LOADING_LABELS = {
  poem: 'Creating poem',
  greeting: 'Crafting greeting',
  speech: 'Writing speech',
  summarize: 'Summarizing',
  expand: 'Expanding',
  rewrite: 'Rewriting',
  enhance: 'Enhancing',
  translate: 'Translating',
  tasks: 'Extracting tasks',
  ocr: 'Reading text',
  describe: 'Analyzing image',
  default: 'Processing'
};

let currentLoadingModal = null;

function showAILoading(action, useModal2 = true) {
  const label = AI_LOADING_LABELS[action] || AI_LOADING_LABELS.default;
  
  const loadingHTML = `
    <div class="ai-loading-inline">
      <div class="ai-loading-dots">
        <span></span><span></span><span></span><span></span><span></span>
      </div>
      <div class="ai-loading-label">${label}...</div>
    </div>
  `;
  
  if (useModal2) {
    // Use AI Result Modal 2 (for AI Tools)
    currentLoadingModal = 'modal2';
    document.getElementById('aiResult2Title').textContent = label;
    document.getElementById('aiResult2Text').innerHTML = loadingHTML;
    document.querySelector('.ai-result-actions').style.display = 'none';
    document.getElementById('aiResult2Category').style.display = 'none';
    document.getElementById('aiResultModal2').classList.add('show');
  } else {
    // Use simple toast for Magic/OCR/Describe
    currentLoadingModal = 'toast';
    toast(label + '...', 'info');
  }
}

function hideAILoading() {
  if (currentLoadingModal === 'modal2') {
    // Restore action buttons
    document.querySelector('.ai-result-actions').style.display = 'flex';
  }
  currentLoadingModal = null;
}

function getTimeOfDay() {
  const hour = new Date().getHours();
  if (hour < 6) return 'night';
  if (hour < 12) return 'morning';
  if (hour < 18) return 'afternoon';
  return 'evening';
}

// ============================================
// AI TOOLS FOR TEXT DROPS (v0.8.2)
// ============================================

let aiToolsDropId = null;
let aiToolsResult = null;
let aiToolsSuggestedCategory = null;

function openAITools(id) {
  const drop = ideas.find(x => x.id === id);
  if (!drop || !drop.text) {
    toast('No text to process', 'error');
    return;
  }
  
  aiToolsDropId = id;
  
  // Show preview
  const previewText = drop.text.length > 200 
    ? drop.text.substring(0, 200) + '...' 
    : drop.text;
  document.getElementById('aiToolsPreviewText').textContent = previewText;
  
  // Show current category
  const catName = CATS[drop.category]?.single || drop.category.toUpperCase();
  document.getElementById('aiToolsCurrentCategory').textContent = catName;
  
  document.getElementById('aiToolsModal').classList.add('show');
}

function closeAITools() {
  document.getElementById('aiToolsModal').classList.remove('show');
  // Don't reset aiToolsDropId here - it's needed for Replace/Create Drop actions
}

async function runAITool(tool) {
  const drop = ideas.find(x => x.id === aiToolsDropId);
  if (!drop) {
    toast('Drop not found', 'error');
    return;
  }
  
  const checkCategory = document.getElementById('aiToolsCheckCategory').checked;
  const removeLineBreaks = document.getElementById('aiToolsRemoveLineBreaks').checked;
  
  // Close tools modal and show loading overlay
  closeAITools();
  showAILoading(tool);
  
  try {
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: tool,
        text: drop.text,
        checkCategory: checkCategory
      }),
    });
    
    const data = await response.json();
    
    hideAILoading();
    
    if (data.success && data.result) {
      // Parse result (may be JSON or plain text)
      let resultText = data.result;
      let suggestedCat = null;
      
      // Try to extract JSON from response (may have markdown wrapper)
      let jsonStr = resultText;
      const jsonMatch = resultText.match(/```json\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        jsonStr = jsonMatch[1];
      } else if (resultText.trim().startsWith('{')) {
        jsonStr = resultText.trim();
      }
      
      try {
        // Try to parse as JSON
        const parsed = JSON.parse(jsonStr);
        if (tool === 'summarize' && parsed.summary) {
          resultText = parsed.summary;
          suggestedCat = parsed.suggestedCategory;
        } else if (tool === 'expand' && parsed.expanded) {
          resultText = parsed.expanded;
          suggestedCat = parsed.suggestedCategory;
        } else if (tool === 'rewrite' && parsed.rewritten) {
          resultText = parsed.rewritten;
          suggestedCat = parsed.suggestedCategory;
        } else if (tool === 'enhance' && parsed.enhanced) {
          resultText = parsed.enhanced;
          suggestedCat = parsed.suggestedCategory;
        } else if (tool === 'tasks' && parsed.tasks) {
          // Create task drops
          createTaskDrops(parsed.tasks);
          return;
        } else {
          // JSON parsed but no expected field - use first text value found
          const textValue = parsed.summary || parsed.expanded || parsed.rewritten || parsed.enhanced || parsed.result || parsed.text;
          if (textValue) {
            resultText = textValue;
            suggestedCat = parsed.suggestedCategory;
          }
          // else keep original resultText (will be cleaned below)
        }
      } catch (e) {
        // Not JSON, use as plain text
        if (tool === 'tasks') {
          // Parse numbered list
          const tasks = resultText.split('\n')
            .map(line => line.replace(/^\d+[\.\)]\s*/, '').trim())
            .filter(line => line.length > 0);
          createTaskDrops(tasks);
          return;
        }
        // For other tools, clean up any JSON-like artifacts
        if (resultText.trim().startsWith('{') || resultText.trim().startsWith('```')) {
          // Failed to parse, try to extract text manually
          const textMatch = resultText.match(/"(?:summary|expanded|rewritten|text)":\s*"([^"]+)"/);
          if (textMatch) {
            resultText = textMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
          }
        }
      }
      
      // T1 FIX: Remove extra line breaks if option is checked
      if (removeLineBreaks && tool !== 'tasks') {
        resultText = resultText
          .replace(/\n+/g, ' ')      // Replace newlines with space
          .replace(/\s{2,}/g, ' ')   // Replace multiple spaces with single
          .trim();
      }
      
      // Show result modal
      showAIResult2(tool, resultText, drop.category, suggestedCat);
      
    } else {
      toast(data.error || 'Processing failed', 'error');
    }
  } catch (error) {
    console.error('AI Tools error:', error);
    hideAILoading();
    toast('Connection error', 'error');
  }
}

// B2 FIX: Store pending tasks for confirmation
let pendingTasks = [];

function createTaskDrops(tasks) {
  if (!tasks || tasks.length === 0) {
    toast('No tasks found', 'warning');
    return;
  }
  
  // Show confirmation modal instead of creating immediately
  pendingTasks = tasks;
  showTasksConfirmModal(tasks);
}

function showTasksConfirmModal(tasks) {
  // Close AI Tools modal first to prevent it showing after Cancel
  closeAITools();
  
  document.getElementById('tasksCount').textContent = tasks.length;
  document.getElementById('tasksCountBtn').textContent = tasks.length;
  
  const listEl = document.getElementById('tasksPreviewList');
  listEl.innerHTML = tasks.map((task, i) => `
    <div class="tasks-preview-item">
      <span class="tasks-preview-num">${i + 1}</span>
      <span class="tasks-preview-text">${task}</span>
    </div>
  `).join('');
  
  document.getElementById('tasksConfirmModal').classList.add('show');
}

function closeTasksConfirm() {
  document.getElementById('tasksConfirmModal').classList.remove('show');
  pendingTasks = [];
  aiToolsDropId = null;
}

function confirmCreateTasks() {
  if (!pendingTasks || pendingTasks.length === 0) {
    closeTasksConfirm();
    return;
  }
  
  const createdIds = [];
  
  pendingTasks.forEach(taskText => {
    const id = Date.now() + Math.random();
    const idea = {
      id: id,
      text: taskText,
      category: 'tasks',
      timestamp: new Date().toISOString(),
      date: new Date().toLocaleDateString('ru-RU'),
      time: new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}),
      aiGenerated: true,
      sourceDropId: aiToolsDropId
    };
    ideas.push(idea);
    createdIds.push(id);
  });
  
  saveUndo('createTasks', { taskIds: createdIds });
  
  save();
  render();
  counts();
  toast(`Created ${pendingTasks.length} tasks! `, 'success');
  
  closeTasksConfirm();
}

// ============================================
// I1 FIX: TRANSLATE FUNCTIONS
// ============================================

function openTranslateModal() {
  closeAITools();
  document.getElementById('translateModal').classList.add('show');
}

function closeTranslateModal() {
  document.getElementById('translateModal').classList.remove('show');
}

async function runTranslate(targetLang) {
  closeTranslateModal();
  
  const drop = ideas.find(x => x.id === aiToolsDropId);
  if (!drop) {
    toast('Drop not found', 'error');
    return;
  }
  
  showAILoading('translate');
  
  try {
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'translate',
        text: drop.text,
        targetLang: targetLang
      }),
    });
    
    const data = await response.json();
    hideAILoading();
    
    if (data.success && data.result) {
      showAIResult2('translate', data.result, drop.category, null);
    } else {
      toast(data.error || 'Translation failed', 'error');
    }
  } catch (error) {
    console.error('Translate error:', error);
    hideAILoading();
    toast('Connection error', 'error');
  }
}

function showAIResult2(tool, text, currentCategory, suggestedCategory) {
  aiToolsResult = text;
  aiToolsSuggestedCategory = suggestedCategory;
  
  const titles = {
    summarize: 'Summary',
    expand: 'Expanded',
    rewrite: 'Rewritten',
    enhance: 'Enhanced',
    translate: 'Translated'
  };
  
  document.getElementById('aiResult2Title').textContent = titles[tool] || 'Result';
  document.getElementById('aiResult2Text').textContent = text;
  
  // Show action buttons (may have been hidden during loading)
  document.querySelector('.ai-result-actions').style.display = 'flex';
  
  // Show category suggestion if available
  const catSection = document.getElementById('aiResult2Category');
  if (suggestedCategory && suggestedCategory !== currentCategory) {
    const currentName = CATS[currentCategory]?.single || currentCategory.toUpperCase();
    const suggestedName = CATS[suggestedCategory]?.single || suggestedCategory.toUpperCase();
    
    document.getElementById('aiResult2CurrentCat').textContent = currentName;
    document.getElementById('aiResult2SuggestedCat').textContent = suggestedName;
    catSection.style.display = 'block';
  } else {
    catSection.style.display = 'none';
  }
  
  document.getElementById('aiResultModal2').classList.add('show');
}

function closeAIResult2() {
  document.getElementById('aiResultModal2').classList.remove('show');
  aiToolsResult = null;
  aiToolsSuggestedCategory = null;
  aiToolsDropId = null; // Reset here when user closes without action
}

function replaceOriginal() {
  if (!aiToolsDropId || !aiToolsResult) return;
  
  const drop = ideas.find(x => x.id === aiToolsDropId);
  if (drop) {
    // Save for undo
    saveUndo('replace', { id: drop.id, originalText: drop.text });
    
    // Save original in drop too
    if (!drop.originalText) {
      drop.originalText = drop.text;
    }
    drop.text = aiToolsResult;
    save();
    render();
    toast('Replaced! ', 'success');
  }
  
  closeAIResult2();
  aiToolsDropId = null;
}

function createNewDrop() {
  if (!aiToolsResult) return;
  
  const sourceDrop = ideas.find(x => x.id === aiToolsDropId);
  const category = aiToolsSuggestedCategory || sourceDrop?.category || 'ideas';
  
  const idea = {
    id: Date.now(),
    text: aiToolsResult,
    category: category,
    timestamp: new Date().toISOString(),
    date: new Date().toLocaleDateString('ru-RU'),
    time: new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}),
    aiGenerated: true,
    sourceDropId: aiToolsDropId
  };
  
  ideas.push(idea);
  save();
  render();
  counts();
  toast('Drop created!', 'success');
  
  closeAIResult2();
  aiToolsDropId = null;
}

function copyResult2() {
  if (aiToolsResult) {
    navigator.clipboard.writeText(aiToolsResult);
    toast('Copied!', 'success');
  }
}

function keepCategory() {
  aiToolsSuggestedCategory = null;
  document.getElementById('aiResult2Category').style.display = 'none';
}

function acceptCategory() {
  if (!aiToolsDropId || !aiToolsSuggestedCategory) return;
  
  const drop = ideas.find(x => x.id === aiToolsDropId);
  if (drop) {
    drop.category = aiToolsSuggestedCategory;
    save();
    counts();
  }
  
  document.getElementById('aiResult2Category').style.display = 'none';
  toast('Category updated! ', 'success');
}

function deleteFromViewer(){
  if(!currentImageId)return;
  if(confirm('Delete this image?')){
    ideas=ideas.filter(x=>x.id!==currentImageId);
    save();
    closeImageViewer();
    render();
    counts();
    toast('Deleted','info');
  }
}


function counts(){
  try{
    const validIdeas=ideas.filter(x=>x&&x.id&&x.category);
    const cntAll=document.getElementById('cntAll');
    const cntToday=document.getElementById('cntToday');
    const cnt7d=document.getElementById('cnt7d');
    
    if(cntAll)cntAll.textContent=validIdeas.length;
    if(cntToday)cntToday.textContent=validIdeas.filter(x=>x.date&&isToday(x.date)).length;
    if(cnt7d)cnt7d.textContent=validIdeas.filter(x=>x.date&&inDays(x.date,7)).length;
    
    // Count ALL items in each category
    for(const k of Object.keys(CATS)){
      const el=document.getElementById('cnt'+k.charAt(0).toUpperCase()+k.slice(1));
      if(el)el.textContent=validIdeas.filter(x=>x.category===k).length;
    }
  }catch(err){}
}

document.getElementById('timeRow').addEventListener('click',e=>{
  const b=e.target.closest('.time-btn');if(!b)return;
  document.querySelectorAll('.time-btn').forEach(x=>x.classList.remove('active'));
  if(b.dataset.time!=='all')b.classList.add('active');
  curTime=b.dataset.time;curCat='all';activeCardId=null;
  document.querySelectorAll('.cat').forEach(x=>x.classList.remove('active'));
  render();counts();
});

document.getElementById('cats').addEventListener('click',e=>{
  const c=e.target.closest('.cat');if(!c)return;
  if(c.classList.contains('active')){c.classList.remove('active');curCat='all';}
  else{document.querySelectorAll('.cat').forEach(x=>x.classList.remove('active'));c.classList.add('active');curCat=c.dataset.category;}
  activeCardId=null;render();
});

function addCatPrompt(){document.getElementById('addCatModal').classList.add('show');}
function closeAddCatModal(){document.getElementById('addCatModal').classList.remove('show');}

function exportAll(){
  closeSettings();
  if(!ideas.length){toast('Nothing to export','warning');return;}
  const grp={};for(const i of ideas){if(!grp[i.category])grp[i.category]=[];grp[i.category].push(i);}
  let md='# DropLit Export\n'+new Date().toLocaleDateString('ru-RU')+' | '+ideas.length+' ideas\n\n';
  for(const[k,arr]of Object.entries(grp)){
    md+='## '+CATS[k].name+' ('+arr.length+')\n';
    for(const i of arr)md+='- ['+i.date+' '+i.time+'] '+i.text+'\n';
    md+='\n';
  }
  md+='---\nExported from DropLit v0.9.58';
  document.getElementById('exportBox').textContent=md;
  document.getElementById('exportModal').classList.add('show');
}

function closeExportModal(){document.getElementById('exportModal').classList.remove('show');}
function copyExport(){navigator.clipboard.writeText(document.getElementById('exportBox').textContent);toast('Copied!','success');closeExportModal();}
function openAbout(){document.getElementById('aboutModal').classList.add('show');}
function closeAbout(){document.getElementById('aboutModal').classList.remove('show');}
function openSettings(){
  document.getElementById('settingsModal').classList.add('show');
  // Initialize voice settings UI with saved values
  initVoiceSettings();
}
function closeSettings(){document.getElementById('settingsModal').classList.remove('show');}

// ============================================
// MAIN MENU
// ============================================

function toggleMainMenu() {
  const menu = document.getElementById('mainMenu');
  const isOpen = menu.classList.contains('show');
  
  if (isOpen) {
    closeMainMenu();
  } else {
    openMainMenu();
  }
}

function openMainMenu() {
  document.getElementById('mainMenu').classList.add('show');
  updateMenuIcon(true);
  updateUndoList();
  updateTokenBalance();
  initFontSize();
  // Initialize voice/TTS settings UI with saved values
  initVoiceSettings();
}

function closeMainMenu() {
  document.getElementById('mainMenu').classList.remove('show');
  updateMenuIcon(false);
}

// Debug info (v0.9.58)
function showDebugInfo() {
  closeMainMenu();
  const total = ideas.length;
  const stringIds = ideas.filter(i => typeof i.id === 'string').length;
  const merged = ideas.filter(i => i.isMerged).length;
  const audio = ideas.filter(i => i.category === 'audio').length;
  const textDrops = ideas.filter(i => !i.isMedia && !i.image && !i.audioData).length;
  const mediaDrops = ideas.filter(i => i.isMedia || i.image || i.audioData).length;
  const userId = currentUser ? currentUser.id.substring(0, 8) + '...' : 'Not logged in';
  const deviceId = (typeof DEVICE_ID !== 'undefined' && DEVICE_ID) ? DEVICE_ID : 'Not set';
  const syncStatus = syncEnabled ? 'Enabled' : 'Disabled';
  const lastSync = lastSyncTime ? lastSyncTime.toLocaleTimeString() : 'Never';
  
  alert(
    `DropLit Debug v0.9.58\n\n` +
    `=== DROPS ===\n` +
    `Total: ${total}\n` +
    `Text: ${textDrops}\n` +
    `Media: ${mediaDrops}\n` +
    `Merged: ${merged}\n` +
    `Audio: ${audio}\n` +
    `String IDs: ${stringIds}\n\n` +
    `=== SYNC ===\n` +
    `User ID: ${userId}\n` +
    `Device ID: ${deviceId}\n` +
    `Sync: ${syncStatus}\n` +
    `Last sync: ${lastSync}\n\n` +
    `=== STORAGE ===\n` +
    `LocalStorage: ${(localStorage.getItem('droplit_ideas')?.length / 1024).toFixed(1)} KB`
  );
}

function updateMenuIcon(isOpen) {
  const btn = document.getElementById('menuToggleBtn');
  if (!btn) return;
  
  const openIcon = btn.querySelector('.menu-icon-open');
  const closeIcon = btn.querySelector('.menu-icon-close');
  
  if (openIcon && closeIcon) {
    openIcon.style.display = isOpen ? 'none' : 'block';
    closeIcon.style.display = isOpen ? 'block' : 'none';
  }
  
  // Change button style when menu is open
  btn.classList.toggle('active', isOpen);
}

// ============================================
// UNDO SYSTEM
// ============================================

const MAX_UNDO_HISTORY = 10;
let undoHistory = JSON.parse(localStorage.getItem('droplit_undo') || '[]');

const UNDO_ICONS = {
  delete: '',
  createTasks: '',
  replace: '',
  edit: '',
  merge: '',
  category: '',
  create: ''
};

const UNDO_LABELS = {
  delete: 'Deleted',
  createTasks: 'Created tasks',
  replace: 'Replaced text',
  edit: 'Edited',
  merge: 'Merged drops',
  category: 'Changed category',
  create: 'Created'
};

function saveUndo(action, data) {
  const entry = {
    action,
    data,
    timestamp: Date.now()
  };
  
  undoHistory.unshift(entry);
  if (undoHistory.length > MAX_UNDO_HISTORY) {
    undoHistory = undoHistory.slice(0, MAX_UNDO_HISTORY);
  }
  
  localStorage.setItem('droplit_undo', JSON.stringify(undoHistory));
}

function performUndo(index) {
  const entry = undoHistory[index];
  if (!entry) return;
  
  switch (entry.action) {
    case 'delete':
      // Restore deleted drop
      ideas.push(entry.data);
      toast('Drop restored! ', 'success');
      break;
      
    case 'createTasks':
      // Remove created tasks
      const taskIds = entry.data.taskIds;
      ideas = ideas.filter(i => !taskIds.includes(i.id));
      toast(`${taskIds.length} tasks removed! `, 'success');
      break;
      
    case 'replace':
      // Restore original text
      const dropR = ideas.find(i => i.id === entry.data.id);
      if (dropR) {
        dropR.text = entry.data.originalText;
        toast('Text restored! ', 'success');
      }
      break;
      
    case 'edit':
      // Restore previous text
      const dropE = ideas.find(i => i.id === entry.data.id);
      if (dropE) {
        dropE.text = entry.data.previousText;
        toast('Edit undone! ', 'success');
      }
      break;
      
    case 'merge':
      // Remove merged drop
      ideas = ideas.filter(i => i.id !== entry.data.mergedId);
      toast('Merge undone! ', 'success');
      break;
      
    case 'category':
      // Restore previous category
      const dropC = ideas.find(i => i.id === entry.data.id);
      if (dropC) {
        dropC.category = entry.data.previousCategory;
        toast('Category restored! ', 'success');
      }
      break;
      
    case 'create':
      // Remove created drop
      ideas = ideas.filter(i => i.id !== entry.data.id);
      toast('Creation undone! ', 'success');
      break;
  }
  
  // Remove from history
  undoHistory.splice(index, 1);
  localStorage.setItem('droplit_undo', JSON.stringify(undoHistory));
  
  save();
  render();
  counts();
  updateUndoList();
}

function updateUndoList() {
  const list = document.getElementById('undoList');
  const mainBtn = document.getElementById('undoMainBtn');
  const toggleBtn = document.getElementById('undoToggleBtn');
  const lastInfo = document.getElementById('undoLastInfo');
  
  if (undoHistory.length === 0) {
    mainBtn.disabled = true;
    mainBtn.innerHTML = ' Nothing to Undo';
    lastInfo.textContent = '';
    toggleBtn.style.display = 'none';
    list.innerHTML = '';
    list.classList.remove('show');
    return;
  }
  
  // Enable main button
  mainBtn.disabled = false;
  const lastEntry = undoHistory[0];
  const lastLabel = UNDO_LABELS[lastEntry.action] || 'Action';
  const lastPreview = getUndoPreview(lastEntry);
  mainBtn.innerHTML = ` Undo: ${lastLabel}`;
  
  // Show last action info
  lastInfo.textContent = `${lastPreview}  ${getTimeAgo(lastEntry.timestamp)}`;
  
  // Show toggle button if more than 1 item
  if (undoHistory.length > 1) {
    toggleBtn.style.display = 'block';
    toggleBtn.textContent = `Show all history (${undoHistory.length})`;
  } else {
    toggleBtn.style.display = 'none';
    list.classList.remove('show');
  }
  
  // Build list (hidden by default)
  list.innerHTML = undoHistory.slice(1).map((entry, index) => {
    const icon = UNDO_ICONS[entry.action] || '';
    const label = UNDO_LABELS[entry.action] || 'Action';
    const time = getTimeAgo(entry.timestamp);
    const preview = getUndoPreview(entry);
    
    return `
      <div class="undo-item">
        <div class="undo-item-icon">${icon}</div>
        <div class="undo-item-info">
          <div class="undo-item-title">${label}: ${preview}</div>
          <div class="undo-item-time">${time}</div>
        </div>
        <button class="pill-s pri" onclick="performUndo(${index + 1})">Undo</button>
      </div>
    `;
  }).join('');
}

function toggleUndoList() {
  const list = document.getElementById('undoList');
  const toggleBtn = document.getElementById('undoToggleBtn');
  const isShown = list.classList.toggle('show');
  toggleBtn.textContent = isShown 
    ? `Hide history (${undoHistory.length})` 
    : `Show all history (${undoHistory.length})`;
}

function undoLast() {
  if (undoHistory.length > 0) {
    performUndo(0);
  }
}

function getUndoPreview(entry) {
  switch (entry.action) {
    case 'delete':
      return truncateText(entry.data.text || 'Drop', 25);
    case 'createTasks':
      return `${entry.data.taskIds.length} tasks`;
    case 'replace':
    case 'edit':
      return truncateText(entry.data.previousText || entry.data.originalText || 'text', 25);
    case 'merge':
      return `${entry.data.count} drops`;
    case 'category':
      return ` ${entry.data.newCategory}`;
    case 'create':
      return truncateText(entry.data.text || 'Drop', 25);
    default:
      return '';
  }
}

function truncateText(text, maxLen) {
  if (!text) return '';
  text = text.replace(/\n/g, ' ').trim();
  if (text.length <= maxLen) return text;
  return text.substring(0, maxLen) + '...';
}

function getTimeAgo(timestamp) {
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  if (seconds < 60) return 'Just now';
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes} min ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours} hr ago`;
  const days = Math.floor(hours / 24);
  return `${days} day${days > 1 ? 's' : ''} ago`;
}

// ============================================
// SEARCH
// ============================================

let searchMode = false;
let searchQuery = '';

function performSearch() {
  const query = document.getElementById('menuSearchInput').value.trim().toLowerCase();
  if (!query) {
    clearSearch();
    return;
  }
  
  searchMode = true;
  searchQuery = query;
  closeMainMenu();
  
  // Show search indicator
  document.getElementById('searchIndicator').style.display = 'flex';
  document.getElementById('searchQueryDisplay').textContent = query;
  
  // Filter ideas by search query
  render();
  
  const count = filtered().length;
  toast(`Found ${count} drop${count !== 1 ? 's' : ''}`, 'info');
}

function clearSearch() {
  searchMode = false;
  searchQuery = '';
  document.getElementById('menuSearchInput').value = '';
  document.getElementById('searchIndicator').style.display = 'none';
  render();
}

let voiceSearchRecognition = null;

function startVoiceSearch() {
  if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    toast('Voice search not supported', 'error');
    return;
  }
  
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  voiceSearchRecognition = new SpeechRecognition();
  voiceSearchRecognition.continuous = false;
  voiceSearchRecognition.interimResults = false;
  voiceSearchRecognition.lang = navigator.language || 'en-US';
  
  voiceSearchRecognition.onresult = (e) => {
    const transcript = e.results[0][0].transcript;
    document.getElementById('menuSearchInput').value = transcript;
    performSearch();
  };
  
  voiceSearchRecognition.onerror = () => {
    toast('Voice search failed', 'error');
  };
  
  voiceSearchRecognition.start();
  toast('Listening...', 'info');
}

// ============================================
// FILTERS TOGGLE (Clean Screen)
// ============================================

function toggleFilters() {
  const isVisible = document.body.classList.toggle('filters-visible');
  localStorage.setItem('droplit_filters_visible', isVisible);
}

function initFiltersState() {
  // Default to hidden (clean screen)
  const savedState = localStorage.getItem('droplit_filters_visible');
  if (savedState === 'true') {
    document.body.classList.add('filters-visible');
  }
}

// ============================================
// SETTINGS FUNCTIONS
// ============================================

function toggleVoiceMode() {
  const toggle = document.getElementById('voiceModeToggle');
  const isEnabled = toggle.classList.toggle('active');
  setVoiceMode(isEnabled);
  
  // Update chat UI
  updateVoiceModeUI();
  
  if (isEnabled) {
    toast('Voice Mode ON');
    acquireWakeLock(); // Keep screen on
    // Start in sleep mode - wait for user tap
    if (document.getElementById('askAIPanel')?.classList.contains('show')) {
      voiceModeSleeping = true;
      updateVoiceModeIndicator('sleeping');
    }
  } else {
    stopVoiceModeListening();
    releaseWakeLock(); // Allow screen to sleep
    toast('Voice Mode OFF');
    updateVoiceModeIndicator('');
  }
}

function toggleAutoSpeak() {
  const toggle = document.getElementById('autoSpeakToggle');
  const isEnabled = toggle.classList.toggle('active');
  setAutoSpeak(isEnabled);
}

// AutoDrop functions
function isAutoDropEnabled() {
  return localStorage.getItem('aski_autodrop') === 'true';
}

function setAutoDrop(enabled) {
  localStorage.setItem('aski_autodrop', enabled ? 'true' : 'false');
  toast(enabled ? 'AutoDrop enabled' : 'AutoDrop disabled');
}

function toggleAutoDrop() {
  const toggle = document.getElementById('autoDropToggle');
  const isEnabled = toggle.classList.toggle('active');
  setAutoDrop(isEnabled);
}

// Auto-save message as drop (for AutoDrop mode)
function autoSaveMessageAsDrop(text, isUser) {
  // Filter out service/error messages
  const servicePatterns = [
    'Connection error',
    'Please check your internet',
    'could not process your request',
    'Sorry, I could not',
    'No internet',
    'Failed to'
  ];
  
  if (servicePatterns.some(pattern => text.includes(pattern))) {
    console.log('AutoDrop: Skipping service message');
    return;
  }
  
  const convId = getConversationId();
  const msgIndex = getNextMessageIndex();
  
  const drop = {
    id: Date.now() + msgIndex, // Ensure unique ID
    text: text,
    category: 'inbox',
    timestamp: new Date().toISOString(),
    date: new Date().toLocaleDateString('ru-RU'),
    time: new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}),
    isMedia: false,
    // AutoDrop metadata
    conversation_id: convId,
    message_index: msgIndex,
    role: isUser ? 'user' : 'assistant',
    source: 'autodrop'
  };
  
  ideas.unshift(drop);
  save(drop);
  render();
  counts();
  
  // Sync with Syntrise if enabled
  if (typeof syncDropToSyntrise === 'function') {
    syncDropToSyntrise(drop);
  }
  
  console.log(`AutoDrop saved: ${isUser ? 'user' : 'ai'} message #${msgIndex} in ${convId}`);
}

// Toggle AutoDrop from chat header
function toggleAutoDropFromChat() {
  const enabled = !isAutoDropEnabled();
  setAutoDrop(enabled);
  updateAutoDropIndicator();
  
  // Also update toggle in settings if visible
  const toggle = document.getElementById('autoDropToggle');
  if (toggle) {
    if (enabled) {
      toggle.classList.add('active');
    } else {
      toggle.classList.remove('active');
    }
  }
}

// Update AutoDrop indicator in chat header
function updateAutoDropIndicator() {
  const indicator = document.getElementById('autoDropIndicator');
  if (!indicator) return;
  
  const enabled = isAutoDropEnabled();
  indicator.style.display = 'block';
  
  if (enabled) {
    indicator.classList.remove('off');
    indicator.textContent = 'AUTODROP';
  } else {
    indicator.classList.add('off');
    indicator.textContent = 'AUTODROP';
  }
}

// Get current conversation ID (creates new one if needed)
function getConversationId() {
  let convId = sessionStorage.getItem('current_conversation_id');
  if (!convId) {
    convId = 'conv_' + Date.now();
    sessionStorage.setItem('current_conversation_id', convId);
  }
  return convId;
}

// Get next message index in conversation
function getNextMessageIndex() {
  let idx = parseInt(sessionStorage.getItem('message_index') || '0');
  sessionStorage.setItem('message_index', (idx + 1).toString());
  return idx;
}

function initVoiceSettings() {
  // ===     LOCALSTORAGE ===
  
  // TTS Provider
  ttsProvider = localStorage.getItem('tts_provider') || 'openai';
  
  // OpenAI 
  askiVoice = localStorage.getItem('aski_voice') || 'nova';
  askiApiKey = localStorage.getItem('openai_tts_key') || '';
  
  // ElevenLabs 
  elevenlabsApiKey = localStorage.getItem('elevenlabs_tts_key') || '';
  elevenlabsVoice = localStorage.getItem('elevenlabs_voice') || 'Nadia';
  elevenlabsVoiceId = localStorage.getItem('elevenlabs_voice_id') || 'gedzfqL7OGdPbwm0ynTP';
  
  // === UI: TTS PROVIDER SELECTOR ===
  //   active   
  document.querySelectorAll('#ttsProviderSelector .pill-m').forEach(btn => {
    btn.classList.remove('active');
  });
  //   active  
  const providerBtn = document.querySelector(`#ttsProviderSelector .pill-m[data-provider="${ttsProvider}"]`);
  if (providerBtn) {
    providerBtn.classList.add('active');
  }
  
  // === UI: /   ===
  const openaiSettings = document.getElementById('openaiVoiceSettings');
  const elevenlabsSettings = document.getElementById('elevenlabsVoiceSettings');
  
  if (openaiSettings) {
    openaiSettings.style.display = (ttsProvider === 'openai') ? 'block' : 'none';
  }
  if (elevenlabsSettings) {
    elevenlabsSettings.style.display = (ttsProvider === 'elevenlabs') ? 'block' : 'none';
  }
  
  // === UI: OPENAI VOICE SELECTOR ===
  document.querySelectorAll('#voiceSelector .pill-m').forEach(btn => {
    btn.classList.remove('active');
  });
  const openaiVoiceBtn = document.querySelector(`#voiceSelector .pill-m[data-voice="${askiVoice}"]`);
  if (openaiVoiceBtn) {
    openaiVoiceBtn.classList.add('active');
  }
  
  // === UI: OPENAI API KEY ===
  const openaiInput = document.getElementById('openaiApiKeyInput');
  if (openaiInput) {
    openaiInput.value = askiApiKey;
    const status = document.getElementById('apiKeyStatus');
    if (status) {
      if (askiApiKey) {
        status.textContent = 'Key loaded';
        status.style.color = '#10B981';
      } else {
        status.textContent = 'Using browser voice';
        status.style.color = 'var(--color-text-muted)';
      }
    }
  }
  
  // === UI: ELEVENLABS VOICE SELECTOR ===
  document.querySelectorAll('#elevenlabsVoiceSelector .pill-m').forEach(btn => {
    btn.classList.remove('active');
  });
  const elVoiceBtn = document.querySelector(`#elevenlabsVoiceSelector .pill-m[data-voiceid="${elevenlabsVoiceId}"]`);
  if (elVoiceBtn) {
    elVoiceBtn.classList.add('active');
  }
  
  // === UI: ELEVENLABS API KEY ===
  const elevenlabsInput = document.getElementById('elevenlabsApiKeyInput');
  if (elevenlabsInput) {
    elevenlabsInput.value = elevenlabsApiKey;
    const status = document.getElementById('elevenlabsApiKeyStatus');
    if (status) {
      if (elevenlabsApiKey) {
        status.textContent = 'Key loaded';
        status.style.color = '#10B981';
      } else {
        status.textContent = '';
      }
    }
  }
  
  // === UI: TOGGLES ===
  const voiceModeToggle = document.getElementById('voiceModeToggle');
  if (voiceModeToggle) {
    voiceModeToggle.classList.toggle('active', isVoiceModeEnabled());
  }
  
  const autoSpeakToggle = document.getElementById('autoSpeakToggle');
  if (autoSpeakToggle) {
    autoSpeakToggle.classList.toggle('active', isAutoSpeakEnabled());
  }
  
  const autoDropToggle = document.getElementById('autoDropToggle');
  if (autoDropToggle) {
    autoDropToggle.classList.toggle('active', isAutoDropEnabled());
  }
  
  // === UI: LISTEN TIME ===
  const savedSeconds = localStorage.getItem('aski_listen_seconds') || '15';
  document.querySelectorAll('#listenCyclesSelector .pill-m').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.cycles === savedSeconds);
  });
}

function initAutoSpeakToggle() {
  // Deprecated - use initVoiceSettings instead
  initVoiceSettings();
}

function toggleDarkMode() {
  const toggle = document.getElementById('darkModeToggle');
  const isDark = toggle.classList.toggle('active');
  document.body.classList.toggle('dark-mode', isDark);
  localStorage.setItem('droplit_darkmode', isDark);
}

function setFontSize(size) {
  // Remove all font size classes
  document.body.classList.remove('font-small', 'font-normal', 'font-large');
  // Add selected
  document.body.classList.add('font-' + size);
  
  // Update buttons (support both old and new selectors)
  document.querySelectorAll('#fontSizeSelector .pill-m, .font-size-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.size === size);
  });
  
  // Save preference
  localStorage.setItem('droplit_fontsize', size);
  
  toast('Font size: ' + size.charAt(0).toUpperCase() + size.slice(1), 'success');
}

function initFontSize() {
  const saved = localStorage.getItem('droplit_fontsize') || 'normal';
  document.body.classList.remove('font-small', 'font-normal', 'font-large');
  document.body.classList.add('font-' + saved);
  
  // Update buttons when initialized
  document.querySelectorAll('#fontSizeSelector .pill-m').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.size === saved);
  });
}

function exportData() {
  const data = {
    version: '0.8.2',
    exported: new Date().toISOString(),
    ideas: ideas
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `droplit-backup-${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  toast('Data exported!', 'success');
}

function handleImportFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      if (data.ideas && Array.isArray(data.ideas)) {
        if (confirm(`Import ${data.ideas.length} drops? This will add to existing data.`)) {
          ideas = ideas.concat(data.ideas);
          save();
          render();
          counts();
          toast(`Imported ${data.ideas.length} drops! `, 'success');
        }
      } else {
        toast('Invalid backup file', 'error');
      }
    } catch (err) {
      toast('Failed to parse file', 'error');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
}

function clearAllData() {
  if (confirm('Delete ALL drops? This cannot be undone!')) {
    if (confirm('Are you REALLY sure? All data will be lost!')) {
      ideas = [];
      undoHistory = [];
      save();
      localStorage.removeItem('droplit_undo');
      render();
      counts();
      updateUndoList();
      toast('All data cleared', 'success');
    }
  }
}

// ============================================
// TOKEN BALANCE
// ============================================

async function updateTokenBalance() {
  // For now, show placeholder - will connect to real API later
  document.getElementById('tokenBalance').textContent = ' Free Beta';
  document.getElementById('tokenUsage').textContent = 'Unlimited during beta';
  
  // TODO: Fetch real balance from API
  // try {
  //   const response = await fetch(AI_API_URL + '?action=balance');
  //   const data = await response.json();
  //   document.getElementById('tokenBalance').textContent = formatTokens(data.balance);
  //   document.getElementById('tokenUsage').textContent = `Used: ${formatTokens(data.used)}`;
  // } catch (e) {
  //   document.getElementById('tokenBalance').textContent = 'N/A';
  // }
}

// ============================================
// PHOTO AI TOOLS
// ============================================

let photoAIResult = null;
let photoAIType = null;

function openPhotoAI() {
  document.getElementById('photoAIModal').classList.add('show');
}

function closePhotoAI() {
  document.getElementById('photoAIModal').classList.remove('show');
}

async function runPhotoAI(type) {
  closePhotoAI();
  photoAIType = type;
  
  if (type === 'ocr') {
    await ocrImageNew();
  } else if (type === 'describe') {
    await aiDescribeNew();
  }
}

async function ocrImageNew() {
  if (aiProcessing) {
    toast('AI is processing...', 'info');
    return;
  }
  
  const item = ideas.find(x => x.id === currentImageId);
  if (!item || !item.image) {
    toast('No image to process', 'error');
    return;
  }

  aiProcessing = true;
  showAILoading('ocr', false);

  try {
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'ocr', image: item.image }),
    });

    const data = await response.json();
    hideAILoading();

    if (data.success && data.result) {
      photoAIResult = data.result;
      showPhotoAIResult('Extracted Text', photoAIResult);
    } else {
      toast(data.error || 'OCR failed', 'error');
    }
  } catch (error) {
    console.error('OCR error:', error);
    hideAILoading();
    toast('Connection error', 'error');
  } finally {
    aiProcessing = false;
  }
}

async function aiDescribeNew() {
  if (aiProcessing) {
    toast('AI is processing...', 'info');
    return;
  }
  
  const item = ideas.find(x => x.id === currentImageId);
  if (!item || !item.image) {
    toast('No image to process', 'error');
    return;
  }

  aiProcessing = true;
  showAILoading('describe', false);

  try {
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'describe', image: item.image }),
    });

    const data = await response.json();
    hideAILoading();

    if (data.success && data.result) {
      photoAIResult = data.result;
      showPhotoAIResult('Image Description', photoAIResult);
    } else {
      toast(data.error || 'Analysis failed', 'error');
    }
  } catch (error) {
    console.error('AI describe error:', error);
    hideAILoading();
    toast('Connection error', 'error');
  } finally {
    aiProcessing = false;
  }
}

function showPhotoAIResult(title, text) {
  document.getElementById('photoAIResultTitle').textContent = title;
  document.getElementById('photoAIResultText').textContent = text;
  document.getElementById('photoAIResult').classList.add('show');
}

function closePhotoAIResult() {
  document.getElementById('photoAIResult').classList.remove('show');
  photoAIResult = null;
  photoAIType = null;
}

function savePhotoAIToCaption() {
  if (!photoAIResult || !currentImageId) return;
  
  const item = ideas.find(x => x.id === currentImageId);
  if (item) {
    // Truncate to 200 chars for caption
    const MAX_CAPTION = 200;
    if (photoAIResult.length > MAX_CAPTION) {
      item.notes = photoAIResult.substring(0, MAX_CAPTION) + '...';
    } else {
      item.notes = photoAIResult;
    }
    save();
    updateImageViewerCaption();
    render();
    toast('Caption updated! ', 'success');
  }
  closePhotoAIResult();
}

function savePhotoAIToNewDrop() {
  if (!photoAIResult) return;
  
  const sourceItem = ideas.find(x => x.id === currentImageId);
  const category = detectCat(photoAIResult);
  
  const idea = {
    id: Date.now(),
    text: photoAIResult,
    category: category,
    timestamp: new Date().toISOString(),
    date: new Date().toLocaleDateString('ru-RU'),
    time: new Date().toLocaleTimeString('ru-RU', {hour:'2-digit', minute:'2-digit'}),
    aiGenerated: true,
    sourceImageId: currentImageId
  };
  
  ideas.push(idea);
  save();
  render();
  counts();
  
  toast('New drop created!', 'success');
  closePhotoAIResult();
}

function copyPhotoAIResult() {
  if (!photoAIResult) return;
  
  navigator.clipboard.writeText(photoAIResult);
  toast('Copied!', 'success');
  closePhotoAIResult();
}

function updateImageViewerCaption() {
  const item = ideas.find(x => x.id === currentImageId);
  if (item) {
    const captionDisplay = document.getElementById('imageCaptionDisplay');
    if (captionDisplay) {
      captionDisplay.textContent = item.notes || '';
    }
  }
}

// ============================================
// PHOTO MARKERS
// ============================================

function openPhotoMarkers() {
  if (!currentImageId) return;
  
  const item = ideas.find(x => x.id === currentImageId);
  if (!item) return;
  
  // Build markers grid
  const grid = document.getElementById('photoMarkersGrid');
  grid.innerHTML = Object.keys(MARKERS).map(mk => {
    const isActive = item.markers && item.markers.includes(mk);
    return `<button class="photo-marker-btn${isActive ? ' active' : ''}" onclick="togglePhotoMarker('${mk}')">${MARKERS[mk]}</button>`;
  }).join('');
  
  document.getElementById('photoMarkersModal').classList.add('show');
}

function closePhotoMarkersModal() {
  document.getElementById('photoMarkersModal').classList.remove('show');
}

function togglePhotoMarker(marker) {
  if (!currentImageId) return;
  
  const item = ideas.find(x => x.id === currentImageId);
  if (!item) return;
  
  if (!item.markers) item.markers = [];
  
  const idx = item.markers.indexOf(marker);
  if (idx === -1) {
    item.markers.push(marker);
  } else {
    item.markers.splice(idx, 1);
  }
  
  save();
  render();
  updatePhotoMarkersButton();
  
  // Update button state in modal
  const btns = document.querySelectorAll('.photo-marker-btn');
  btns.forEach(btn => {
    const mk = Object.keys(MARKERS).find(k => MARKERS[k] === btn.textContent);
    if (mk) {
      btn.classList.toggle('active', item.markers.includes(mk));
    }
  });
}

function updatePhotoMarkersButton() {
  const item = ideas.find(x => x.id === currentImageId);
  const btn = document.getElementById('imageViewerMarkers');
  if (!btn) return;
  
  if (item && item.markers && item.markers.length > 0) {
    btn.innerHTML = item.markers.map(m => MARKERS[m] || '').join('');
    btn.classList.add('has-markers');
  } else {
    btn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94.94-2.48 0-3.42L12 2Z"/><path d="M7 7h.01"/></svg>';
    btn.classList.remove('has-markers');
  }
}

function toast(m,t='info'){
  const w=document.getElementById('toastWrap'),el=document.createElement('div');
  el.className='toast '+t;
  el.innerHTML=({success:'OK',warning:'!',error:'X',info:'i'})[t]+' '+m;
  w.appendChild(el);
  setTimeout(()=>el.classList.add('show'),10);
  setTimeout(()=>{el.classList.remove('show');setTimeout(()=>el.remove(),300);},2500);
}

function updateNet(){document.getElementById('netBanner').classList.toggle('show',!navigator.onLine);}
window.addEventListener('online',updateNet);
window.addEventListener('offline',updateNet);

// Handle page visibility changes (screen lock, tab switch)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden - stop voice mode listening
    if (voiceModeRecognition) {
      stopVoiceModeListening();
      voiceModeSleeping = true;
      updateVoiceModeIndicator('sleeping');
      console.log('Voice mode paused (page hidden)');
    }
  } else {
    // Page is visible again - re-acquire Wake Lock if chat is open
    if (document.getElementById('askAIPanel')?.classList.contains('show')) {
      acquireWakeLock();
      console.log('Wake Lock re-acquired (page visible)');
    }
  }
});

document.addEventListener('DOMContentLoaded',()=>{
  initSR();render();counts();updateNet();initFiltersState();
  setTimeout(scrollToBottomInstant,50);
  
  // Initialize dark mode
  if (localStorage.getItem('droplit_darkmode') === 'true') {
    document.getElementById('darkModeToggle')?.classList.add('active');
    document.body.classList.add('dark-mode');
  }
  
  // Initialize auto-speak
  if (localStorage.getItem('aski_auto_speak') === 'true') {
    document.getElementById('autoSpeakToggle')?.classList.add('active');
  }
  
  // Initialize voice mode
  if (localStorage.getItem('aski_voice_mode') === 'true') {
    document.getElementById('voiceModeToggle')?.classList.add('active');
  }
  
  // Initialize voice selector (OpenAI TTS)
  const savedVoice = localStorage.getItem('aski_voice') || 'nova';
  document.querySelectorAll('#voiceSelector .pill-m').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.voice === savedVoice);
  });
  
  // Load OpenAI API key on page load
  setTimeout(loadOpenAIKey, 100);
  
  // Initialize listen time
  const savedSeconds = localStorage.getItem('aski_listen_seconds') || '15';
  document.querySelectorAll('#listenCyclesSelector .pill-m').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.cycles === savedSeconds);
  });
  
  // Initialize font size
  const savedFontSize = localStorage.getItem('droplit_fontsize') || 'normal';
  document.body.classList.add('font-' + savedFontSize);
});

// ============================================
// SYNTRISE CORE INTEGRATION v0.1
// ============================================

const SYNTRISE_CONFIG = {
  API_URL: 'https://syntrise-core.vercel.app/api',
  USER_ID: 'c95e2b0c-1182-424d-ac0a-0f0566cf09fa',
  ENABLED: true
};

let syntriseSyncQueue = [];

// Sync single drop to Syntrise CORE
async function syncDropToCore(drop) {
  if (!SYNTRISE_CONFIG.ENABLED) return;
  try {
    const response = await fetch(`${SYNTRISE_CONFIG.API_URL}/drops/sync`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        user_id: SYNTRISE_CONFIG.USER_ID,
        drops: [{
          id: String(drop.id),
          content: drop.text,
          category: drop.category || 'uncategorized',
          tags: drop.tags || [],
          created_at: drop.created || new Date().toISOString()
        }]
      })
    });
    if (response.ok) {
      console.log(' Synced to Syntrise CORE:', drop.id);
    }
  } catch (e) {
    console.warn(' Syntrise sync queued:', e.message);
    syntriseSyncQueue.push(drop);
  }
}

// Get context for Aski from Syntrise CORE
async function getSyntriseContext(query) {
  // LEGACY: Old API - now using Supabase
  if (!SYNTRISE_CONFIG.ENABLED) return null;
  try {
    const response = await fetch(`${SYNTRISE_CONFIG.API_URL}/drops/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        user_id: SYNTRISE_CONFIG.USER_ID,
        query: query,
        limit: 5,
        threshold: 0.1
      })
    });
    const data = await response.json();
    return data.results || [];
  } catch (e) {
    console.warn('Syntrise context error:', e.message);
    return [];
  }
}

// ============================================
// DYNAMIC CONTEXT FROM SUPABASE (v0.9.58)
// ============================================

// Get fresh drops for ASKI context
async function getSupabaseContext(query, options = {}) {
  const {
    limit = 20,           // Max drops to return
    recentHours = 24,     // Include drops from last N hours
    searchEnabled = true  // Enable text search
  } = options;
  
  if (!supabaseClient || !currentUser) {
    console.log(' Supabase not ready for context');
    return { recent: [], relevant: [] };
  }
  
  try {
    const context = { recent: [], relevant: [] };
    
    // 1. Get RECENT drops (last N hours)
    const recentSince = new Date(Date.now() - recentHours * 60 * 60 * 1000).toISOString();
    
    const { data: recentDrops, error: recentError } = await supabaseClient
      .from('drops')
      .select('content, category, created_at, metadata')
      .eq('user_id', currentUser.id)
      .gte('created_at', recentSince)
      .order('created_at', { ascending: false })
      .limit(limit);
    
    if (!recentError && recentDrops) {
      context.recent = recentDrops.map(d => ({
        text: d.content,
        category: d.category,
        time: d.metadata?.time || '',
        date: d.metadata?.date || ''
      }));
      console.log(` Context: ${recentDrops.length} recent drops`);
    }
    
    // 2. SEARCH relevant drops by keywords (if query provided)
    if (searchEnabled && query && query.length > 2) {
      // Extract keywords (simple: split and filter)
      const keywords = query.toLowerCase()
        .split(/\s+/)
        .filter(w => w.length > 3)
        .slice(0, 3); // Max 3 keywords
      
      if (keywords.length > 0) {
        // Search using ilike for each keyword
        const searchPattern = `%${keywords[0]}%`;
        
        const { data: relevantDrops, error: searchError } = await supabaseClient
          .from('drops')
          .select('content, category, created_at, metadata')
          .eq('user_id', currentUser.id)
          .ilike('content', searchPattern)
          .order('created_at', { ascending: false })
          .limit(5);
        
        if (!searchError && relevantDrops) {
          context.relevant = relevantDrops.map(d => ({
            text: d.content,
            category: d.category,
            time: d.metadata?.time || '',
            date: d.metadata?.date || ''
          }));
          console.log(` Context: ${relevantDrops.length} relevant drops for "${keywords[0]}"`);
        }
      }
    }
    
    return context;
    
  } catch (error) {
    console.error(' Supabase context error:', error);
    return { recent: [], relevant: [] };
  }
}

// Format context for AI prompt
function formatContextForAI(context) {
  if (!context || (!context.recent?.length && !context.relevant?.length)) {
    return null;
  }
  
  let formatted = [];
  
  // Add relevant drops first (if any)
  if (context.relevant?.length) {
    formatted.push('=== RELEVANT NOTES ===');
    context.relevant.forEach(d => {
      formatted.push(`[${d.category}] ${d.text}`);
    });
  }
  
  // Add recent drops
  if (context.recent?.length) {
    formatted.push('=== RECENT NOTES (last 24h) ===');
    context.recent.slice(0, 10).forEach(d => {
      const timeStr = d.time ? ` (${d.time})` : '';
      formatted.push(`[${d.category}]${timeStr} ${d.text}`);
    });
  }
  
  return formatted.join('\n');
}

// Sync all existing drops in batches (to avoid timeout)
async function syncAllDropsToCore() {
  if (!SYNTRISE_CONFIG.ENABLED) {
    console.log('Syntrise sync disabled');
    return { synced: 0, error: 'disabled' };
  }
  
  // Filter text drops only
  const textDrops = ideas.filter(drop => drop.text && !drop.isMedia);
  
  if (!textDrops.length) {
    console.log('No drops to sync');
    return { synced: 0, error: 'no_drops' };
  }
  
  console.log(' Syncing', textDrops.length, 'drops in batches...');
  
  const BATCH_SIZE = 5;
  let totalSynced = 0;
  let errors = [];
  
  // Split into batches
  for (let i = 0; i < textDrops.length; i += BATCH_SIZE) {
    const batch = textDrops.slice(i, i + BATCH_SIZE);
    const batchNum = Math.floor(i / BATCH_SIZE) + 1;
    const totalBatches = Math.ceil(textDrops.length / BATCH_SIZE);
    
    console.log(`Batch ${batchNum}/${totalBatches}...`);
    
    try {
      const response = await fetch(`${SYNTRISE_CONFIG.API_URL}/drops/sync`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: SYNTRISE_CONFIG.USER_ID,
          drops: batch.map(drop => ({
            id: String(drop.id),
            content: drop.text,
            category: drop.category || 'uncategorized',
            created_at: drop.timestamp || new Date().toISOString()
          }))
        })
      });
      
      if (response.ok) {
        const data = await response.json();
        totalSynced += data.synced || 0;
      } else {
        errors.push(`Batch ${batchNum} failed`);
      }
    } catch (e) {
      errors.push(`Batch ${batchNum}: ${e.message}`);
    }
    
    // Small delay between batches
    if (i + BATCH_SIZE < textDrops.length) {
      await new Promise(r => setTimeout(r, 500));
    }
  }
  
  console.log(` Synced ${totalSynced}/${textDrops.length} drops`);
  
  if (errors.length) {
    return { synced: totalSynced, error: errors.join(', ') };
  }
  return { synced: totalSynced };
}

// Expose for console access
window.SyntriseCore = {
  sync: syncDropToCore,
  syncAll: syncAllDropsToCore,
  getContext: getSyntriseContext,
  config: SYNTRISE_CONFIG
};

// Sync to Cloud button handler
async function syncToCloud() {
  const textDrops = ideas.filter(drop => drop.text && !drop.isMedia);
  if (!textDrops.length) {
    toast('No text drops to sync', 'info');
    return;
  }
  
  const batches = Math.ceil(textDrops.length / 5);
  toast(`Syncing ${textDrops.length} drops (${batches} batches)...`, 'info');
  
  try {
    const result = await syncAllDropsToCore();
    if (result.error === 'disabled') {
      toast('Cloud sync is disabled', 'info');
    } else if (result.error && result.synced === 0) {
      toast('Sync failed: ' + result.error, 'error');
    } else if (result.synced > 0) {
      toast('Synced ' + result.synced + ' drops!', 'success');
    } else {
      toast('All drops already synced', 'success');
    }
  } catch (e) {
    toast('Sync error: ' + e.message, 'error');
  }
}

// ============================================
// PUSH NOTIFICATIONS & PROACTIVE INSIGHTS
// ============================================

let currentInsight = null;
const INSIGHTS_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes

// Register Service Worker
async function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    try {
      const registration = await navigator.serviceWorker.register('/sw-droplit.js');
      console.log(' Service Worker registered');
      return registration;
    } catch (error) {
      console.warn(' Service Worker registration failed:', error);
    }
  }
}

// Check notification permission
function checkNotificationPermission() {
  if (!('Notification' in window)) {
    console.log('Notifications not supported');
    return;
  }
  
  if (Notification.permission === 'default') {
    // Show permission banner after 30 seconds
    setTimeout(() => {
      const dismissed = localStorage.getItem('notif_banner_dismissed');
      if (!dismissed) {
        document.getElementById('notifBanner').classList.add('show');
      }
    }, 30000);
  }
}

// Request notification permission
async function requestNotifPermission() {
  try {
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      toast(' !', 'success');
      // Test notification
      new Notification('DropLit', {
        body: ' ASKI    !',
        icon: '/icons/icon-192.png'
      });
    }
  } catch (error) {
    console.error('Notification permission error:', error);
  }
  dismissNotifBanner();
}

// Dismiss notification banner
function dismissNotifBanner() {
  document.getElementById('notifBanner').classList.remove('show');
  localStorage.setItem('notif_banner_dismissed', 'true');
}

// Check for pending insights
async function checkPendingInsights() {
  if (!currentUser) return;
  
  try {
    // Get session token for RLS
    const { data: { session } } = await supabase.auth.getSession();
    const token = session?.access_token || SUPABASE_ANON_KEY;
    
    const response = await fetch(
      `${SUPABASE_URL}/rest/v1/core_insights?user_id=eq.${currentUser.id}&status=eq.pending&order=priority.desc&limit=1`,
      {
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    const insights = await response.json();
    
    if (insights?.length > 0) {
      showInsightBanner(insights[0]);
    }
  } catch (error) {
    console.warn('Check insights error:', error);
  }
}

// Show insight banner
function showInsightBanner(insight) {
  currentInsight = insight;
  
  const banner = document.getElementById('insightsBanner');
  const title = document.getElementById('insightTitle');
  const text = document.getElementById('insightText');
  
  // Set icon based on type
  const icon = banner.querySelector('.insights-banner-icon');
  if (insight.insight_type === 'birthday_reminder') {
    icon.textContent = '';
  } else if (insight.insight_type === 'event_reminder') {
    icon.textContent = '';
  } else {
    icon.textContent = '';
  }
  
  title.textContent = insight.title;
  text.textContent = insight.content;
  
  banner.classList.add('show');
  
  // Also show browser notification if permitted
  if (Notification.permission === 'granted') {
    new Notification(insight.title, {
      body: insight.content,
      icon: '/icons/icon-192.png',
      tag: `insight-${insight.id}`
    });
  }
}

// Dismiss insight
async function dismissInsight() {
  document.getElementById('insightsBanner').classList.remove('show');
  
  if (currentInsight && currentUser) {
    try {
      // Get session token for RLS
      const { data: { session } } = await supabase.auth.getSession();
      const token = session?.access_token || SUPABASE_ANON_KEY;
      
      await fetch(
        `${SUPABASE_URL}/rest/v1/core_insights?id=eq.${currentInsight.id}`,
        {
          method: 'PATCH',
          headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=minimal'
          },
          body: JSON.stringify({ status: 'dismissed' })
        }
      );
    } catch (error) {
      console.warn('Dismiss insight error:', error);
    }
  }
  
  currentInsight = null;
}

// Initialize proactive features
function initProactiveFeatures() {
  registerServiceWorker();
  checkNotificationPermission();
  
  // Check insights on load (after auth)
  setTimeout(checkPendingInsights, 3000);
  
  // Periodic check
  setInterval(checkPendingInsights, INSIGHTS_CHECK_INTERVAL);
}

// Start when DOM ready
document.addEventListener('DOMContentLoaded', () => {
  setTimeout(initProactiveFeatures, 2000);
});

console.log(' Syntrise CORE integration loaded');
console.log(' Proactive features initialized');
</script>
</body>
</html>
